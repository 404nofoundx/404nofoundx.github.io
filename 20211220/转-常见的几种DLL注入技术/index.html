<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="baidu-site-verification" content="code-Um7dmQVTiB"><title>常见的几种DLL注入技术 - R1024</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="R1024"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="R1024"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="DLL注入的核心就是把要注入的DLL的路径写到目标进程中，然后在目标进程中调用LoadLibrary函数，并且指定参数为保存了DLL路径的地址。"><meta property="og:type" content="blog"><meta property="og:title" content="R1024"><meta property="og:url" content="http://www.404nofoundx.top/20211220/%E8%BD%AC-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DDLL%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"><meta property="og:site_name" content="R1024"><meta property="og:description" content="DLL注入的核心就是把要注入的DLL的路径写到目标进程中，然后在目标进程中调用LoadLibrary函数，并且指定参数为保存了DLL路径的地址。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/nixiang.png"><meta property="article:published_time" content="2021-12-20T02:21:56.000Z"><meta property="article:modified_time" content="2022-01-06T02:41:29.076Z"><meta property="article:author" content="R1024"><meta property="article:tag" content="Win逆向"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/nixiang.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.404nofoundx.top/20211220/%E8%BD%AC-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DDLL%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},"headline":"常见的几种DLL注入技术","image":["https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/nixiang.png"],"datePublished":"2021-12-20T02:21:56.000Z","dateModified":"2022-01-06T02:41:29.076Z","author":{"@type":"Person","name":"R1024"},"publisher":{"@type":"Organization","name":"R1024","logo":{"@type":"ImageObject","url":{"text":"R1024"}}},"description":"DLL注入的核心就是把要注入的DLL的路径写到目标进程中，然后在目标进程中调用LoadLibrary函数，并且指定参数为保存了DLL路径的地址。"}</script><link rel="canonical" href="http://www.404nofoundx.top/20211220/%E8%BD%AC-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DDLL%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?52c041fd9882a2d4b05bb16f933cdf75";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">R1024</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/404nofoundx"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile">常见的几种DLL注入技术</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2021-12-20</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2022-01-06</time></span><span class="level-item"><a class="link-muted" href="/categories/Win%E9%80%86%E5%90%91/">Win逆向</a></span><span class="level-item">38 分钟读完 (大约5769个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><blockquote>
<p>原文链接: <a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269910.htm">https://bbs.pediy.com/thread-269910.htm</a></p>
</blockquote>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>这次实验是在WIN7 X86系统上进程，使用的编译器是VS2017。</p>
<p>所谓的DLL注入，其实就是在其他的进程中把我们编写的DLL加载进去。如下图所示</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_BM9HQM3THPU8RQP.jpg" alt="img"></p>
<p>而加载Dll的API就是LoadLibrary，它的参数是保存要加载的DLL的路径的地址。所以DLL注入的核心就是把要注入的DLL的路径写到目标进程中，然后在目标进程中调用LoadLibrary函数，并且指定参数为保存了DLL路径的地址。</p>
<p>要实现DLL注入，首先就要创建一个用来注入的DLL。在VS2017中要生成一个DLL项目，只需要向下图这样创建一个DLL工程就好</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_BVV2KNFRWDJD2QZ.jpg" alt="img"></p>
<p>在生成的文件中，有个dllmain.cpp，打开以后内容如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_CGUGFVSMK3TVY2F.jpg" alt="img"></p>
<p>当DLL的状态发生变化的时候，就会调用DllMain函数。而传递的ul_reason_for_call这个参数代表了4种不同的状态变化的情况，我们就可以根据这四种不同的状态根据需要来写出相应的代码，就会让注入的DLL执行我们需要的功能</p>
<table>
<thead>
<tr>
<th><strong>ul_reason_for_call的值</strong></th>
<th><strong>代表的状态</strong></th>
</tr>
</thead>
<tbody><tr>
<td>DLL_PROCESS_ATTACH</td>
<td>Dll刚刚映射到进程空间中</td>
</tr>
<tr>
<td>DLL_THREAD_ATTACH</td>
<td>进程中有新线程创建</td>
</tr>
<tr>
<td>DLL_THREAD_DETACH</td>
<td>进程中有新线程销毁</td>
</tr>
<tr>
<td>DLL_PROCESS_DETACH</td>
<td>Dll从进程空间中接触映射</td>
</tr>
</tbody></table>
<p>不过在实现DLL注入的时候用的DLL几乎都是在Dll刚刚映射到进程空间的时候就执行相关的代码。比如像下面这样，创建一个新线程来执行代码，这里在桌面打开一个文件来并写入加载这个DLL的进程的完成路径名。由于是独占方式打开，此时如果多个线程同时打开这个文件，CreateFile就会出错，错误码就会是32，根据这个来对线程进行休眠，等其他线程使用完了，再次打开文件进行操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Shlobj.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;shell32.lib&quot;</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_NAME <span class="meta-string">&quot;result.txt&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    CHAR szDesktopFile[MAX_PATH] = &#123; <span class="number">0</span> &#125;;  <span class="comment">//保存系统桌面路径</span></span><br><span class="line">    CHAR szFullFilePath[MAX_PATH] = &#123; <span class="number">0</span> &#125;; <span class="comment">//保存完成的加载DLL文件的文件路径</span></span><br><span class="line">    DWORD dwRetLen = <span class="number">0</span>, dwFileLen = <span class="number">0</span>;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获取桌面路径</span></span><br><span class="line">    bRet = <span class="built_in">SHGetSpecialFolderPath</span>(<span class="literal">NULL</span>, szDesktopFile, CSIDL_DESKTOP, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(szDesktopFile, <span class="string">&quot;\\&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(szDesktopFile, FILE_NAME);</span><br><span class="line">        <span class="keyword">while</span> (TRUE)</span><br><span class="line">        &#123;</span><br><span class="line">            hFile = <span class="built_in">CreateFile</span>( szDesktopFile,</span><br><span class="line">                                GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">                                <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                OPEN_ALWAYS,</span><br><span class="line">                                FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE)   <span class="comment">//打开文件错误</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">GetLastError</span>() == <span class="number">32</span>)    <span class="comment">//错误码是不是其他进程正在使用这个文件,是的话等待一会在继续打开</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">Sleep</span>(<span class="number">200</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szFullFilePath, MAX_PATH);    <span class="comment">//获取加载DLL的进程的完整路径</span></span><br><span class="line">                dwFileLen = <span class="built_in">strlen</span>(szFullFilePath);</span><br><span class="line">                szFullFilePath[dwFileLen] = <span class="string">&#x27;\r&#x27;</span>; <span class="comment">//由于是在WIN7运行，换行符是\r\n</span></span><br><span class="line">                szFullFilePath[dwFileLen + <span class="number">1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                <span class="built_in">SetFilePointer</span>(hFile, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_END);</span><br><span class="line">                <span class="built_in">WriteFile</span>(hFile, szFullFilePath, dwFileLen + <span class="number">2</span>, &amp;dwRetLen, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (hFile) <span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        &#123;</span><br><span class="line">            HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (hThread) <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">        <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击生成解决方案以后就可以在项目目录下找到相应的DLL文件，如下图。这个文件就是用来注入到其他进程的DLL。</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_NXYYK6CYEHK6UFZ.jpg" alt="img"></p>
<h1 id="二、代码框架"><a href="#二、代码框架" class="headerlink" title="二、代码框架"></a>二、代码框架</h1><p>由于要编写的代码中，只有注入功能不同，但是其他的辅助功能。比如，提权，获取进程PID等等是一样的，为了避免重复就先在这给出代码的框架。后面的不同注入技术只需根据需要加进去就好。注意，如果想要提权成功，需要用管理员权限运行代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_NAME <span class="meta-string">&quot;taskmgr.exe&quot;</span>    <span class="comment">//要注入的进程名，这个是任务管理器的进程名</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_NAME <span class="meta-string">&quot;InjectDll.dll&quot;</span>  <span class="comment">//要注入的DLL的名称</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPid, CHAR szDllName[])</span></span>;  <span class="comment">//注入DLL</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetPID</span><span class="params">(PCHAR pProName)</span></span>; <span class="comment">//根据进程名获取PID</span></span><br><span class="line"><span class="function">VOID <span class="title">ShowError</span><span class="params">(PCHAR msg)</span></span>;    <span class="comment">//打印错误信息</span></span><br><span class="line"><span class="function">BOOL <span class="title">EnbalePrivileges</span><span class="params">(HANDLE hProcess, <span class="keyword">char</span> *pszPrivilegesName)</span></span>;    <span class="comment">//提升进程权限</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CHAR szDllPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;  <span class="comment">//保存要注入的DLL的路径</span></span><br><span class="line">    DWORD dwPID = <span class="number">0</span>;                 <span class="comment">//保存要注入的进程的PID</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 提升当前进程令牌权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">EnbalePrivileges</span>(<span class="built_in">GetCurrentProcess</span>(), SE_DEBUG_NAME))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;权限提升失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dwPID = <span class="built_in">GetPID</span>(PROCESS_NAME);</span><br><span class="line">    <span class="keyword">if</span> (dwPID == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到要注入的进程\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">GetCurrentDirectory</span>(MAX_PATH, szDllPath);  <span class="comment">//获取程序的目录</span></span><br><span class="line">    <span class="built_in">strcat</span>(szDllPath, <span class="string">&quot;\\&quot;</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(szDllPath, DLL_NAME);               <span class="comment">//与DLL名字拼接得到DLL的完整路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;要注入的进程名:%s PID:%d\n&quot;</span>, PROCESS_NAME, dwPID);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;要注入的DLL的完整路径%s\n&quot;</span>, szDllPath);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">InjectDll</span>(dwPID, szDllPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Dll注入成功\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">exit:</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPid, CHAR szDllName[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">DWORD <span class="title">GetPID</span><span class="params">(PCHAR pProName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PROCESSENTRY32 pe32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE hSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    DWORD dwPID = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (hSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CreateToolhelp32Snapshot process %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    pe32.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(pe32);</span><br><span class="line">    bRet = <span class="built_in">Process32First</span>(hSnap, &amp;pe32);</span><br><span class="line">    <span class="keyword">while</span> (bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstrcmp</span>(pe32.szExeFile, pProName) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dwPID = pe32.th32ProcessID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bRet = <span class="built_in">Process32Next</span>(hSnap, &amp;pe32);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnap);</span><br><span class="line">exit:</span><br><span class="line">    <span class="keyword">return</span> dwPID;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">VOID <span class="title">ShowError</span><span class="params">(PCHAR msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s Error %d\n&quot;</span>, msg, <span class="built_in">GetLastError</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">BOOL <span class="title">EnbalePrivileges</span><span class="params">(HANDLE hProcess, <span class="keyword">char</span> *pszPrivilegesName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">    LUID luidValue = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TOKEN_PRIVILEGES tokenPrivileges = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 打开进程令牌并获取具有 TOKEN_ADJUST_PRIVILEGES 权限的进程令牌句柄</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;OpenProcessToken&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取本地系统的 pszPrivilegesName 特权的LUID值</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, pszPrivilegesName, &amp;luidValue))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;LookupPrivilegeValue&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 设置提升权限信息</span></span><br><span class="line">    tokenPrivileges.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tokenPrivileges.Privileges[<span class="number">0</span>].Luid = luidValue;</span><br><span class="line">    tokenPrivileges.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="comment">// 提升进程令牌访问权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tokenPrivileges, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;AdjustTokenPrivileges&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据错误码判断是否特权都设置成功</span></span><br><span class="line">        dwRet = ::<span class="built_in">GetLastError</span>();</span><br><span class="line">        <span class="keyword">if</span> (ERROR_SUCCESS == dwRet)</span><br><span class="line">        &#123;</span><br><span class="line">            bRet = TRUE;</span><br><span class="line">            <span class="keyword">goto</span> exit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ERROR_NOT_ALL_ASSIGNED == dwRet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ShowError</span>(<span class="string">&quot;ERROR_NOT_ALL_ASSIGNED&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> exit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">exit:</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、远程线程注入"><a href="#三、远程线程注入" class="headerlink" title="三、远程线程注入"></a>三、远程线程注入</h1><p>这种注入方式可以说是最常用的注入方式了，它的核心就是调用Windows提供的CreateRemoteThread函数。该函数可以在其他的进程空间中创建一个新的线程进行执行，该函数在文档中的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  __in   HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in   LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in   SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in   LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in   LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in   DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  __out  LPDWORD lpThreadId)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>hProcess</strong></td>
<td><strong>要创建线程的进程句柄</strong></td>
</tr>
<tr>
<td>lpThreadAttributes</td>
<td>新线程的安全描述符</td>
</tr>
<tr>
<td>dwStackSize</td>
<td>堆栈起始大小，为0表示默认大小</td>
</tr>
<tr>
<td><strong>lpStartAddress</strong></td>
<td><strong>表示要运行线程的起始地址</strong></td>
</tr>
<tr>
<td><strong>lpParameter</strong></td>
<td><strong>保存要传递给线程参数的地址</strong></td>
</tr>
<tr>
<td>dwCreationFlags</td>
<td>控制线程创建的标志，为0表示创建后立即执行</td>
</tr>
<tr>
<td>lpThreadId</td>
<td>指向接收线程标识符变量的指针。为NULL表示不返回线程标识符</td>
</tr>
</tbody></table>
<p>其中的关键三个参数分别是</p>
<ol>
<li>hProcess用来指定在哪个进程中创建新线程</li>
<li>lpStartAddress用来指定将进程中的哪个地址开始作为新线程运行的起始地址</li>
<li>lpParameter保存的也是一个地址，这个地址中保存的就是新线程要用到的参数</li>
</ol>
<p>那也就是说只要我们指定了一个地址给lpStartAddress，那么我们就可以在其他进程中创建一个线程来执行程序。而再看加载DLL的LoadLibrary函数在文档中的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HMODULE WINAPI <span class="title">LoadLibrary</span><span class="params">(__in  LPCTSTR lpFileName)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个函数同样也只需要一个参数，这个参数是一个地址，而这个地址中保存的是我们要加载的DLL的名称的字符串。</p>
<p>根据这些，不难想到，只要我们可以获取新进程中的LoadLibrary函数的地址以及包含有要加载的DLL的字符串的地址就可以通过CreateRemoteThread函数来成功开起一个线程执行LoadLibrary函数来加载我们的DLL。</p>
<p>那么现在的问题就是如何获得LoadLibrary函数的地址以及保存有要加载的DLL路径的字符串的地址。</p>
<p>对于LoadLibrary函数，由于它是在常用的系统DLL，也就是KERNEL32.dll中，所以这个DLL是可以按照它的ImageBase成功装载到每个进程的空间中。这样的话Kernel32.dll在每个进程中的起始地址是一样的，那么LoadLibrary函数的地址也就会一样。那么我们就可以在本进程中查找LoadLibrary函数的地址，并且完全可以相信，在要注入DLL的进程中LoadLibrary的地址也是这个。</p>
<p>至于DLL名称的字符串，我们可以通过在进程中申请一块可以将DLL完整路径写入的内存，并在这个内存中将DLL的完整路径写入，将写入到注入进程DLL完整路径的内存地址作为参数就可以实现进程的注入。</p>
<p>具体代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPid, CHAR szDllName[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hKernel32 = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    LPVOID pDllPathAddr = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pLoadLibraryAddr = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 打开注入进程，获取进程句柄</span></span><br><span class="line">    hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hProcess)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;OpenProcess&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在注入进程中申请可以容纳DLL完成路径名的内存空间</span></span><br><span class="line">    dwSize = <span class="number">1</span> + <span class="built_in">strlen</span>(szDllName);</span><br><span class="line">    pDllPathAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pDllPathAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;VirtualAllocEx&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 把DLL完整路径名写入进程中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, pDllPathAddr, szDllName, dwSize, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;WriteProcessMemory&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    hKernel32 = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hKernel32 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;LoadLibrary&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">    pLoadLibraryAddr = <span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pLoadLibraryAddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;GetProcAddress &quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建远程线程进行DLL注入</span></span><br><span class="line">    hRemoteThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, </span><br><span class="line">                      (LPTHREAD_START_ROUTINE)pLoadLibraryAddr,</span><br><span class="line">                       pDllPathAddr, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteThread == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;CreateRemoteThread&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">exit:</span><br><span class="line">    <span class="keyword">if</span> (hKernel32) <span class="built_in">FreeLibrary</span>(hKernel32);</span><br><span class="line">    <span class="keyword">if</span> (hProcess) <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteThread) <span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、加强版远程线程注入"><a href="#四、加强版远程线程注入" class="headerlink" title="四、加强版远程线程注入"></a>四、加强版远程线程注入</h1><p>上面的方法虽然可以方便的注入DLL。但是在WIN7,WIN10系统上，会由于SESSION 0隔离机制从而导致只能成功注入普通的用户进程，如果注入系统进程就会导致失败。而经过逆向分析发现，使用Kernel32.dll中的CreateRemoteThread进行注入的时候，程序会走到ntdll.dll中的ZwCreateThreadEx函数进行执行。这是一个未导出的函数，所以需要手动获取函数地址来进行调用，相比于CreateRemoteThread更加底层。这个函数在64位和32位系统中的函数声明也不相同，在32位中的声明如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *pFnZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">        ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">        HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">        BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">        DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID pUnkown)</span></span>;</span><br></pre></td></tr></table></figure>

<p>而在64位中的声明如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *pFnZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">        ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">        HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">        ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">        SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">        SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">        LPVOID pUnkown)</span></span>;</span><br></pre></td></tr></table></figure>

<p>根据逆向分析的结果，在内核6.0(WIN7, WIN10)等系统上调用CreateRemoteThread的时候，当程序走到ZwCreateThreaEx的时候它第7个参数，也就是CreateThreadFlags会被设置为1，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_3K6PUFGYUZU4YSV.jpg" alt="img"></p>
<p>它会导致线程创建的时候就被挂起，随后查看要运行的进程所在的会话层之后再决定是否要恢复线程的运行。所以要破解这种情况只需要将第7个参数设为0就可以，相应代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *pFnZwCreateThreadEx)</span><span class="params">(PHANDLE, ACCESS_MASK, LPVOID, </span></span></span><br><span class="line"><span class="params"><span class="function">                       HANDLE, LPTHREAD_START_ROUTINE,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID, BOOL, DWORD, DWORD, DWORD, LPVOID)</span></span>;</span><br><span class="line">                     </span><br><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPid, CHAR szDllName[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hRemoteThread = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hKernel32 = <span class="literal">NULL</span>, hNtDll = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    LPVOID pDllPathAddr = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pLoadLibraryAddr = <span class="literal">NULL</span>;</span><br><span class="line">    pFnZwCreateThreadEx ZwCreateThreadEx = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 打开注入进程，获取进程句柄</span></span><br><span class="line">    hProcess = ::<span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hProcess)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;OpenProcess&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在注入进程中申请可以容纳DLL完成路径名的内存空间</span></span><br><span class="line">    dwSize = <span class="number">1</span> + <span class="built_in">strlen</span>(szDllName);</span><br><span class="line">    pDllPathAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pDllPathAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;VirtualAllocEx&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 把DLL完成路径名写入进程中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, pDllPathAddr, szDllName, dwSize, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;WriteProcessMemory&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">     </span><br><span class="line">    hKernel32 = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hKernel32 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;LoadLibrary kernel32&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">    pLoadLibraryAddr = <span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pLoadLibraryAddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;GetProcAddress LoadLibraryA&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    hNtDll = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hNtDll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;LoadLibrary ntdll&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    ZwCreateThreadEx = (pFnZwCreateThreadEx)<span class="built_in">GetProcAddress</span>(hNtDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ZwCreateThreadEx)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;GetProcAddress ZwCreateThreadEx&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">ZwCreateThreadEx</span>(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, </span><br><span class="line">                     hProcess, (LPTHREAD_START_ROUTINE)pLoadLibraryAddr,</span><br><span class="line">                     pDllPathAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteThread == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">exit:</span><br><span class="line">    <span class="keyword">if</span> (hKernel32) <span class="built_in">FreeLibrary</span>(hKernel32);</span><br><span class="line">    <span class="keyword">if</span> (hNtDll) <span class="built_in">FreeLibrary</span>(hNtDll);</span><br><span class="line">    <span class="keyword">if</span> (hProcess) <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">if</span> (hRemoteThread) <span class="built_in">CloseHandle</span>(hRemoteThread);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、APC注入"><a href="#五、APC注入" class="headerlink" title="五、APC注入"></a>五、APC注入</h1><p>在Windows系统中，每个线程都会维护一个自己的APC队列，这个APC队列中保存了要求线程执行的一些APC函数。对于用户模式的APC队列，当线程处在可警告状态时，就会执行这些APC函数。而要往APC队列中增加APC函数，需要通过QueueUserAPC函数来实现，这个函数在文档中的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  __in  PAPCFUNC pfnAPC,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in  HANDLE hThread,</span></span></span><br><span class="line"><span class="params"><span class="function">  __in  ULONG_PTR dwData)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>pfnAPC</td>
<td>当满足条件时，要执行的APC函数的地址</td>
</tr>
<tr>
<td>hThread</td>
<td>指定增加APC函数的线程句柄</td>
</tr>
<tr>
<td>dwData</td>
<td>要执行的APC函数参数地址</td>
</tr>
</tbody></table>
<p>可以看到pfnAPC和dwData这两个参数和CreateRemoteThread中的lpStartAddress和lpParameter的作用是一样的。不过这里是对线程进行操作，一个进程有多个线程。所以为了确保程序正确运行，所以需要遍历所有线程，查看是否是要注入的进程的线程，依次获得句柄插入APC函数。具体代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPid, CHAR szDllName[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>, hThread = <span class="literal">NULL</span>, hSnap = <span class="literal">NULL</span>;</span><br><span class="line">    HMODULE hKernel32 = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    PVOID pDllPathAddr = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID pLoadLibraryAddr = <span class="literal">NULL</span>;</span><br><span class="line">    THREADENTRY32 te32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 打开注入进程，获取进程句柄</span></span><br><span class="line">    hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hProcess)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;OpenProcess&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在注入进程中申请可以容纳DLL完成路径名的内存空间</span></span><br><span class="line">    dwSize = <span class="number">1</span> + <span class="built_in">strlen</span>(szDllName);</span><br><span class="line">    pDllPathAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!pDllPathAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;VirtualAllocEx&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 把DLL完成路径名写入进程中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(hProcess, pDllPathAddr, szDllName, dwSize, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;WriteProcessMemory&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    hKernel32 = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;kernel32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hKernel32 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;LoadLibrary&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 获取LoadLibraryA函数地址</span></span><br><span class="line">    pLoadLibraryAddr = <span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (pLoadLibraryAddr == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;GetProcAddress&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//获得线程快照</span></span><br><span class="line">    hSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hSnap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;CreateToolhelp32Snapshot&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//遍历线程</span></span><br><span class="line">    te32.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(te32);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hSnap, &amp;te32))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这个线程的进程ID是不是要注入的进程的PID</span></span><br><span class="line">            <span class="keyword">if</span> (te32.th32OwnerProcessID == dwPid)</span><br><span class="line">            &#123;</span><br><span class="line">                hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);</span><br><span class="line">                <span class="keyword">if</span> (hThread)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)pLoadLibraryAddr, hThread, (ULONG_PTR)pDllPathAddr);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                    hThread = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">ShowError</span>(<span class="string">&quot;OpenThread&quot;</span>);</span><br><span class="line">                    bRet = FALSE;</span><br><span class="line">                    <span class="keyword">goto</span> exit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hSnap, &amp;te32));</span><br><span class="line">    &#125;</span><br><span class="line">exit:</span><br><span class="line">    <span class="keyword">if</span> (hKernel32) <span class="built_in">FreeLibrary</span>(hKernel32);</span><br><span class="line">    <span class="keyword">if</span> (hProcess) <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="keyword">if</span> (hThread) <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、AppInit-DLLs注入"><a href="#六、AppInit-DLLs注入" class="headerlink" title="六、AppInit_DLLs注入"></a>六、AppInit_DLLs注入</h1><p>这种注入方式主要是通过修改注册表中<strong>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows</strong>中的AppInit_DLLs和LoadAppInit_Dlls，如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_JZZAKG3GTBHTSQ9.jpg" alt="img"></p>
<p>只要将AppInit_DLLs设置为要注入的DLL的路径并且将LoadAppInit_DLLs的值改成1。那么，当程序重启的时候，所有加载user32.dll的进程都会根据AppInit_Dlls中的DLL路径加载指定的DLL。</p>
<p>所以这种DLL注入的实现代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPid, CHAR szDllName[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line">    HKEY hKey = <span class="literal">NULL</span>;</span><br><span class="line">    CHAR szAppKeyName[] = &#123; <span class="string">&quot;AppInit_DLLs&quot;</span> &#125;;</span><br><span class="line">    CHAR szLoadAppKeyName[] = &#123; <span class="string">&quot;LoadAppInit_DLLs&quot;</span> &#125;;</span><br><span class="line">    DWORD dwLoadAppInit = <span class="number">1</span>; <span class="comment">//设置LoadAppInit_DLLs的值</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//打开相应注册表键</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegOpenKeyEx</span>(HKEY_LOCAL_MACHINE, <span class="string">&quot;Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows&quot;</span>,</span><br><span class="line">        <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey) != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;RegOpenKeyEx&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//设置AppInit_DLLs为相应的DLL路径</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, szAppKeyName, <span class="number">0</span>, REG_SZ, (PBYTE)szDllName, <span class="built_in">strlen</span>(szDllName) + <span class="number">1</span>) != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;RegSetValueEx&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将LoadAppInit_DLLs的值设为1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">RegSetValueEx</span>(hKey, szLoadAppKeyName, <span class="number">0</span>, REG_DWORD, (PBYTE)&amp;dwLoadAppInit, <span class="built_in"><span class="keyword">sizeof</span></span>(dwLoadAppInit)) != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;RegSetValueEx&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">exit:</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序以后，会发现相应的键值已经被设置</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_ZEUHCVQQ2BXA7KR.jpg" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_52Q2U6ACPPRDYDB.jpg" alt="img"></p>
<h1 id="七、全局钩子注入"><a href="#七、全局钩子注入" class="headerlink" title="七、全局钩子注入"></a>七、全局钩子注入</h1><p>Windows系统中的大多数应用都是基于消息机制的，也就是说它们都有一个消息过程函数，可以根据收到的不同消息来执行不同的代码。基于这种消息机制，Windows维护了一个OS message queue以及为每个程序维护着一个application message queue。当发生各种事件的时候，比如敲击键盘，点击鼠标等等，操作系统会从OS message queue将消息取出给到相应的程序的application message queue。</p>
<p>而OS message queue和application message queue的中间有一个称为钩链的结果如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_KE3EM4G7BBBFPM8.jpg" alt="img"></p>
<p>在这个钩链中保存的就是设置的各种钩子函数，而这些钩子函数会比应用程序还早接收到消息并对消息进行处理。所以程序员可以通过在钩子中设置钩子函数，而要设置钩子函数就需要使用SetWindowHookEx来将钩子函数安装到钩链中，函数在文档中的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookEx</span><span class="params">(<span class="keyword">int</span> idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>idHook</td>
<td>要安装的钩子类型，为了挂全局钩子，这里选择WH_GETMESSAGE。表示的是安装一个挂钩过程，它监视发送到消息队列的消息</td>
</tr>
<tr>
<td>lpfn</td>
<td>表示的是钩子的回调函数。如果dwThreadId为0，则lpfn指向的钩子过程必须指向DLL中的钩子过程</td>
</tr>
<tr>
<td>hMod</td>
<td>包含由lpfn参数执行的钩子过程的DLL句柄</td>
</tr>
<tr>
<td>dwThreadId</td>
<td>与钩子过程关联的线程标识符，如果为0则表示与所有线程相关联。</td>
</tr>
</tbody></table>
<p>如果函数成功，则返回钩子过程的句柄，否则为NULL。</p>
<p>根据上面的介绍可以得知，想要创建一个全局钩子，就必须在DLL文件中创建。这是因为进程的地址空间是独立的，发生对应事件的进程不能调用其他进程地址空间的钩子函数。如果钩子函数的实现代码在DLL中，则在对应事件发生时，系统会把这个DLL加载到发生事件的进程地址空间中，使它可以调用钩子函数进行处理。</p>
<p>所以只要在系统中安装了全局钩子，那么只要进程接收到可以发出钩子的消息，全局钩子的DLL就会被系统自动或者强行加载到进程空间中，这就可以实现DLL注入。</p>
<p>而这里之所以设置为WH_GETMESSAGE，是因为这种类型的钩子会监视消息队列，又因为Windows系统是基于消息驱动的，所以所有的进程都会有自己的一个消息队列，都会加载WH_GETMESSAGE类型的全局钩子。</p>
<p>当idHook设置为WH_GETMESSAGE的时候，回调函数lpfn的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">GetMsgProc</span><span class="params">(<span class="keyword">int</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">                            WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">                            LPARAM lParam)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>指定钩子过程是否必须处理该消息。如果代码是HC_ACTION，则钩子过程必须处理该消息。如果代码小于零，则钩子过程必须将消息传递给CallNextHookEx函数而无需进一步处理，并且应该返回CallNextHookEx返回的值</td>
</tr>
<tr>
<td>wParam</td>
<td>指定消息是否已从队列中删除。此参数可以是以下值之一。PM_NOREMOVE:指定消息尚未从队列中删除PM_REMOVE:指定消息已从队列中删除</td>
</tr>
<tr>
<td>lParam</td>
<td>指向包含消息详细信息的MSG结构体的指针</td>
</tr>
</tbody></table>
<p>如果要卸载钩子，则需要使用UnhookWindowsHookEx，该函数定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UnhookWindowsHookEx</span><span class="params">(HHOOK hhk)</span></span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>hhk</td>
<td>需要卸载的钩子句柄。此参数是通过上一次调用SetWindowsHookEx获得的钩子句柄</td>
</tr>
</tbody></table>
<p>由于设置全局钩子的代码需要在DLL文件中完成，所以首先需要新建一个InjectDll.cpp。</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_UWZA69RMWUAQVJT.jpg" alt="img"></p>
<p>随后在文件中写入如下设置全局钩子的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> HMODULE g_hDllModule;</span><br><span class="line"><span class="comment">// 设置全局钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_hHook = <span class="built_in">SetWindowsHookEx</span>(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == g_hHook)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的回调函数的实现如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 钩子回调函数</span></span><br><span class="line"><span class="function">LRESULT <span class="title">GetMsgProc</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> code,</span></span></span><br><span class="line"><span class="params"><span class="function">    WPARAM wParam,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(g_hHook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只是简单的调用CallNextHookEx函数表示将当前钩子传递给钩链中的下一个钩子，第一个参数要指定当前钩子的句柄。如果直接返回0，则表示中断钩子传递，这就实现了对钩子进行拦截。</p>
<p>而g_hDllModule则是在DLL加载的时候被赋值的</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_GEPY4DNXCA748YS.jpg" alt="img"></p>
<p>当钩子不再使用，可以卸载掉全局钩子，这样此时已经包含钩子回调函数的DLL模块的进程就会释放DLL模块。卸载钩子的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 卸载钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnSetGlobalHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_hHook)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">UnhookWindowsHookEx</span>(g_hHook);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的全局钩子的设置，钩子回调函数的实现以及全局钩子的卸载都需要使用到全局钩子的句柄。为了让任意一个独立的进程中对句柄的修改都可以影响到其他进程，就需要在DLL中使用共享内存的，来保证将DLL中加载到多个进程以后，一个进程对它的修改可以影响到其他进程。设置共享内存的方式如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;mydata&quot;</span>)</span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/SECTION:mydata,RWS&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>而为了调用设置钩子和卸载钩子的函数，就需要创建一个.def文件来将两个函数导出</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_B5Y7DFYYCSKUEEP.jpg" alt="img"></p>
<p>此时使用PEID查看InjectDll.dll可以看到导出表有如下的导出函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_KJSTSA5TWNP4EQY.jpg" alt="img"></p>
<p>接下来只要在代码中将DLL引入并或者对应的函数对它们进行调用就好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InjectDll</span><span class="params">(DWORD dwPid, CHAR szDllName[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = TRUE;</span><br><span class="line">    HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">    pFnSetGlobalHook SetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line">    pFnUnSetGlobalHook UnSetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    hDll = <span class="built_in">LoadLibrary</span>(szDllName);</span><br><span class="line">    <span class="keyword">if</span> (hDll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;LoadLibrary&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    SetGlobalHook = (pFnSetGlobalHook)<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;SetGlobalHook&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (SetGlobalHook == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;GetProcAddress SetGlobalHook&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">SetGlobalHook</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;钩子安装失败\n&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;钩子安装成功,按回车卸载钩子\n&quot;</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    UnSetGlobalHook = (pFnUnSetGlobalHook)<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;UnSetGlobalHook&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (UnSetGlobalHook == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ShowError</span>(<span class="string">&quot;GetProcAddress UnSetGlobalHook&quot;</span>);</span><br><span class="line">        bRet = FALSE;</span><br><span class="line">        <span class="keyword">goto</span> exit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UnSetGlobalHook</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;已将全局钩子卸载\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">exit:</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、实验结果"><a href="#八、实验结果" class="headerlink" title="八、实验结果"></a>八、实验结果</h1><p>将编译好的exe文件和dll文件放到同一路径中，运行exe以后会在桌面生成一个result.txt文件。打开文件以后会看到里面的内容是被注入的进程的完整的路径名</p>
<p><img src="https://cdn.jsdelivr.net/gh/404nofoundx/ImageCloud/835440_VM7QKKQK93F34CQ.jpg" alt="img"></p>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Win%E9%80%86%E5%90%91/">Win逆向</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered"> </h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信公众号</span><span class="qrcode"><img src="/img/qrcode.jpg" alt="微信公众号"></span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>知识星球</span><span class="qrcode"><img src="/img/zhishi_100.png" alt="知识星球"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/20211222/WX%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Windows WX注入原理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/20211214/%E5%8F%8D%E5%88%B6Unidbg/"><span class="level-item">反制Unidbg</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="waline-thread"></div><script src="https://cdn.jsdelivr.net/npm/@waline/client@1.3.1/dist/Waline.min.js"></script><script>Waline({
            el: '#waline-thread',
            serverURL: "https://blog-api-ab4zca1le-404nofoundx.vercel.app/",
            lang: "zh-CN",
            visitor: false,
            emoji: ["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],
            dark: "auto",
            meta: ["nick","mail"],
            requiredMeta: [],
            login: "enable",
            avatar: "mp",
            
            pageSize: 10,
            avatarCDN: "https://sdn.geekzu.org/avatar/",
            avatarForce: false,
            highlight: true,
            mathTagSupport: false,
            copyright: true,
            locale: {"placeholder":"Comment here..."},
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="R1024"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">R1024</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">42</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/404nofoundx" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、前言"><span class="level-left"><span class="level-item">一、前言</span></span></a></li><li><a class="level is-mobile" href="#二、代码框架"><span class="level-left"><span class="level-item">二、代码框架</span></span></a></li><li><a class="level is-mobile" href="#三、远程线程注入"><span class="level-left"><span class="level-item">三、远程线程注入</span></span></a></li><li><a class="level is-mobile" href="#四、加强版远程线程注入"><span class="level-left"><span class="level-item">四、加强版远程线程注入</span></span></a></li><li><a class="level is-mobile" href="#五、APC注入"><span class="level-left"><span class="level-item">五、APC注入</span></span></a></li><li><a class="level is-mobile" href="#六、AppInit-DLLs注入"><span class="level-left"><span class="level-item">六、AppInit_DLLs注入</span></span></a></li><li><a class="level is-mobile" href="#七、全局钩子注入"><span class="level-left"><span class="level-item">七、全局钩子注入</span></span></a></li><li><a class="level is-mobile" href="#八、实验结果"><span class="level-left"><span class="level-item">八、实验结果</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">R1024</a><p class="is-size-7"><span>&copy; 2022</span>  Zhan  ♡  RR<br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客, <span id="busuanzi_value_site_pv">0</span>次访问</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://blog.csdn.net/qq_41179280?spm=1000.2115.3001.5343"><i class="fab fa-weibo"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://blog.csdn.net/qq_41179280?spm=1000.2115.3001.5343"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/404nofoundx"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script type="text/javascript" src="/js/love.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>