{"pages":[{"title":"知识星球小彩蛋","text":"","link":"/about/index.html"}],"posts":[{"title":"20211208|每日算法—两数之和","text":"咬定青山不放松，立根原在破岩中。千磨万击还坚劲，任尔东西南北风。 0x001、两数之和地址：https://leetcode-cn.com/problems/two-sum/ 方法一、暴力循环 1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1,len(nums)): if nums[i]+nums[j]==target: return [i,j] return [] 方法二、哈希表 123456789class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: item = {} for i in range(len(nums)): if target-nums[i] in item: return [item[target-nums[i]],i] else: item[nums[i]] = i return [] 0x002、盛最多水的容器地址：https://leetcode-cn.com/problems/container-with-most-water/ 木桶能装多少水取决于最短的木板。 方法一、双指针 左右指针，每次移动比较矮的一侧。 123456789101112class Solution: def maxArea(self, height: List[int]) -&gt; int: left,right = 0,len(height)-1 max_area = 0 while left&lt;right: area = (right-left)*(min(height[right],height[left])) max_area = max(max_area,area) if height[left]&gt;=height[right]: right-=1 else: left+=1 return max_area 0x003、三数之和地址：https://leetcode-cn.com/problems/3sum/方法一、排序+双指针 长度小于3返回空列表 排序 取锚点元素，如果锚点元素大于0，代表后面没有三数和为零的元素，直接break，毕竟排过序 取锚点元素后一个为左指针left，最后一个为右指针right 循环 left&lt;right 三数和大于零，右边距向左移动一位 三数和小于零，左边距向右移动一位 三数和等于零，添加到result 判断左右边距是否重合，left是否等于left+1 left+=1 判断左右边距是否重合，right是否等于right-1 right-=1 收缩左右边距 12345678910111213141516171819202122232425262728class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: lenght = len(nums) result = list() if lenght&lt;3: return result nums.sort() for i in range(lenght): if nums[i]&gt;0: break if i&gt;0 and nums[i]==nums[i-1]: continue left,right = i+1,lenght-1 while left&lt;right: flag = nums[i] + nums[left] + nums[right] if flag&gt;0: right-=1 elif flag&lt;0: left+=1 else: result.append([nums[i],nums[left],nums[right]]) while left&lt;right and nums[left]==nums[left+1]: left+=1 while left&lt;right and nums[right]==nums[right-1]: right-=1 right-=1 left+=1 return result","link":"/20211108/20211208%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"},{"title":"20211209|每日算法—最接近的三数之和","text":"疾风知劲草，板荡识诚臣。勇夫安识义，智者必怀仁。 0x001、最接近的三数之和地址：https://leetcode-cn.com/problems/3sum-closest/ 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 实例一123输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 方法一、排序+双指针 1234567891011121314151617181920212223242526272829303132class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: nums.sort() flag = float(&quot;inf&quot;) lenght = len(nums) for i in range(lenght): if i&gt;0 and nums[i]==nums[i-1]: continue left,right = i+1,lenght-1 while left&lt;right: curr = nums[i]+nums[left]+nums[right] if curr==target: return curr elif curr&lt;target: flag = self.update_flag(flag=flag,curr=curr,target=target) # 解决重复 while left&lt;right and nums[left]==nums[left+1]: left+=1 left+=1 else: flag = self.update_flag(flag=flag,curr=curr,target=target) # 解决重复 while left&lt;right and nums[right]==nums[right-1]: right-=1 right-=1 return flag def update_flag(self,flag,curr,target): if abs(curr-target)&lt;abs(flag-target): return curr return flag","link":"/20211109/20211209%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"},{"title":"ARM指令集","text":"1 、LDR 和 STR加载/存储字和无符号字节指令，使用单一数据传送指令(STR 和 LDR)来装载和存储，单一字节或字的数据从/到内存LDR指令用于从内存中读取数据放入寄存器中，STR指令用于将寄存器中的数据保存到内存。 指令格式如下： 1234567LDR{cond}{T} Rd,&lt;地址&gt; ;加载指定地址上的数据(字),放入 Rd 中 STR{cond}{T} Rd,&lt;地址&gt; ;存储数据(字)到指定地址的存储单元,要存储的数据在 Rd 中 LDR{cond}B{T} Rd,&lt;地址&gt; ;加载字节数据,放入 Rd 中,即 Rd 最低字节有效,高 24 位清零 STR{cond}B{T} Rd,&lt;地址&gt; ;存储字节数据,要存储的数据在 Rd,最低字节有效 2、LDM 和 STM批量加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数，LDM 为加载多个寄存器，STM 为存储多个寄存器，允许一条指令传送 16 个寄存器任何子集或所有寄存器。LDM /STM 的主要用途是现场保护、数据复制、参数传送等。 指令格式如下: 1234567LDM{cond}&lt;模式&gt; Rn{!},reglist{^} STM{cond}&lt;模式&gt; Rn{!},reglist{^} LDMIA R0!,{R3-R9} ;加载 R0 指向的地址上的多字数据,保存到 R3～R9 中,R0 值更新 STMIA R1!,{R3-R9} ;将 R3～R9 的数据存储到 R1 指向的地址上,R1 值更新 STMFD SP!,{R0-R7,LR} ;现场保存,将 R0～R7、LR 入栈 LDMFD SP!,{R0-R7,PC}^;恢复现场,异常处理返回 3、 SWP寄存器和存储器交换指令，SWP 指令用于将一个内存单元(该单元地址放在寄存器Rn 中)的内容读取到一个寄存器 Rd 中,同时将另一个寄存器 Rm 的内容写入到该内存单元中。 指令格式如下: SWP{cond}{B} Rd,Rm,[Rn]、 其中，B 为可选后缀,若有B，则交换字节，否则交换 32 位字；Rd 为数据从存储器加载到的寄存器；Rm 的数据用于存储到存储器中，若 Rm 与 Rn 相同，则为寄存器与存储器内容进行交换；Rn 为要进行数据交换的存储器地址,Rn 不能与 Rd 和 Rm 相同. SWP 指令举例如下： 123SWP R1,R1,[R0] ;将 R1 的内容与 R0 指向的存储单元的内容进行交换 SWP R1,R2,,[R0] ;将R0指向的存储单元内容读取一字节数据到R1中(高24 位清零),并将R2的内容写入到该内存单元中(最低字节有效) ​ ​ 数据传送指令4、MOV数据传送指令，将 8 位图立即数或寄存器(operant2)传送到目标寄存器 Rd，可用于移位运算等操作。 指令格式如下： MOV{cond}{S} Rd,operand2 MOV 指令举例如下: 12345MOV R1#0x10 ;R1=0x10 MOV R0,R1 ;R0=R1 MOVS R3,R1,LSL #2 ;R3=R1＜＜2,并影响标志位 MOV PC,LR ;PC=LR ,子程序返回 5、MVN数据非传送指令，将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数。 指令格式如下: MVN{cond}{S} Rd,operand2 MVN 指令举例如下: 12MVN R1,#0xFF ;R1=0xFFFFFF00 MVN R1,R2 ;将 R2 取反,结果存到 R1 算术逻辑运算指令6、ADD加法运算指令，将 operand2 数据与 Rn 的值相加，结果保存到 Rd 寄存器。 指令格式如下： ADD{cond}{S} Rd,Rn,operand2 ADD 指令举例如下: 123ADDS R1,R1,#1 ;R1=R1+1 ADD R1,R1,R2 ;R1=R1+R2 ADDS R3,R1,R2,LSL #2 ;R3=R1+R2＜＜2 7、SUB减法运算指令，用寄存器 Rn 减去 operand2.结果保存到 Rd 中。 指令格式如下：SUB{cond}{S} Rd,Rn,operand2 SUB 指令举例如下： 1234SUBS R0,R0,#1 ;R0=R0-1 SUBS R2,R1,R2 ;R2=R1-R2 SUB R6,R7,#0x10 ;R6=R7-0x10 8、RSB逆向减法指令，用寄存器 operand2 减法 Rn，结果保存到 Rd 中。 指令格式如下：RSB{cond}{S} Rd,Rn,operand2 RSB 指令举例如下： 123RSB R3,R1,#0xFF00 ;R3=0xFF00-R1 RSBS R1,R2,R2,LSL #2 ;R1=R2＜＜2-R2=R2×3 RSB R0,R1,#0 ;R0=-R1 9、ADC带进位加法指令，将 operand2 的数据与 Rn 的值相加，再加上 CPSR 中的 C 条件标志位，结果保存到 Rd 寄存器。 指令格式如下; ADC{cond}{S} Rd,Rn,operand2 ADC 指令举例如下: 12ADDS R0,R0,R2 ADC R1,R1,R3 ;使用 ADC 实现 64 位加法,(R1、R0)=(R1、R0)+（R3、R2） 10、SBC带进位减法指令。用寄存器 Rn 减去 operand2，再减去 CPSR 中的 C 条件标志位的非（即若 C 标志清零，则结果减去 1），结果保存到 Rd 中。 指令格式如下： SCB{cond}{S} Rd,Rn,operand2 SBC 指令举例如下： 12SUBS R0，R0，R2 SBC R1，R1，R3 ;使用 SBC 实现 64 位减法,(R1,R0)-(R3,R2) 11、RSC带进位逆向减法指令。用寄存器 operand2 减去 Rn，再减去 CPSR 中的 C 条件标志位，结果保存到 Rd 中。 指令格式如下：RSC{cond}{S} Rd,Rn,operand2 RSC 指令举例如下： 12RSBS R2,R0,#0 RSC R3,R1,#0 ;使用 RSC 指令实现求 64 位数值的负数 12、AND逻辑与操作指令，将 operand2 值与寄存器 Rn 的值按位作逻辑与操作，结果保存到Rd 中。 指令格式如下： AND{cond}{S} Rd,Rn,operand2 AND 指令举例如下: 12ANDS R0,R0,#x01 ;R0=R0&amp;0x01,取出最低位数据 AND R2,R1,R3 ;R2=R1&amp;R3 13、ORR逻辑或操作指令，将operand2的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中。 指令格式如下：ORR{cond}{S} Rd,Rn,operand2 ORR 指令举例如下: 123ORR R0,R0,#x0F ;将 R0 的低 4 位置 1 MOV R1,R2,LSR #4 ORR R3,R1,R3,LSL #8 ;使用 ORR 指令将近 R2 的高 8 位数据移入到 R3 低 8 位 中 14、 EOR逻辑异或操作指令。将operand2的值与寄存器Rn的值按位作逻辑异或操作，结果保存到 Rd 中。 指令格式如下： EOR{cond}{S} Rd,Rn,operand2 EOR 指令举例如下 123EOR R1,R1,#0x0F ;将 R1 的低 4 位取反 EOR R2,R1,R0 ;R2=R1^R0 EORS R0,R5,#0x01 ;将 R5 和 0x01 进行逻辑异或,结果保存到 R0,并影响标志位","link":"/20211130/ARM%E6%8C%87%E4%BB%A4%E9%9B%86/"},{"title":"ARM汇编小结","text":"一、ARM汇编规范1、书写规范 所有的符号都必须在一行书写，在后面不用添加高级语言所用的分号。 ARM汇编器对标识符的大小写敏感，书写符号以及指令时字母大小写一定要一致。 一条ARM指令，伪指令。寄存器名可以全部写为大写字母,也可以全部为小写字母, 但是不能大小写混合编写使用。 注释使用(分号)，注释内容由(分号)开始到执行结束。 例如：[符号] &lt;指令|条件|S&gt; &lt;操作数&gt;[;注释] 2、符号符号可以代表地址、变量、数字变量，当符号代表地址时又叫标号，符号就是变量的变量名、数字常量的名称、标号，符号的命名规则如下： 符号由大小写字母、数字以及下划线组成； 除局部标号以数字开头外，其它的符号不能以数字开头； 符号区分大小写，且所有字符都是有意义的； 符号在其作用域范围必须是唯一的； 符号不能与系统内部或系统预定义的符号同名； 符号不要与指令助记符、伪指令同名。 3、常量常量的分类：数字常数、字符常量、布尔常量 （1）数字常数有三种表示方式： 十进制数，如：12、5、876、0 十六进制数如：0x4387、0xFF0、0x1 n 进制数用n-XXX 表示，其中n 为2～9，XXX 为具体的数，如：2-010111、8-4363156 （2）字符常量 字符常量由一对单引号及中间字符串表示，标准C 语言中的转义符也可使用。如果需要包含双引号或$，必须使用”” “”和$$代替。 如：Hello SETS “Hello World！” Errorl SETS “The parameter ““VFH””error$$2” （3）布尔常量 布尔常量的逻辑真为{TRUE}，逻辑假为{FALSE}。 如： testno SETS {FALSE} 4、ARM指令的格式ARM是三地址指令格式，指令的基本格式为： 1234567&lt;opcode&gt; {&lt;cond&gt;} {s} &lt;Rd&gt;, &lt;Rn&gt; {,&lt;operand2&gt;} opcode: 指令助记符 cond: 执行条件 s: 是否影响CPSR寄存器的值 Rd: 目标寄存器 Rn: 第一个操作数的寄存器 operand2: 第二个操作数 其中&lt; &gt;号内为必须的，{ }里面的项是可选的 5、跳转指令B 无条件跳转 BEQ 相等后跳转 BNE 不相等后跳转 BL 带链接的无条件跳转 BX 带状态切换的无条件跳转 根据目标地址最低位切换状态（arm/thumb） BLX 带链接和状态切换的无条件跳转 B loc_地址 6.存储器与寄存器交互数据指令存储器（主存，内存）寄存器中放的数据：可以是字符串，可以是数，也可以是一个地址，它可以放各种类型的数据存储地址单元：地址（如0x00004000）与地址中存在的值 A、LDR指令 (Load from memory into register)LDR指令的格式： LDR{条件} 目的寄存器 &lt;存储器地址&gt; 作用：将存储器地址所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 ← LDR指令的寻址方式比较灵活,实例如下： 123456789101112131415161718192021LDR R0，[R1] ；将存储器地址为R1的字数据读入寄存器R0。LDR R0，[R1，R2] ；将存储器地址为R1+R2的字数据读入寄存器R0。LDR R0，[R1，#8] ；将存储器地址为R1+8的字数据读入寄存器R0。LDR R0，[R1],R2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1],#8 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+8的值存入R1。LDR R0，[R1，R2]! ；将存储器地址为R1+R2的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1，LSL #3] ；将存储器地址为R1*8的字数据读入寄存器R0。LDR R0，[R1，R2，LSL #2] ；将存储器地址为R1+R2*4的字数据读入寄存器R0。LDR R0，[R1,,R2，LSL #2]！ ；将存储器地址为R1+R2*4的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，[R1],R2，LSL #2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，Label ；Label为程序标号，Label必须是当前指令的-4~4KB范围内。 B、STR指令 (Store from a register into memory)STR指令的格式为： STR{条件} 源寄存器，&lt;存储器地址&gt; STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。→ 123456STR r1, [r0] ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中STR R0，[R1]，＃8 ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。STR R0，[R1，＃8] ；将R0中的字数据写入以R1＋8为地址的存储器中。 C、LDM指令 (Load from memory into register / Load much)LDM指令的格式为： LDM {cond} &lt;模式&gt; Rn{!},reglist{^} LDM是将内存中堆栈内的数据，批量的赋值给寄存器，即是出栈操作 → LDM R0,｛R1-R3｝将R0指向的存储单元的数据依次加载到R1,R2,R3寄存器 D、STM指令 (Store from a register into memory / Store much)STM指令的格式为： STM {cond} &lt;模式&gt; Rn{!},reglist{^} STM：将一个寄存器列表的数据存储到指定的存储器 ← STM R0,{R1-R3} ;把R1,R2,R3保存到堆栈R0中 E、PUSH和POPPUSH:将寄存器值推入堆栈 压栈--&gt; POP：将堆栈值推出到寄存器 出栈 &lt;-- F、SWPSWP将寄存器与存储器之间的数据进行交换 SWP指令的格式为： SWP Rd,Rm,[Rn] Rd 为数据从存储器加载到的寄存器；Rm的数据用于存储到存储器中，若Rm与Rn相同，则为寄存器与存储器内容进行交换；Rn为要进行数据交换的存储器地址，Rn不能与Rd和Rm相同。 123SWP R1, R1 [R0] ;将R1寄存器与R0指向的存储单元的内容进行交换SWP R1, R2, [R0] ;把R0所指向的内容读到R1，同时把R2的内容写到 [R0] 7、数据传送指令MOV：将立即数或寄存器的数据传送到目标寄存器 ← 1MOV R0, #8 ;R0=8 8、数据算术运算指令​ ←​ ADD,SUB,MUL,DIV (加、减、乘、除)​ 有符号，无符号运算；带进位运算 9、数据算术运算指令与：AND或：ORR异或：EOR 移位：实质是乘，除，类似于小数点移位，但相反。小数点左移，数变小；右移变大。但逻辑移位，左移变大，右移变小，且按2的倍数进行，因为是2进制。 LSL：逻辑左移←LSR：逻辑右移← LSL R0,R1，#2 ；R0=R1*4 LSR R0,R1，#2 ；R0=R1*2 10、比较指令CMP：比较 1CMP R0 #0 ;R0寄存器中的值与0比较","link":"/20210906/ARM%E6%B1%87%E7%BC%96%E5%B0%8F%E7%BB%93/"},{"title":"Docker布置mitmproxy镜像使用Python脚本拦截请求","text":"mitmproxy 就是用于 MITM 的 proxy，MITM 即中间人攻击（Man-in-the-middle-attack）。用于中间人攻击的代理首先会向正常的代理一样转发请求，保障服务端与客户端的通信，其次，会适时的查、记录其截获的数据，或篡改数据，引发服务端或客户端特定的行为。本文教会读者如何用Docker搭建一个mitmproxy服务。 一、官方镜像及启动命令官方镜像 1docker pull mitmproxy/mitmproxy 1、挂载证书启动1docker run --rm -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -p 8080:8080 mitmproxy/mitmproxy 2、mitmdump加载脚本-v 将本地文件挂载到docker里面 1docker run --rm -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -v /mitm_proxy/:/usr/mitm_proxy -p 8899:8899 mitmproxy/mitmproxy mitmdump -p 8899 -s /usr/mitm_proxy/proxy.py 3、mitmweb1docker run --rm -it -p 8080:8080 -p 127.0.0.1:8081:8081 mitmproxy/mitmproxy mitmweb --web-host 0.0.0.0 二、定制自己的Docker1、创建Dockerfile创建自己的Docker的好处就是可以定制化下载各种各样的包 1234FROM mitmproxy/mitmproxyADD ./mitm_proxy /mitm_proxyWORKDIR /mitm_proxyRUN pip install PyMySQL 指令 说明 FROM 指定所创建镜像的基础镜像 ADD 赋值指定的路径下的内容到容器中的路径下，可以为URL；如果为tar文件，会自动解压到路径下(注意: 上边命令中.和/demo_mitm之间有空格，其中.表示宿主机的当前目录，即当前脚本所在目录,/demo_mitm表示docker容器目录，合起来的意思就是将宿主机当前目录下的文件拷贝至docker容器的/demo_mitm目录，文件夹不存在会自动创建) WORKDIR 配置工作目录，这里我配置的是/demo_mitm,即在上边通过ADD指令添加的目录下 RUN 在创建镜像时运行的命令，可写多个 2、Build1docker build -t demo_mitm:latest . 使用docker images，查看镜像 3、启动1docker run -i -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -v /data1/mitm_proxy/:/usr/mitm_proxy -p 8899:8899 demo_mitm mitmdump -p 8899 -s /usr/mitm_proxy/proxy.py 4、后台启动1docker run -i -d -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -v /data1/mitm_proxy/:/usr/mitm_proxy -p 8899:8899 demo_mitm mitmdump -p 8899 -s /usr/mitm_proxy/proxy.py 5、docker run参数123456789101112131415161718192021222324252627282930313233docker run --helpUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Run a command in a new container -a, --attach=[] Attach to stdin, stdout or stderr. -c, --cpu-shares=0 # 设置 cpu 使用权重 --cap-add=[] Add Linux capabilities --cap-drop=[] Drop Linux capabilities --cidfile=&quot;&quot; # 把容器 id 写入到指定文件 --cpuset=&quot;&quot; # cpu 绑定 -d, --detach=false Detached mode: Run container in the background, print new container id # 后台运行容器 --device=[] Add a host device to the container (e.g. --device=/dev/sdc:/dev/xvdc) --dns=[] # 设置 dns --dns-search=[] # 设置 dns 域搜索 -e, --env=[] # 定义环境变量 --entrypoint=&quot;&quot; Overwrite the default entrypoint of the image # ？ --env-file=[] # 从指定文件读取变量值 --expose=[] # 指定对外提供服务端口 -h, --hostname=&quot;&quot; # 设置容器主机名 -i, --interactive=false # 保持标准输出开启即使没有 attached --link=[] # 添加链接到另外一个容器 --lxc-conf=[] (lxc exec-driver only) Add custom lxc options --lxc-conf=&quot;lxc.cgroup.cpuset.cpus = 0,1&quot; -m, --memory=&quot;&quot; # 内存限制 --name=&quot;&quot; # 设置容器名 --net=&quot;bridge&quot; # 设置容器网络模式 'bridge': creates a new network stack for the container on the docker bridge 'none': no networking for this container 'container:&lt;name|id&gt;': reuses another container network stack 'host': use the host network stack inside the container. Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure. -P, --publish-all=false # 自动映射容器对外提供服务的端口 -p, --publish=[] # 指定端口映射 format: ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort (use 'docker port' to see the actual mapping) --privileged=false # 提供更多的权限给容器 --restart=&quot;&quot; Restart policy to apply when a container exits (no, on-failure[:max-retry], always) --rm=false # 如果容器退出自动移除和 -d 选项冲突 --security-opt=[] Security Options --sig-proxy=true Proxify received signals to the process (even in non-tty mode). SIGCHLD is not proxied. -t, --tty=false # 分配伪终端 -u, --user=&quot;&quot; # 指定运行容器的用户 uid 或者用户名 -v, --volume=[] # 挂载卷 --volumes-from=[] # 从指定容器挂载卷 -w, --workdir=&quot;&quot; # 指定容器工作目录","link":"/20211209/Docker%E5%B8%83%E7%BD%AEmitmproxy%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8mitmdump%E5%90%AF%E5%8A%A8Python%E8%84%9A%E6%9C%AC/"},{"title":"Crakeme01实战分析 IDA动态静态分析","text":"一、APK下载Crakeme01:Crakeme01.apk 二、jadx分析java代码根据AndroidManifest.xml找到程序入口 第一眼看到的System.loadLibrary()，就知道有NDK开发SO了，首先判断输入是否是空，非空的话调用NI.greywolf(this, this.editText.getText().toString());，而greywolf是 三、IDA静态分析上来一看，发现没有java_开头，敲定是动态注册，直接看伪代码。 跟进去AD()看下，发现里面全是各种反调试，动态调试的时候直接nop掉就ok。 四、IDA动态调试在JNI_OnLoad开头下断点，nop掉反调试的部分。 JNI_OnLoad有三个函数，找最后一个的函数就是RegisterNatives，然后找RegisterNatives中的第三个参数，里面包含着对应关系。 跟进去按C，找到个bc函数。 在静态分析中找到bc，分析逻辑，dh主要做的是调试检测，如果没有被反调试，则return 1，否则kill 然后再return 0，ds这个函数猜测是加解密用的，flag没准就是v4的返回值，动态调试试一下。 ds函数打断点，对照静态调试的伪代码，找到指令，BLX后的返回值推测是flag，查看R0寄存器。 找到flag=hello5.1，还不算难.jpg。","link":"/20210918/Crakeme01%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90-IDA%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"},{"title":"Frida主动调用函数","text":"一、 主动调用类方法(java静态方法)1public static String sign(String str1, int num1) 函数是有static关键字修饰的，所以是个类方法（静态方法）。 调用格式：类名引用.方法名（参数，…） 12345678910function call_sign(str1, num1) { Java.perform(function() { // 获取类 var onj = Java.use(&quot;类名&quot;); //调用类方法 因为这里是静态方法 所以可以直接调用 result = obj.sign(str1, num1); console.log(&quot;result: &quot; + result); });}setImmediate(call_sign) 二、 主动调用native类方法 (静态native方法）1public static native String sign(String st1) 这个函数有static关键字的 所以是个类方法（静态方法）这里有native 关键字 所以是个静态的c方法 调用格式：类名引用.方法名（参数，…） 123456789function call_sign(st1) { Java.perform(function() { // 获取类 var obj = Java.use(&quot;类名&quot;); //调用类方法 因为这里是静态方法 所以可以直接调用 result = obj.sign(st1); console.log(&quot;result: &quot; + result); });} 三、主动调用对象的java方法1public String sign(String str1) 函数是没有static关键字，所以是个对象方法（实例方法） 主动调用有2种方式： 直接获取内存中已存在的对象（建议使用） 创建一个新对象 因为运行过程中对象的成员的值可能已经发生变化，所以如果创建一个对象，新对象的值还是初始值，在调用算法或者函数的时候，可能会产生影响。 所以这里建议直接获取内存中已经有的对象 调用格式： instance.方法名（参数，…） //直接获取已有对象 类名引用.方法名（参数，…） //新创建的对象 1、直接获取内存中对象主动调用Frida的api： 12345678//从内存中（堆）直接搜索已存在的对象Java.choose('xxx.xxx.xxx '， //这里写类名 { //onMatch 匹配到对象执行的回调函数 onMatch: function(instance) {}, //堆中搜索完成后执行的回调函数 onComplete: function() {} }); 主动调用代码 123456789101112131415161718function call_sign(str1) { //这里写函数对应的类名 var class_name = &quot;类名&quot;; //返回值 Java.perform(function() { Java.choose(class_name, { onMatch: function(instance) { //调试用 console.log(&quot;onMatch &quot;); //直接调用对象的函数 instance是找到的对象 var result = instance.sign(str1); console.log(&quot;result: &quot; + result); }, onComplete: function() {} }); });} 2、创建一个新对象主动调用代码Frida创建对象的语法 $new() 1234 //获取类的引用var cls = Java.use('类名');//调用构造函数 创建新对象 这里注意参数var obj = cls.$new(); $new()是调用类的构造函数，新建一个对象。 注意两点 如果 没有构造函数 或 构造函数没有参数 直接写$new() 如果 构造函数有参数，那么一定要填参数 $new(参数，…) 创建一个对象，主动调用代码 1234567891011function call_sign(str1) { Java.perform(function() { //获取类的引用 var cls = Java.use(&quot;类名&quot;); //调用构造函数 创建新对象 这里注意参数 var obj = cls.$new(); //调用新对象的对象方法 enc var result = obj.sign(str1)； console.log(&quot;result: &quot; + result); });} 四、主动调用对象的native方法1public native String sign(String str1, int num1) 这个函数是没有有static关键字的，所以是个对象方法（实例方法）。 主动调用有2种方式： 直接获取内存中已存在的对象 自己创建一个新对象 建议直接获取内存中已经有的对象 调用格式： instance.方法名（参数，…） //直接获取已有对象 类名引用.方法名（参数，…） //新创建的对象 1、直接获取内存中对象主动调用1234567891011121314function call_sign(str1, num1) { var class_name = &quot;类名&quot;; Java.perform(function() { Java.choose(class_name, { onMatch: function(instance) { console.log(&quot;onMatch &quot;); //直接调用对象的函数 instance是找到的对象 var result = instance.sign(str1, num1); console.log(&quot;result: &quot; + result); }, onComplete: function() {} }); });} 2、创建一个新对象主动调用代码123456789101112function call_sign(str1, num1) { var class_name = &quot;类名&quot;; Java.perform(function() { //获取类的引用 var cls = Java.use(class_name); //调用构造函数 创建新对象 这里注意参数 var obj = cls.$new(); //调用新对象的对象方法 enc var result = obj.sign(str1, num1)； console.log(&quot;result: &quot; + result); });} 五、主动调用so方法1char* c_sign(char* p_str_data, int n_num) Frida用于调用c层函数的API 1NativeFunction(address, returnType, argTypes[, abi]) address：要hook的函数地址 returnType：返回值类型 argTypes[, abi]: 参数类型 这里参数可以是多个 NativeFunction支持的类型 12345678910111213141516171819202122Supported Types void pointer int uint long ulong char uchar size_t ssize_t float double int8 uint8 int16 uint16 int32 uint32 int64 uint64 bool 参数有两个 一个是 char* 一个是int NativeFunction是支持int这个类型的 但是没有char* 对于指针一系列的参数我们可以用 pointer表示，所以这里的返回值类型就是 ‘pointer’，参数类型是[‘pointer’, ‘int’] Tip： JavaScript 是没有char* 这个类型的，所以要通过frida的api去模拟，这里Memory.allocUtf8String()申请空间 存入字符串 模拟char*。 123456789101112131415161718192021function sign_c(str1, num1) { var str_name_so = &quot;libnative-lib.so&quot;; //要hook的so名 var str_name_func = &quot;c_sign&quot;; //要hook的函数名 //获取函数的地址 var func_addr = Module.findExportByName(str_name_so, str_name_func); console.log(&quot;func addr is:&quot; + func_addr); //定义NativeFunction 等下要调用 var func_c_sign = new NativeFunction(func_addr, 'pointer', ['pointer', 'int']); //调用frida的api申请空间 填入字符串 模拟char* var str_data_arg = Memory.allocUtf8String(str1); //调用so层的c函数 var p_str_result = func_c_sign(str_data_arg, num1); //读取字符串 var result = Memory.readCString(p_str_result); console.log(&quot;result:&quot; + result);}","link":"/20220110/Frida%E4%B8%BB%E5%8A%A8%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0/"},{"title":"IDA安卓10动态调试","text":"一、调式环境1、IDA Pro 7.5 2、Pixel 2 XL 安卓10 二、环境准备找到 IDA目录下的文件夹dbgsrv中的android_server，然后推到手机 /data/local/tmp目录 12PS D:\\IDA\\dbgsrv&gt; adb push .\\android_server /data/local/tmp.\\android_server: 1 file pushed, 0 skipped. 32.6 MB/s (786868 bytes in 0.023s) 然后切换到对应目录，给予777权限并启动，android_server默认端口23946 1234567891011PS C:\\Users\\Admin&gt; adb shelltaimen:/ $ sutaimen:/ # cd /data/local/tmp/127|taimen:/data/local/tmp # chmod 777 android_server//重要：安卓10 IDA Pro 7.5 要用这种方式启动android_server taimen:/data/local/tmp # IDA_LIBC_PATH=/apex/com.android.runtime/lib/bionic/libc.so /data/local/tmp/android_serverIDA Android 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020Listening on 0.0.0.0:23946... 特别注意：安卓10 IDA Pro 7.5 要用这种方式启动android_server IDA_LIBC_PATH=/apex/com.android.runtime/lib/bionic/libc.so /data/local/tmp/android_server 转发端口 1PS C:\\Users\\Admin&gt; adb forward tcp:23946 tcp:23946 adb shell执行命令 1234PS C:\\Users\\Admin\\Desktop\\apkHome&gt; adb shelltaimen:/ $ su 切换至root模式taimen:/ # magisk resetprop ro.debuggable 1 修改为全局可调式taimen:/ # stop;start; 重启 三、动态调试1、调试模式挂起app1adb shell am start -D -n com.example.javandk1/.MainActivity 2、Ida选择Linux/Android debugger 3、填入Host和Port 4、选择调试的APP 5 、加载完毕后，设置ida三钩、 6、DDMS查看挂机的端口 7、jdb放开调试1jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8600 接下来就可以动态调试了 IDA调试常用快捷键： F2快速下断点。 F7单步步入，F8单步步过。 F4运行到光标所在位置。 G跳到地址和函数名。 U解析成未定义数据。 C将数据解析成汇编指令。 光标放在函数头位置，按P键将汇编指令识别为函数。 CTRL+F搜索。 F5将汇编指令识别伪代码。 ALT+G查看当前指令是Thumb指令还是ARM指令。 CTRL+S看见系统所有的模块。 X交叉引用。","link":"/20210914/IDA%E5%AE%89%E5%8D%9310%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"},{"title":"Icarus 主题配置","text":"目录粘性定位原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 123456diff:source/js/main.js if ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); 12345diff:include/style/article.styl+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll","link":"/20210814/Icarus%E9%85%8D%E7%BD%AE/"},{"title":"NDK开发小结","text":"一、JNI作用：用于java代码和C++、c代码的交互（代码混编）。 分类使用：Jni静态注册、jni动态注册 二、静态注册1、定义被native修饰的方法1public native String Getstring(); 2、根据java代码生成.h头文件（javah -jni 类的包名路径）1javah -jni com.example.jnitest.MainActivity 3、编写C/C++代码，导入.h头文件，实现我们.h头文件中方法123456789#include &lt;JNItest.h&gt;JNIEXPORT jstring JNICALL Java_com_example_jnitest_MainActivity_Getstring (JNIEnv *env, jobject obj) { jstring str = (*env)-&gt;NewStringUTF(env, &quot;hello ndk&quot;); return str; } 4、编写（配置）两个mk文件：application.mk/android.mk1234567891011#application.mkAPP_ABI := armeabi#android.mkLOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := JNItest LOCAL_SRC_FILES := JNItest.c LOCAL_ARM_MODE := armLOCAL_LDLIBS += -llog include $(BUILD_SHARED_LIBRARY) 5、通过ndk-build生成so文件1ndk-build 6、java代码中加载so文件/libs文件下去头去尾（头：lib；尾：.so）123static{ System.loadLibrary(&quot;JNItest&quot;);} 7、build.gradle文件配置123456androi -ddefaultConfig --ndk { // 设置支持的SO库架构 abiFilters 'armeabi' ,'x86', 'armeabi-v7a', 'x86_64','arm64-v8a' } 8、main创建jniLibs文件夹将so文件复制123456main -jniLibs --armeabi ---libJNItest.so --armeabi-v7a ---libJNItest.so 三、动态注册1、.c文件编写JNI_OnLoadFindClass处填写对应类 1234567891011121314151617JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved){ JNIEnv* env; if((*vm)-&gt;GetEnv(vm, (void**)&amp;env, JNI_VERSION_1_4)!=JNI_OK){ return JNI_ERR; } jclass cls=(*env)-&gt;FindClass(env, &quot;com/example/myjnireistest/MainActivity&quot;); if((*env)-&gt;RegisterNatives(env, cls, jninativemethod,2)!=JNI_OK){ return JNI_ERR; } return JNI_VERSION_1_4;} 2、.c文件定义方法结构体123456789101112JNINativeMethod jninativemethod[]={ { &quot;getInt&quot;, &quot;()I&quot;, (void*)GetInt }, { &quot;getChar&quot;, &quot;()C&quot;, (void*)GetChar, }}; 3、.c文件对应C函数12345678jint GetInt (JNIEnv *env, jobject obj){ return 99;}jchar GetChar(JNIEnv* env, jobject obj){ return 'y';} 4、java代码逻辑12345static { System.loadLibrary(&quot;MyJniTest&quot;);}public native int getInt();public native char getChar(); 四、SO库获取java层字段值12345678//反射获取对应类jclass clazz=(*env)-&gt;FindClass(env, &quot;com/example/myjnilogin/MainActivity&quot;);//获取实例字段id (env, clazz, 字段名,字段类型)jfieldID fieldid = (*env)-&gt;GetFieldID(env, clazz, &quot;userId&quot;,&quot;Ljava/lang/String;&quot;);//根据实例id获取对应的值jstring jstr_user = (*env)-&gt;GetObjectField(env, obj, fieldid);//将string转化charconst char* user= (*env)-&gt;GetStringUTFChars(env, jstr_user, 0); 五、SO库调用JAVA函数1234//反射获取方法idjmethodID methodID = (*env)-&gt;GetMethodID(env,clazz, &quot;pwError&quot;, &quot;()V&quot;);//call调用方法(*env)-&gt;CallVoidMethod(env,obj, methodID);","link":"/20210831/NDK%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"},{"title":"Python根据关键词在360、百度、bing下载图片","text":"1. 简介输入一组关键词，指定所需图片个数，在常见搜索引擎中检索，记录图片url地址，并将图片保存在指定目录下。 百度图片：https://image.baidu.com/ 360搜图：https://image.so.com/ 微软：https://cn.bing.com/images/trending?FORM=ILPTRD） 2. 功能 支持的搜索引擎: 360, 必应, 百度 可配置线程数及代理 3. 安装3.1 安装相关python库1pip3 install -r requirements.txt 4. 如何使用4.1 命令行12345usage: image_downloader.py [-h] [--engine {baidu,bing,360}] [--max-number MAX_NUMBER] [--num-threads NUM_THREADS] [--timeout TIMEOUT] [--output OUTPUT] [--user-proxy USER_PROXY] keywords help 12345678910111213141516171819202122usage: image_downloader.py [-h] [--engine {baidu,bing,360}] [--max-number MAX_NUMBER] [--num-threads NUM_THREADS] [--timeout TIMEOUT] [--output OUTPUT] [--user-proxy USER_PROXY] keywordsImage Downloaderpositional arguments: keywords 搜索关键词optional arguments: -h, --help show this help message and exit --engine {baidu,bing,360}, -e {baidu,bing,360} 抓取网站. --max-number MAX_NUMBER, -n MAX_NUMBER 下载图片数量 --num-threads NUM_THREADS, -j NUM_THREADS 进程数 --timeout TIMEOUT, -t TIMEOUT 下载超时 --output OUTPUT, -o OUTPUT 输出文件夹 --user-proxy USER_PROXY, -p USER_PROXY 是否使用代理(默认不使用) 运行： 123456789101112131415161718python image_downloader.py &quot;中国地图&quot; -e &quot;360&quot; -n 10目标网站为:360关键词为: 中国地图抓取数量为:10条目标网站搜索结果为:1500目标抓取:10条 已抓取:10条##下载成功: 360_a674c5fccbd187575dbe3c46698d841a.jpeg##下载成功: 360_20760e3529df9287b80066168f35eae5.png##下载成功: 360_cb28e97178694f3f45788eec0894bf55.jpg##下载成功: 360_82dcd18912bbd65572d464e3e990eb8b.png##下载成功: 360_dbfb153accb1e125ea40fcd5585e3e5e.jpeg##下载成功: 360_7f95f7893557d445c668f448b159d9e0.jpg##下载成功: 360_968b76513aa6a56866bc5a68c873f5cd.png##下载成功: 360_aabb350a736c8418f8f581a660f9fb74.png##下载成功: 360_06ffc47d52f056cb2848315c2e6cb2ef.jpeg##下载成功: 360_a99a12dd76843c48264f215c50b099d0.jpegFinished. downloader.py:做图片下载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&quot;&quot;&quot; Download image according to given urls and automatically rename them in order. &quot;&quot;&quot;# -*- coding: utf-8 -*-# author: Yabin Zheng# Email: sczhengyabin@hotmail.comfrom __future__ import print_functionimport hashlibimport shutilimport imghdrimport osimport concurrent.futuresimport requestsheaders = { &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Proxy-Connection&quot;: &quot;keep-alive&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot; &quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, sdch&quot;,}def download_image(image_url, dst_dir, file_prefix, timeout=20, use_proxy=False): proxies = None # if proxy_type: # proxies = { # &quot;http&quot;: proxy_type + &quot;://&quot; + proxy, # &quot;https&quot;: proxy_type + &quot;://&quot; + proxy # } response = None try_times = 0 while True: try: try_times += 1 response = requests.get( image_url, headers=headers, timeout=timeout, proxies=proxies) image_name = get_img_name(response.content) file_name = file_prefix + &quot;_&quot; + image_name file_path = os.path.join(dst_dir, file_name) with open(file_path, 'wb') as f: f.write(response.content) response.close() file_type = imghdr.what(file_path) if file_type in [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;png&quot;, &quot;bmp&quot;]: new_file_name = &quot;{}.{}&quot;.format(file_name, file_type) else: new_file_name = &quot;{}.{}&quot;.format(file_name, 'jpg') new_file_path = os.path.join(dst_dir, new_file_name) shutil.move(file_path, new_file_path) print(&quot;##下载成功: {} &quot;.format(new_file_name)) break except Exception as e: if try_times &lt; 3: continue if response: response.close() print(&quot;##下载错误: {} {}&quot;.format(e.args,image_url)) breakdef download_images(image_urls, folder_dir='./download_images', file_prefix=&quot;img&quot;, max_workers=50, timeout=20, use_proxy=False): &quot;&quot;&quot; 图片下载 :param image_urls:图片列表 :param folder_dir:文件夹地址 :param file_prefix:文件来源 :param max_workers:最大并发 :param timeout:下载超时 :param use_proxy:是否使用代理 :return: &quot;&quot;&quot; with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor: future_list = list() count = 0 if not os.path.exists(folder_dir): os.makedirs(folder_dir) for image_url in image_urls: future_list.append(executor.submit( download_image, image_url, folder_dir, file_prefix, timeout, use_proxy)) count += 1 concurrent.futures.wait(future_list, timeout=180)def get_img_name(image_url): &quot;&quot;&quot; 图片name :param image_url: :return: &quot;&quot;&quot; md5 = hashlib.md5() md5.update(image_url) image_name = md5.hexdigest() return image_name image_downloader.py：做启动调度 123456789101112131415161718192021222324252627282930313233343536373839404142from __future__ import print_functionimport argparseimport crawlerimport downloaderimport sysdef main(argv): parser = argparse.ArgumentParser(description=&quot;Image Downloader&quot;) parser.add_argument(&quot;keywords&quot;, type=str, help='搜索关键词') parser.add_argument(&quot;--engine&quot;, &quot;-e&quot;, type=str, default=&quot;baidu&quot;, help=&quot;抓取网站.&quot;, choices=[&quot;baidu&quot;, &quot;bing&quot;, &quot;360&quot;]) parser.add_argument(&quot;--max-number&quot;, &quot;-n&quot;, type=int, default=100, help=&quot;下载图片数量&quot;) parser.add_argument(&quot;--num-threads&quot;, &quot;-j&quot;, type=int, default=50, help=&quot;进程数&quot;) parser.add_argument(&quot;--timeout&quot;, &quot;-t&quot;, type=int, default=20, help=&quot;下载超时&quot;) parser.add_argument(&quot;--output&quot;, &quot;-o&quot;, type=str, default=&quot;./download_images&quot;, help=&quot;输出文件夹&quot;) parser.add_argument(&quot;--user-proxy&quot;, &quot;-p&quot;, type=str, default=False, help=&quot;是否使用代理(默认不使用)&quot;) args = parser.parse_args(args=argv) # 默认不加代理 use_proxy = False crawled_urls = crawler.crawl_image_urls(args.keywords, engine=args.engine, max_number=args.max_number, use_proxy=use_proxy) downloader.download_images(image_urls=crawled_urls, folder_dir=args.output, max_workers=args.num_threads, timeout=args.timeout, use_proxy=use_proxy, file_prefix=args.engine) print(&quot;Finished.&quot;)if __name__ == '__main__': main(sys.argv[1:]) 项目地址:https://github.com/404SpiderMan/DownloadImage","link":"/20211203/Python%E6%A0%B9%E6%8D%AE%E5%85%B3%E9%94%AE%E8%AF%8D%E5%9C%A8360%E3%80%81%E7%99%BE%E5%BA%A6%E3%80%81bing%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/"},{"title":"Simhash-文本相似度算法","text":"一、什么是simhashsimhash初衷是用于解决亿万级别的网页去重任务，simhash通常用于长文本，通过降维处理，将长文本压缩至几个关键词来代表一篇文章，然后再将这些关键词编码成一个固定长度的二进制字符串（一般为32位或是64位），这样即用一个固定长度的编码来表示一整篇文章，我们想要对比多篇文章，只需要对比这些固定长度的编码就可以了。 二、 SimHash流程实现 分词 把需要判断文本分词形成这个文章的特征单词。最后形成去掉噪音词的单词序列并为每个词加上权重，我们假设权重分为5个级别（1~5）。 比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==&gt; 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。 hash 通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101,“51区”通过hash算法计算为 101011。这样我们的字符串就变成了一串串数字，还记得文章开头说过的吗，要把文章变为数字计算才能提高相似度计算性能，现在是降维过程进行时。 加权 通过 2步骤的hash生成结果，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。 合并 把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实计算需要把所有单词的序列串累加。 降维 把4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。","link":"/20211222/Simhash-%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%AE%97%E6%B3%95/"},{"title":"Python自动化构建雷电模拟器","text":"1、launch 支持2种启动雷电模拟器的方式–name顾名思义，应该是模拟器的标题栏的名字，本人经过验证果然如此!–index mnq_idx，模拟器的索引，第一个是0，第二个是1，以此类推 启动默认模拟器的2种方法：lsconsole.exe launch –name 雷神模拟器lsconsole.exe launch –index 0 2、quit 退出模拟器也提供了3种退出方式，和launch对应，不再累述。 3、quitall 退出模拟器退出所有开着的模拟器。 4、属性设置部分精彩部分来了，同样，修改属性时也要指定需要修改的是哪个模拟器的属性（多开的情况），仍然采用的是以上的3种方式，雷神提供的属性字段有： modify &lt;–name mnq_name | –index mnq_idx&gt;[–resolution ] // 自定义分辨率[–cpu &lt;1 | 2 | 3 | 4&gt;] // cpu设置[–memory &lt;512 | 1024 | 2048 | 4096 | 8192&gt;] // 内存设置[–manufacturer asus] // 手机厂商[–model ASUS_Z00DUO] // 手机型号[–pnumber 13812345678] // 手机号码[–imei ] // imei设置，auto就自动随机生成[–imsi ][–simserial ][–androidid ][–mac ] //12位m16进制mac地址[–autorotate &lt;1 | 0&gt;][–lockwindow &lt;1 | 0&gt;] 写个例子，修改默认模拟器的分辨率为600*360,dpi 160,cpu为1核，内存1024，imei随机，这样写：lsconsole.exe modify –index 0 –resolution 600,360,160 –cpu 1 –memory 1024 –imei auto 注：调用modify需要在模拟器启动前，不然可能不生效 5、新增模拟器add [–name mnq_name] 6、复制模拟器copy [–name mnq_name] –from 注意：from参数既可以是名字也可以是索引，判断规则为如果全数字就认为是索引，否则是名字 7、删除模拟器remove &lt;–name mnq_name | –index mnq_idx&gt; 8、备份，还原命令backup &lt;–name mnq_name | –index mnq_idx&gt; –filerestore &lt;–name mnq_name | –index mnq_idx&gt; –file 9、list2F:\\BaiZhi\\lsplayer&gt;lsconsole.exe list20,雷神模拟器,2032678,1704928,1,7456,35001,雷神模拟器-1,852422,590830,1,3772,3180 list2一次性返回了多个信息，依次是：索引，标题，顶层窗口句柄，绑定窗口句柄，是否进入android，进程PID，VBox进程PID官方文档 Python自动化构建模拟器1234567891011import os#切换至命令目录os.chdir('D:\\LDPlayer3.0')# 删除模拟器os.system('ldconsole.exe remove --name test2')#创建新的模拟器os.system('ldconsole.exe add --name test2')#设置模拟器属性os.system('ldconsole.exe modify --name test2 --resolution 1080,1920,480 --cpu 4 --imei auto --imsi auto --mac auto --manufacturer HUAWEI --model LIO-AN00')#打开模拟器os.system('ldconsole.exe launch --name test2') Python导入mitmproxy证书两种方式导入mitmproxy证书1、通过adb 2、是通过雷电ldconsole命令 1234567891011121314151617#adb --name &quot;雷神模拟器&quot;os.system('adb devices')# #推送至手机目录#ldconsole.exe push --name test2 --remote /sdcard --local F:/python3/RebortLeiDian/c8750f0d.0os.system('adb push F:/python3/RebortLeiDian/c8750f0d.0 /sdcard')# #给予写入权限#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell mount -o rw,remount /system&quot;os.system('adb shell &quot;mount -o rw,remount /system&quot;')# #推送至系统目录#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell mv /sdcard/c8750f0d.0 /system/etc/security/cacerts&quot;os.system('adb shell &quot;mv /sdcard/c8750f0d.0 /system/etc/security/cacerts&quot;')# #给予证书权限#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell chmod 644 /system/etc/security/cacerts/c8750f0d.0&quot;os.system('adb shell &quot;chmod 644 /system/etc/security/cacerts/c8750f0d.0&quot;')# #设置代理#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell settings put global http_proxy ip:端口&quot;os.system('adb shell &quot;settings put global http_proxy ip:端口&quot;') 完整代码，可以关注公众号回复: LD","link":"/20210723/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E9%9B%B7%E7%94%B5%E6%A8%A1%E6%8B%9F%E5%99%A8/"},{"title":"Tampermonkey油猴脚本安装及入门","text":"一、简介油猴脚本是是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox，通过它可以让浏览器实现各种各样的扩展功能，和浏览器扩展的作用类似。比如获去链接重定向、微博页面精简、去广告等，可以说为所欲也了。 二、油猴脚本安装官方网站选择对应预览器下载即可。 三、脚本创建及基本用法首先添加一个新脚本 一个初始化脚本已经完成。官方文档：https://www.tampermonkey.net/documentation.php?ext=dhdg#GM_openInTab 12345678910111213141516// ==UserScript==// @name New Userscript// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author You// @match https://www.tampermonkey.net/// @icon https://www.google.com/s2/favicons?domain=tampermonkey.net// @grant none// ==/UserScript==(function() { 'use strict'; // Your code here...})(); 用户脚本 Header@name脚本名称 @namesapce脚本命名空间 @include设置脚本在哪些网页中可以运行，允许设置多个标签。 @include 不支持URL hash参数。 123@include http://123.com/*@include https://123.com/*@include https://* @match与 @include 标签类似，允许设置多个。 1@match http*:// @exclude排除的URL， 在这些页面不运行脚本， 即使地址包含在 @include或@match标签内。允许设置多个。 @require表示在运行脚本前需要加载和运行的JavaScript文件。允许设置多个。注：如果加载的脚本使用use strict模式，用户脚本可能也会受严格模式影响 123@require https://code.jquery.com/jquery-2.1.4.min.js@require https://code.jquery.com/jquery-2.1.3.min.js#sha256=23456...@require https://code.jquery.com/jquery-2.1.2.min.js#md5=34567...,sha256=6789.. @resource定义一些需要预加载的资源文件，这些资源可以在脚本中通过GM_getResourceURL，GM_getResourceText访问。允许设置多个。 1234@resource icon2 /images/icon.png@resource html http://www.tampermonkey.net/index.html@resource xml http://www.tampermonkey.net/crx/tampermonkey.xml@resource SRIsecured1 http://www.tampermonkey.net/favicon.ico#md5=123434... @connect设置允许通过GM_xmlhttpRequest连接访问的域名（包括子域名）。 12@connect *@connect *://*.qidian.com/ @connect 标签允许设置的值： 域名，如tampermonkey.net, 设置后该域名下的所有子域名都是允许访问的 @run-at设置注入脚本的时间。@run-at defines the first possible moment a script wants to run. @run-at document-start The script will be injected as fast as possible.@run-at document-body The script will be injected if the body element exists.@run-at document-end The script will be injected when or after the DOMContentLoaded event was dispatched.@run-at document-idle The script will be injected after the DOMContentLoaded event was dispatched. This is the default value if no @run-at tag is given.@run-at content-menu The script will be injected if it is clicked at the browser context menu (desktop Chrome-based browsers only). @grant@grant标签用于设置GM_*方法， unsafeWindow对象， window对象方法的白名单。If no @grant tag is given TM guesses the scripts needs. 123456@grant GM_setValue@grant GM_getValue@grant GM_setClipboard@grant unsafeWindow@grant window.close@grant window.focus APIunsafeWindowunsafeWindow对象提供对页面javascript函数和变量的完全访问。 GM_addStyle(css)将给定样式添加到文档并返回注入的样式元素。 GM_addElement(tag_name, attributes), GM_addElement(parent_node, tag_name, attributes)创建由tag_name指定的HTML元素，应用所有给定的attributes，并返回注入的HTML元素。如果给定了“父节点”，则会将其附加到该节点或附加到文档头或文档体。 12345678910111213141516GM_addElement('script', { textContent: 'window.foo = &quot;bar&quot;;'});GM_addElement('script', { src: 'https://example.com/script.js', type: 'text/javascript'});GM_addElement(document.getElementsByTagName('div')[0], 'img', { src: 'https://example.com/image.png'});GM_addElement(shadowDOM, 'style', { textContent: 'div { color: black; };'}); GM_deleteValue(name)从storage中删除“名称”。 GM_listValues()列出storage的所有名称。 GM_addValueChangeListener(name, function(name, old_value, new_value, remote) {})对storage存储的变量添加监听器，返回监听器ID。 name参数是要监听的变量名 GM_removeValueChangeListener(listener_id)移除监听器。 GM_setValue(name, value)将“name”的值设置为storage。 GM_getValue(name, defaultValue)从storage里面获取’name’的值 GM_log(message)控制台输出日志 GM_getResourceText(name)获取在脚本头部用@resource标签预定义的的内容 GM_getResourceURL(name)获取在脚本头部用@resource标签预定义的的base64编码的URI GM_registerMenuCommand(name, fn, accessKey)在脚本运行页面的Tampermonkey菜单中注册新的菜单，返回菜单command ID GM_unregisterMenuCommand(menuCmdId)注销用GM_registerMenuCommand注册的菜单 GM_openInTab(url, options), GM_openInTab(url, loadInBackground)在新标签页打开URL。options可选的值： active decides whether the new tab should be focused, insert that inserts the new tab after the current one, setParent makes the browser re-focus the current tab on close and incognito makes the tab being opened inside a incognito mode/private mode window. GM_xmlhttpRequest(details)创建一个 xmlHttpRequest. GM_download(details), GM_download(url, name)下载URL指定资源到本地磁盘 四、编写Cookies转发脚本用于转发页面上的cookies信息到我们自己的服务器，供爬虫使用。 油猴脚本12345678910111213141516171819202122232425262728293031323334// ==UserScript==// @name BSpider// @namespace http://tampermonkey.net/// @version 0.1// @description cookies转发脚本// @author X// @match https://www.baidu.com/*// @icon https://www.google.com/s2/favicons?domain=tampermonkey.net// @grant GM_log// @grant GM_xmlhttpRequest// @grant GM_notification// @grant unsafeWindow// @run-at document-end// @connect *// ==/UserScript==(function() { //text, title, image, onclick) GM_log(&quot;脚本加载成功&quot;); var save_cookie = document.cookie; GM_log(save_cookie); GM_xmlhttpRequest({ url:&quot;http://ip:port/test&quot;, method :&quot;POST&quot;, data:save_cookie, headers: { &quot;Content-type&quot;: &quot;application/x-www-form-urlencoded&quot; }, onload:function(xhr){ GM_log(&quot;success&quot;); } });})(); 访问时会通知跨域，总是运行就行。查看预览器控制台，及flask端。 12345@app.route('/test',methods=['post'])def gat_cookies(): result = &quot;&quot;.join([i for i in request.form.items()][0]) print(result) return &quot;ok&quot; 五、结语油猴脚本是个很强大的浏览器辅助工具，而且相比于浏览器扩展，脚本更加轻便，占用资源极小，却可以实现丰富的功能。并且还有很多做好的插件，其中的细节有兴趣的同学可以自己研究下。","link":"/20220105/Tampermonkey%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/"},{"title":"Pycharm激活新思路所有版本无限试用！适用于所有jetbrains产品","text":"一、前言PyCharm激活码是大家一直都需要的，主要是PyCharm激活码一段时间就会过期，并且涉及到法律问题，产生侵权行为，而下面这种方法是用自动的方法代替手动卸载Pychram并重新试用，适用于所有jetbrains产品，一劳永逸，无限试用，并且我们没有对软件进行破解等不会产生侵权行为。 二、方法1、插件获取 12扫码关注公众号：虫术回复关键字：激活 (1) 可以 for free 免费进入的朋友直接将插件用鼠标拖入到代码编辑区就会安装，如果无法拖动安装，你可以在Settings–Plugins 里手动安装插件（Install Plugin From Disk），插件会提示安装成功。 ​ (2) 已经到期的朋友只有卸载重装了。(在重装之前不用特意去卸载，直接找到安装包点击再次安装，将弹窗出来的是否卸载之前的都打勾就可以卸载干净)。重装之后按照上面(1)操作即可 3、插件使用：（1）一般来说，在IDE窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（25天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示） （2）也可以手动唤出插件的主界面： 如果IDE没有打开项目，在 pycharm 界面点击菜单Get Help -&gt; Eval Reset； 如果IDE打开了项目，点击菜单：Help -&gt; Eval Reset （3)唤出的插件主界面中包含了一些显示信息，2个按钮，1个勾选项： 按钮：Reload 用来刷新界面上的显示信息。 按钮：Reset 点击会询问是否重置试用信息并重启IDE。选择Yes则执行重置操作并重启IDE生效，选择No则什么也不做。（手动重置方式） 选项：Auto reset before per restart 如果勾选了，则自勾选后每次重启/退出IDE时会自动重置试用信息，你无需做额外的事情。（自动重置试用方式）无需再管，一劳永逸。理论上这个插件支持所有的所有的版本，本人只在 pycharm 2020.2.3 安装使用（其他版本请自行测试） 重要： 手动重置的效果（插件安装3天之后）：还剩27天试用，点reset之后试用变成30天 reset之前： reset 重置试用之后： 结语：现在这种插件重置方式比补丁激活的方式更香了，官方无法封杀。只是通过重置了使用信息来保障我们可以一直用下去。","link":"/20211209/Pycharm%E6%BF%80%E6%B4%BB%E6%96%B0%E6%80%9D%E8%B7%AF%E6%89%80%E6%9C%89%E7%89%88%E6%9C%AC%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8%EF%BC%81%E9%80%82%E7%94%A8%E4%BA%8E%E6%89%80%E6%9C%89jetbrains%E4%BA%A7%E5%93%81/"},{"title":"Unidbg(一)环境安装及配置","text":"一、环境准备1、IntelliJ IDEA直接官网下载就可以 2、Maven环境官网：https://maven.apache.org/download.cgi 解压文件： 1tar -zxvf apache-maven-3.5.4-bin.tar.gz 配置环境变量： 12export MAVEN_HOME=/usr/local/apache-maven-3.8.4export PATH=$MAVEN_HOME/bin:$PATH 测试是否配置成功：mvn -version配置maven 二、导入代码1git clone https://github.com/zhkl0228/unidbg.git 等待加载完成后，运行下例子，运行成功就代表配置完成","link":"/20211207/Unidbg-%E4%B8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"title":"Windows WX注入原理","text":"一、注入原理 在 Windows 系统中，每个 .exe 文件在双击打开时都会加载 kernel32.dll 这个系统模块，该模块中有一个 LoadLibrary() 函数，可以将DLL文件加载到自身进程中。 用 CreateRemoteThread() 函数创建一个远程线程，让目标进程调用LoadLibrary() 来加载我们自己写的DLL 。CreateRemoteThread() 有这几个参数比较关键：A:想要注入的进程的句柄，这里可以通过OpenProcess()得到； B:想要运行的函数，本例中当然是 LoadLibrary() 啦； C: 所运行函数的参数，本例中是自己写的DLL的存放路径。 这就需要在内存中开辟一块空间，把路径写入进去。这要先用 VirtualAllocEx(）开辟一块空间，然后用WriteProcessMemory() 函数把DLL路径写进去。 总结：先在目标进程的内存空间里开辟一块新地方，往新地方里面写入DLL的路径，再创建远程线程找到LoadLibrary() 函数，并在刚才开辟的新地方中读取DLL路径，进而加载我们自己写的DLL。 二、构成1、注入器 遍历系统中的进程，找到微信进程（CreateToolhelp32Snapshot、Process32Next） 打开微信进程，获得HANDLE（OpenProcess） 在微信进程中为DLL文件路径字符串申请内存空间（VirtualAllocEx） 把DLL文件路径字符串写入到申请的内存中（WriteProcessMemory） 从Kernel32.dll中获取LoadLibraryA的函数地址（GetModuleHandle、GetProcAddress） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 伪代码// 1、遍历系统中的进程，找到微信进程（CreateToolhelp32Snapshot、Process32Next）//CreateToolhelp32Snapshot 获取指定进程的快照，以及这些进程使用的堆、模块和线程。HANDLE handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);//将设置格式的数据写入字符串 buff中swprintf_s(buff,L&quot;CreateToolhelp32Snapshot=%p&quot;, handle);//输出调试字符串OutputDebugString(buff);//定义结构体PROCESSENTRY32 processentry32 = { 0 };processentry32.dwSize = sizeof(PROCESSENTRY32);//检索有关记录在系统快照中的下一个进程的信息BOOL next = Process32Next(handle, &amp;processentry32);while (next == TRUE){ if (wcscmp(processentry32.szExeFile, L&quot;WeChat.exe&quot;) == 0) { weChatProcessID = processentry32.th32ProcessID; break; } next = Process32Next(handle, &amp;processentry32);}//2、打开微信进程，获得HANDLE（OpenProcess）// PROCESS_ALL_ACCESS 过程对象的所有可能访问权限// weChatProcessID 要打开的本地进程的标识符HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, weChatProcessID);//3、在微信进程中为DLL文件路径字符串申请内存空间（VirtualAllocEx）//VirtualAllocEx 在指定进程的虚拟地址空间内保留，提交或更改内存区域的状态。该函数将其分配的内存初始化为零//如果函数成功，则返回值是页面分配区域的基地址LPVOID allocAddress = VirtualAllocEx(hProcess, NULL, strSize, MEM_COMMIT, PAGE_READWRITE);if (allocAddress == NULL){ MessageBox(NULL, L&quot;申请内存空间失败&quot;, L&quot;提示&quot;, MB_OK); return 0;}swprintf_s(buff, L&quot;VirtualAllocEx=%p&quot;, allocAddress);//输出调试字符串OutputDebugString(buff);//4、把DLL文件路径字符串写入到申请的内存中（WriteProcessMemory）BOOL result = WriteProcessMemory(hProcess, allocAddress, DllFileName, strSize, NULL);if (result == FALSE){ MessageBox(NULL, L&quot;DLL文件路径字符串写入到申请的内存中失败&quot;, L&quot;提示&quot;, MB_OK); return 0;}//5、从Kernel32.dll中获取LoadLibraryA的函数地址（GetModuleHandle、GetProcAddress）HMODULE hMODULE = GetModuleHandle(L&quot;Kernel32.dll&quot;);FARPROC fARPROC = GetProcAddress(hMODULE, &quot;LoadLibraryA&quot;);//6、在微信中启动内存中指定了文件名路径的DLL（CreateRemoteThread）。//也就是调用DLL中的DllMain（以DLL_PROCESS_ATTACH为参数）。HANDLE hANDLE = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)fARPROC, allocAddress, 0, NULL); 2、Dll文件 获取WeChatWin.dll的基址 hook指定地址改变函数 保存当前寄存器状况方便恢复现场 跳转至自己的逻辑 恢复现场 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// 伪代码// DLL入口函数BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ switch (ul_reason_for_call) { // 当DLL注入时候执行逻辑 case DLL_PROCESS_ATTACH: { HANDLE hANDLE = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ShowDemoUI, hModule, NULL, 0); if (hANDLE != 0) { CloseHandle(hANDLE); } break; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;}VOID ShowDemoUI(HMODULE hModule){ // 获取WeChatWin.dll的基址 wxBaseAddress = (DWORD)GetModuleHandle(TEXT(&quot;WeChatWin.dll&quot;)); string text = &quot;微信基址：\\t&quot;; text.append(Dec2Hex(wxBaseAddress)); DialogBox(hModule, MAKEINTRESOURCE(IDD_MAIN), NULL, &amp;DialogProc);}//窗口回调函数，处理窗口事件INT_PTR CALLBACK DialogProc(_In_ HWND hwndDlg, _In_ UINT uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam){ hWinDlg = hwndDlg; switch (uMsg) { case WM_INITDIALOG: break; case WM_CLOSE: //关闭窗口事件 EndDialog(hwndDlg, 0); break; case WM_COMMAND: //接收消息 if (wParam == ID_START) { HookWx(); HWND hEditor = GetDlgItem(hwndDlg, IDC_MSG); SetWindowText(hEditor, TEXT(&quot;开始准备接收微信消息......\\r\\n&quot;)); break; } //停止接收 if (wParam == ID_STOP) { OutputDebugString(TEXT(&quot;停止接收按钮被点击&quot;)); UnHookWx(); HWND hFileHelper = GetDlgItem(hwndDlg, IDC_MSG); SetWindowText(hFileHelper, TEXT(&quot;停止准备接收微信消息......&quot;)); break; } //ID_UNLODA if (wParam == ID_UNLOAD) { //EndDialog(hwndDlg, 0); UnHookWx(); UnLoadMyself(); break; } default: break; } return FALSE;}// Hook接收消息VOID HookWx(){ if (isWxHooked == FALSE) { isWxHooked = TRUE; // hook地址 int hookAddress = wxBaseAddress + 0x4112FB; // 跳回的地址 jumBackAddress = wxBaseAddress + 0x411300; // 组装跳转数据 BYTE jmpCode[5] = { 0 }; jmpCode[0] = 0xE9; // 新跳转指令中的数据=跳转的地址-原地址（HOOK的地址）-跳转指令的长度 *(DWORD*)&amp;jmpCode[1] = (DWORD)RecieveMsgHook - hookAddress - 5; // 保存当前位置的指令,在unhook的时候使用。 ReadProcessMemory(GetCurrentProcess(), (LPVOID)hookAddress, originalCode, 5, 0); // 覆盖指令 B9 E8CF895C //mov ecx,0x5C89CFE8 WriteProcessMemory(GetCurrentProcess(), (LPVOID)hookAddress, jmpCode, 5, 0); }}DWORD C_EAX;DWORD C_EBX;DWORD C_ECX;DWORD C_EDX;DWORD C_ESI;DWORD C_EDI;DWORD C_EBP;DWORD C_ESP;// 跳转到这里，让我们自己处理消息__declspec(naked) VOID RecieveMsgHook(){ __asm { //保存寄存器 mov C_EAX, eax mov C_EBX, ebx mov C_ECX, ecx mov C_EDX, edx mov C_ESI, esi mov C_EDI, edi mov C_EBP, ebp mov C_ESP, esp mov r_esp, esp } //调用接收消息的函数 //RecieveMsg(); //起一个线程去做 CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)RecieveMsg, NULL,NULL, NULL); //恢复现场 __asm { mov eax, C_EAX mov ebx, C_EBX mov ecx, C_ECX mov edx, C_EDX mov esi, C_ESI mov edi, C_EDI mov ebp, C_EBP mov esp, C_ESP //跳回被HOOK指令的下一条指令 //07DD0000 - B9 C8FB0B5E - mov ecx, WeChatWin.dll + 1DDFBC8{ (5DD09EA0) } //07DD0005 - E9 F0129254 - jmp WeChatWin.dll + 4112FA call dword ptr[eax + 0x08] push edi push ecx jmp jumBackAddress }} 三、wx多开在Windows系统里面要实现单实例运行，基本都是用互斥体来实现的。互斥体，只能同时被一个线程持有， 只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。 微信的Mutex名字是：**_WeChat_App_Instance_Identity_Mutex_Name** 1、修改WeChatWin.dll修改字节，改变Mutex名字。 2、Hook内存","link":"/20211222/WX%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"},{"title":"smali动态调式","text":"一、Android Studio 调试的原理使用 Android Studio 进行动态调试，通过 Android Studio 导入反编译出的完整的 smali 代码，设置好调试所需的条件，设置断点。将移动设备连接至 PC端，然后运行待调试的apk应用程序，当该应用程序执行流程，运行至smali代码的断点处时，就会触发断点。从而可以进行进一步的分析和调试，让程序的运行流程和中间参数更清晰。 二、流程1、待调试的apk设置debuggable=”true”使用AndroidKiller工具，反编译我们要调试的APK文件，反编译成功后，在“工程管理器”找到AndroidManiFest.xml文件，再找到该文件里的application标签，查看标签中是否存在android:debuggable=“true”属性，如果文件中不存在android:debuggable=“true”，则需要进行添加。 2、导入Project3、调试环境配置​ 配置远程调试的选项，选择Run–&gt;Edit Configurations选项， 点击“+”号，新建remote类型调试器，设置Name，修改端口号，可以选择未被占用的任意端口，本次设置为8700。 4、动态调试smali代码（1）普通模式调试查看app的进程pid 1adb shell ps 进行端口转发，其中的“tcp”是之前配置调试环境时指定的端口号：8700，“jdwp”这里指的是我们要调试的程序的进程pid 1adb forward tcp:8709 jdwp:4917 （2）调试模式启动应用程序调试1adb shell am start –D -n 应用程序包名/应用程序入口界面 查看app的进程pid 1adb shell ps 进行端口转发，其中的“tcp”是之前配置调试环境时指定的端口号：8700，“jdwp”这里指的是我们要调试的程序的进程pid 1adb forward tcp:8709 jdwp:4917 快捷键：F9：跳到下一个断点F8：单步步过F7：单步步入Alt+shift+F7:强制进入Shift+F8:单步步出","link":"/20210915/smali%E5%8A%A8%E6%80%81%E8%B0%83%E5%BC%8F/"},{"title":"smali语法基础详解","text":"一、介绍apk文件通过apktool反编译出来的都有一个smali文件夹，里面都是以.smali结尾的文件。smali语言是Davlik的寄存器语言，语法上和汇编语言相似，Dalvik VM与JVM的最大的区别之一就是Dalvik VM是基于寄存器的。基于寄存器的意思是，在smali里的所有操作都必须经过寄存器来进行。 二、类型Java中的基本数据类型与Dalvik字节码类型的对应关系| Dalvik | Java || —— | ——- || B | byte || C | char || D | double || F | float || I | int || S | short || V | void || J | long || Z | boolean | *注意J、Z两个不是对应类型的首字母；在dalvik字节码中，寄存器都是32位的，能够支持任何类型，Long和Double类型是64位的，需要2个寄存器；V 只能用于返回值类型； 三、描述类的信息在打开smali文件的时候，它的头三行描述了当前类的一些信息 .class &lt; 访问权限&gt; [ 修饰关键字] &lt; 类名&gt; .super &lt; 父类名&gt;.source &lt;源文件名&gt;.class指令表示当前的类名，类的访问权限是public，类名为LHelloWorld，类开头的L表示后面跟随的字符串是一个类。.super指定了当前类所继承的父类，后面指的就是这个父类的类名，L表示后面跟的字符串是一个类.例： 123.class public Lcom/tt/android/xigua/detail/c/a$1;.super Ljava/lang/Object;.source &quot;SourceFile&quot; 四、静态字段#static fields .field &lt; 访问权限&gt; static [ 修饰关键字]&lt; 字段名&gt;:&lt; 字段类型&gt;baksmali在生成smali文件时，会在静态字段声明的起始处添加注释”static fields”，注释是以#开头。访问权限包括：private、protected、public修饰关键字为字段其他属性。例： 12# static fields.field public static a:Lcom/meituan/robust/ChangeQuickRedirect; 五、实例字段#instance fields .field &lt; 访问权限&gt; [ 修饰关键字] &lt; 字段名&gt;:&lt; 字段类型&gt;例： 12# instance fields.field final synthetic b:Lcom/tt/android/xigua/detail/c/a; 六、直接方法直接方法指的是该类中定义的方法。 #direct methods .method &lt;访问权限&gt; [ 修饰关键字] &lt; 方法原型&gt;、&lt;.registers&gt;、&lt;.locals&gt; [.param][.prologue][.line]&lt;代码体&gt; .end method例： 12345678910.method public f()Ljava/lang/String; .locals 4 .prologue .line 196608 const/4 v0, 0x0 …………………… .line 196609.end method #direct methods 是注释，是baksmali添加的，访问权限和修饰关键字 跟字段是一样的。方法原型 描述了方法的名称、参数与返回值。.registers 指令指定了方法中寄存器的总数,这个数量是参数和本地变量总和。.param 表明了方法的参数，每个.param指令表示一个参数，方法使用了几个参数就有几个.parameter指令。.prologue 指定了代码的开始处，混淆过的代码可能去掉了该指令。.line 指明了该处代码在源代码中的行号，同样，混淆后的代码可能去掉了行号。.local 使用这个指定表明方法中非参寄存器 七、虚方法虚方法指的是从父类中继承的方法或者实现的接口的方法，它的声明跟直接方法相同，只是起始的初始为“virtual methods”。 #virtual methods .method &lt;访问权限&gt; [ 修饰关键字] &lt; 方法原型&gt;&lt;.registers&gt;&lt;.locals&gt; [.param] [.prologue] [.line] &lt;代码体&gt;.end method 八、接口如果一个类实现了一个接口，那么会在smali文件中用.implements指令指出。 #interfaces .implements &lt; 接口名&gt;#interfaces是注释，.implements 是接口关键字，后面的接口名是 DexClassDef 结构中 interfacesOff 字段指定的内容 12# interfaces.implements Lcom/tt/floatwindow/video/a/d;","link":"/20211110/smali%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"title":"xpath 骚操作清单","text":"一、xpath不匹配含有指定子节点或属性的节点1. 不匹配含有指定子节点的节点如，不匹配子节点含有 ‘i’ 节点的 ‘p’ 节点 1xpath('//p[not(i)]') 2. 不匹配含有指定属性的节点如，不匹配子节点含有 ‘class’ 属性的 ‘p’ 节点 1xpath('//p[not(@class)]') 3. 二者联合使用，不匹配含有指定子节点和属性的节点如，不匹配子节点含有 ‘i’ 节点和子节点含有 ‘class’ 属性的 ‘p’ 节点 1xpath('//p[not(i) and not(@class)]')","link":"/20210916/xpath-%E9%AA%9A%E6%93%8D%E4%BD%9C%E6%B8%85%E5%8D%95/"},{"title":"反制Unidbg","text":"一、JNI交互尽可能增加补JAVA环境所需的时间成本，打个比方，在SO中编写1000个对JAVA层的访问和调用函数，每次计算时根据时间戳使用其中的50个，这样做的话，运算的时间成本不高，但因为时间戳一直在变，所以得在Unidbg中补齐全量的JAVA访问。使用Unidbg暂不支持的JNI调用src/main/java/com/github/unidbg/linux/android/dvm/DalvikVM.java 是Unidbg中实现JNI方法的类，可以发现，只实现了最常用的那部分JNI方法，所以可以在样本中使用这些Unidbg尚未实现的JNI方法。 二、系统调用Unidbg实现了许多常见的系统调用，但还有一些偏冷门的系统调用未实现，以及不偏僻但较难完美实现的系统调用，典型代表——fork相关系统调用。 三、文件访问尽可能多的文件访问和交互 四、检测Unidbg样本可以感知并检测自己运行在Unidbg环境中，并走向错误的分支。这一块我的了解不多，但确实是可以的，Unidbg的执行环境和真机是有很大差距的。打个比方，每个Android进程都有一些初始化环境变量，Android系统启动时通过setEnv设置，Unidbg中则没有。 五、目标函数无法被单独执行尽其所能的增加目标函数被执行的”前置条件“，或者说初始化函数。这里面可以玩的花招、阴招太多了。这应该作为一个主要的反Unidbg的方向，它是有效且杀伤力巨大的。","link":"/20211214/%E5%8F%8D%E5%88%B6Unidbg/"},{"title":"实战分析自毁程序Crackme IDA动态调试","text":"一、目标Crackme：https://github.com/404nofoundx/Cloud/blob/main/AliCrackme.zip 二、查看java代码二话不说上jadx，通过AndroidManifest.xml文件确定入口。 三、IDA静态分析 四、IDA动态分析打上断点 还没等到断点的时候，程序就崩溃了，猜测有反调试。 这次在JNI_OnLoad下断点，看看是哪里崩溃的，多次尝试发现在此处崩溃，用00000000修改此处命令。 修改前 修改后 反调试安全跳过，重新在Java_com_yaotong_crackme_MainActivity_securityCheck 设置断点。 查看R2寄存器 Flag = aiyou,bucuoo AliCrackme主要考验了过反调试和动态调试，还挺简单.jpg","link":"/20210917/%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E8%87%AA%E6%AF%81%E7%A8%8B%E5%BA%8FCrackme-IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"},{"title":"安卓逆向 | 某s社交类APP shield","text":"一、分析执行流程版本：djYuOTcuMA== 查看java代码，发现首先执行了initializeNative，intercept的第二个参数是，initialize获取到的，所有执行过程如下。 initializeNative()—-&gt;cPtr = initialize(str)—–&gt;intercept(Interceptor.Chain chain, long j2) 二、Unidbg1234567891011121314151617181920212223public class xhs extends AbstractJni { private final AndroidEmulator emulator; private final VM vm; private final Module module; xhs() { emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.xingin.***&quot;).build(); final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析 vm = emulator.createDalvikVM(new File(&quot;unidbg-android\\\\src\\\\test\\\\java\\\\com\\\\xiaohongshu6970\\\\bash.apk&quot;)); // 创建Android虚拟机 vm.setVerbose(true); // 设置是否打印Jni调用细节 DalvikModule dm = vm.loadLibrary(new File(&quot;unidbg-android\\\\src\\\\test\\\\java\\\\com\\\\xiaohongshu6970\\\\libshi**.so&quot;), true); module = dm.getModule(); // vm.setJni(this); dm.callJNI_OnLoad(emulator); } public static void main(String[] args) { xhs test = new xhs(); }} 框架搭好，尝试运行，缺啥补啥。 123456789@Overridepublic DvmObject&lt;?&gt; getStaticObjectField(BaseVM vm, DvmClass dvmClass, String signature) { switch (signature){ case &quot;com/xingin/shield/http/ContextHolder-&gt;sLogger:Lcom/xingin/shield/http/ShieldLogger;&quot;:{ return vm.resolveClass(&quot;com/xingin/shield/http/ShieldLogger&quot;).newObject(signature); } } return super.getStaticObjectField(vm, dvmClass, signature);} 初步运行没有问题。 构建initializeNative函数，运行，报错，缺啥补啥。 123456public void initializeNative(){ List&lt;Object&gt; list = new ArrayList&lt;&gt;(10); list.add(vm.getJNIEnv()); list.add(0); module.callFunction(emulator,0x6c11d,list.toArray());} 补环境的时候回遇到一个getSharedPreferences，SharedPreferences是一种轻型的数据存储方式，它的本质是基于XML文件存储key-value键值对数据，通常用来存储一些简单的配置信息。其存储位置在/data/data/&lt;包名&gt;/shared_prefs目录下。 123456789101112131415161718@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) { switch (signature){ case &quot;android/content/Context-&gt;getSharedPreferences(Ljava/lang/String;I)Landroid/content/SharedPreferences;&quot;:{ System.out.println(&quot;getSharedPreferences:&quot;+dvmObject.getValue()); System.out.println(&quot;getSharedPreferences arg1&quot;+vaList.getObjectArg(0)); System.out.println(&quot;getSharedPreferences arg2&quot;+vaList.getObjectArg(1)); return vm.resolveClass(&quot;android/content/SharedPreferences&quot;).newObject(vaList.getObjectArg(0)); } case &quot;android/content/SharedPreferences-&gt;getString(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;&quot;:{ System.out.println(&quot;SharedPreferences:&quot;+dvmObject.getValue()); System.out.println(&quot;SharedPreferences arg1&quot;+vaList.getObjectArg(0)); System.out.println(&quot;SharedPreferences arg2&quot;+vaList.getObjectArg(1)); return vm.resolveClass(&quot;java/lang/String&quot;).newObject(null); } } return super.callObjectMethodV(vm, dvmObject, signature, vaList);} 123456789101112getSharedPreferences:android/app/ActivityThread-&gt;currentApplication()Landroid/app/Application;getSharedPreferences arg1:&quot;s&quot;getSharedPreferences arg2:nullSharedPreferences:&quot;s&quot;SharedPreferences arg1:&quot;main&quot;SharedPreferences arg2:&quot;&quot;SharedPreferences:&quot;s&quot;SharedPreferences arg1:&quot;main_hmac&quot;SharedPreferences arg2:&quot;&quot; 通过输出可证明，在/data/data/com.xingin.xhs/shared_prefs这个目录下有个s.xml文件，然后取里面值，使用adb找到文件所在。 比较要注意的几个点：整个执行过程中，有很多要对Request进行操作的，所以要初始化好，方便操作，有一些不动的方法，就去文档查询在做什么操作。 123456request = new Request.Builder() .url(url) .addHeader(&quot;X-B3-TraceId&quot;, &quot;&quot;) .addHeader(&quot;xy-common-params&quot;, &quot;&quot;) .addHeader(&quot;User-Agent&quot;, &quot;&quot;) .build(); 最后的最后补完环境。 完整代码放在知识星球，关键词为xiao。 *本案例仅做分析参考，如有侵权请联系删除","link":"/20220113/%E5%B0%8F-%E4%B9%A6APP-shield%E5%88%86%E6%9E%90/"},{"title":"安卓逆向 | 某f新闻类APP sn","text":"一、抓包通过抓包，然后转换成python代码，通过删除字段的方式确定加密参数为 st：猜测为时间戳 sn：猜测根据时间戳加密 二、脱壳查壳工具查看有壳，用Frida-DEXDump脱壳，不会的可以点击传送门，开箱即用的脱壳工具。传送门 三、Java层分析脱壳脱出多个dex，挨个看一下，很幸运第一个dex就搜到了关键点。 r0tracer Hook一下,诶呦不错哟，还真找对了。其中st=int(time.time())*10000+random.randint(1000,9999)，sn调用的是a方法，传入st和false。 再看下a方法，hook一下ciy.b方法看下入参出参，看这个出参的长度好像md5啊。 验证下，确实是md5。 安卓逆向深似海，从此开发是路人，还是要多做多学，逆的多了，也就顺手了。欢迎关注知识星球，一起讨论爬虫安卓逆向知识。 *本案例仅做分析参考，如有侵权请联系删除","link":"/20220119/%E6%9F%90%E5%87%B0%E6%96%B0%E9%97%BB-sn/"},{"title":"安卓逆向 | 某b社交类APP gsid","text":"一、目标参数gsid 二、抓包 表单里面必要的几个参数checktoken、mfp、appkey，其中appkey是固定值。 1、checktokenjadx搜索checktoken，跟进去发现个b方法，用r0tracer hook一下这个方法，根据抓包对应下发现是uid+ “/“ + did+ “/“ + “obiew”拼接后传入ai.a中。 12345678910111213141516*** entered com.sina.weibo.utils.s.barg[0]: 2001734928402 =&gt; &quot;2001734928402&quot;arg[1]: 0f607264fc6318a92b9e13c65db7cd3c1138465a =&gt; &quot;0f607264fc6318a92b9e13c65db7cd3c1138465a&quot;java.lang.Throwable at com.sina.weibo.utils.s.b(Native Method) at com.sina.weibo.requestmodels.RequestParam.fillCommonParam(RequestParam.java:408) at com.sina.weibo.requestmodels.RequestParam.getNetRequestGetBundle(RequestParam.java:328) at com.sina.weibo.net.f.a(NetEngine.java:3465) at com.sina.weibo.push.h.g(PullSlave.java:227) at com.sina.weibo.push.h.f(PullSlave.java:203) at com.sina.weibo.push.h$1.run(PullSlave.java:144) at java.util.TimerThread.mainLoop(Timer.java:562) at java.util.TimerThread.run(Timer.java:512)retval: bf71ad18464a3a89989ca8dcf38979f4 =&gt; &quot;bf71ad18464a3a89989ca8dcf38979f4&quot;*** exiting com.sina.weibo.utils.s.b 跟进去ai.a方法里面，发现个关键字md5。 测试一下。标准的md5。 2、mfpjadx直接搜索mfp，找到关键点，分别hook下查看参数及返回值。 生成的主要位置如下图，底下标出了encryptRsa，可能是个RSA，再看下。 注意这里看这个a方法时候，jadx有可能出现下面的情况，可以换个版本试试或者用jeb查看java代码。 123arg[0]: {&quot;1&quot;:&quot;Android 10&quot;,&quot;5&quot;:&quot;02:00:00:00:00:00&quot;,&quot;10&quot;:&quot;f47e49ac58667fe3&quot;,&quot;13&quot;:&quot;armeabi-v7a&quot;,&quot;14&quot;:&quot;Pixel 2 XL&quot;,&quot;15&quot;:&quot;55782572032&quot;,&quot;16&quot;:&quot;1440*2880&quot;,&quot;17&quot;:&quot;&lt;unknown ssid&gt;&quot;,&quot;22&quot;:&quot;google&quot;,&quot;19&quot;:&quot;wifi&quot;,&quot;20&quot;:&quot;Google-Pixel 2 XL__weibo__12.0.0__android__android10&quot;,&quot;50&quot;:&quot;1&quot;,&quot;51&quot;:&quot;02:00:00:00:00:00&quot;} =&gt; &quot;{\\&quot;1\\&quot;:\\&quot;Android 10\\&quot;,\\&quot;5\\&quot;:\\&quot;02:00:00:00:00:00\\&quot;,\\&quot;10\\&quot;:\\&quot;f47e49ac58667fe3\\&quot;,\\&quot;13\\&quot;:\\&quot;armeabi-v7a\\&quot;,\\&quot;14\\&quot;:\\&quot;Pixel 2 XL\\&quot;,\\&quot;15\\&quot;:\\&quot;55782572032\\&quot;,\\&quot;16\\&quot;:\\&quot;1440*2880\\&quot;,\\&quot;17\\&quot;:\\&quot;&lt;unknown ssid&gt;\\&quot;,\\&quot;22\\&quot;:\\&quot;google\\&quot;,\\&quot;19\\&quot;:\\&quot;wifi\\&quot;,\\&quot;20\\&quot;:\\&quot;Google-Pixel 2 XL__weibo__12.0.0__android__android10\\&quot;,\\&quot;50\\&quot;:\\&quot;1\\&quot;,\\&quot;51\\&quot;:\\&quot;02:00:00:00:00:00\\&quot;}&quot;arg[1]: MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDHHM0Fi2Z6+QYKXqFUX2Cy6AaWq3cPi+GSn9oeAwQbPZR75JB7Netm0HtBVVbtPhzT7UO2p1JhFUKWqrqoYuAjkgMVPmA0sFrQohns5EE44Y86XQopD4ZO+dE5KjUZFE6vrPO3rWW3np2BqlgKpjnYZri6TJApmIpGcQg9/G/3zQIDAQAB =&gt; &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDHHM0Fi2Z6+QYKXqFUX2Cy6AaWq3cPi+GSn9oeAwQbPZR75JB7Netm0HtBVVbtPhzT7UO2p1JhFUKWqrqoYuAjkgMVPmA0sFrQohns5EE44Y86XQopD4ZO+dE5KjUZFE6vrPO3rWW3np2BqlgKpjnYZri6TJApmIpGcQg9/G/3zQIDAQAB&quot; Cipher类为加密和解密提供密码功能。它构成了Java Cryptographic Extension（JCE)框架的核心。 Cipher c = Cipher.getInstance(“RSA/ECB/PKCS1Padding”) 参数String transformation的格式是“算法/工作模式/填充模式”，不同的算法支持不同的工作模式以及填充模式。 c.init(1, g.b(arg12));public final void init(int opmode, Certificate certificate) // 用取自给定证书的公钥初始化此Cipher对象 v1_1.doFinal(v11_1, v9, v12_1);// 按单部分操作加密或解密数据，或者结束一个多部分操作 123456789101112131415161718192021222324252627*** entered com.sina.weibo.utils.g.barg[0]: com.sina.weibo.WeiboApplication@3356748 =&gt; &quot;&lt;instance: android.content.Context, $className: com.sina.weibo.WeiboApplication&gt;&quot;java.lang.Throwable at com.sina.weibo.utils.g.b(Native Method) at com.sina.weibo.requestmodels.hf.createPostRequestBundle(LoginVisitorParam.java:63) at com.sina.weibo.requestmodels.RequestParam.getNetRequestPostBundle(RequestParam.java:306) at com.sina.weibo.net.f.a(NetEngine.java:212) at com.sina.weibo.k.b.c(Controller.java:701) at com.sina.weibo.account.data.b.a(VisitorUtil.java:70) at com.sina.weibo.account.data.a.a(AccountData.java:54) at com.sina.weibo.utils.g.a(AidTask.java:676) at com.sina.weibo.requestmodels.ha.fillCommonParamSelf(LogInstallParam.java:267) at com.sina.weibo.requestmodels.RequestParam.fillCommonParam(RequestParam.java:394) at com.sina.weibo.requestmodels.RequestParam.getNetRequestGetBundle(RequestParam.java:328) at com.sina.weibo.net.f.i(NetEngine.java:3836) at com.sina.weibo.as.e.a(StatisticMethods.java:313) at com.sina.weibo.utils.go.a(UploadInstallLogTask.java:41) at com.sina.weibo.utils.go.doInBackground(UploadInstallLogTask.java:16) at com.sina.weibo.ay.d$2.call(ExtendedAsyncTask.java:93) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641) at java.lang.Thread.run(Thread.java:919)retval: 01cv/pmzSpMoR+Um7AdIkfSuUPmoxAHpT8000MGRbdMZ1pkZhG6fWF1yeSmkwsUviL1lvbnVix4GQObGPzLrV3c7Z0p014mum+gn7x4GFcAR5E1xey0xGRQD4aaeyjO7bq7wUtVJRDkMdOk65em2IjKQWXW/KBuWI0BrqfHBG1DLB1VGWTNq2rD8/4DuuVmq2ZGVkQysUuHNSnOB7NsVE6vkWH1npcW5+35nYiLx9C2O+Cr5U9sEx3yj7VBS+qErBs56ewvIyTOlRn8RmKiSHi9oBHPyzkiCkPDYaRP8Y2J+zsl2wzKuuSXtP9PqnIl98jcyHZUZQwk08Wcnevar16yoR2PUYRPMUSERgIyEU3pOxYoajRGkU2F0+cZhKg42pHEW49u6+LtUln2E5LhKcycyTaMS4/CatfVzOLeb2i0M8RBRqrzcmHrHCuChjtO/wZZpqPlc5DnXwn/NJTj6kDLeo3RYvJiWnGBuS8xn2Y3WiSFaVOUmC2ZuTyYX+VXJd3 =&gt; &quot;01cv/pmzSpMoR+Um7AdIkfSuUPmoxAHpT8000MGRbdMZ1pkZhG6fWF1yeSmkwsUviL1lvbnVix4GQObGPzLrV3c7Z0p014mum+gn7x4GFcAR5E1xey0xGRQD4aaeyjO7bq7wUtVJRDkMdOk65em2IjKQWXW/KBuWI0BrqfHBG1DLB1VGWTNq2rD8/4DuuVmq2ZGVkQysUuHNSnOB7NsVE6vkWH1npcW5+35nYiLx9C2O+Cr5U9sEx3yj7VBS+qErBs56ewvIyTOlRn8RmKiSHi9oBHPyzkiCkPDYaRP8Y2J+zsl2wzKuuSXtP9PqnIl98jcyHZUZQwk08Wcnevar16yoR2PUYRPMUSERgIyEU3pOxYoajRGkU2F0+cZhKg42pHEW49u6+LtUln2E5LhKcycyTaMS4/CatfVzOLeb2i0M8RBRqrzcmHrHCuChjtO/wZZpqPlc5DnXwn/NJTj6kDLeo3RYvJiWnGBuS8xn2Y3WiSFaVOUmC2ZuTyYX+VXJd3&quot;*** exiting com.sina.weibo.utils.g.b 123v11_1=[123,34,49,34,58,34,65,110,100,114,111,105,100,32,49,48,34,44,34,53,34,58,34,48,50,58,48,48,58,48,48,58,48,48,58,48,48,58,48,48,34,44,34,49,48,34,58,34,102,52,55,101,52,57,97,99,53,56,54,54,55,102,101,51,34,44,34,49,51,34,58,34,97,114,109,101,97,98,105,45,118,55,97,34,44,34,49,52,34,58,34,80,105,120,101,108,32,50,32,88,76,34,44,34,49,53,34,58,34,53,53,55,56,50,53,55,50,48,51,50,34,44,34,49,54,34,58,34,49,52,52,48,42,50,56,56,48,34,44,34,49,55,34,58,34,60,117,110,107,110,111,119,110,32,115,115,105,100,62,34,44,34,50,50,34,58,34,103,111,111,103,108,101,34,44,34,49,57,34,58,34,119,105,102,105,34,44,34,50,48,34,58,34,71,111,111,103,108,101,45,80,105,120,101,108,32,50,32,88,76,95,95,119,101,105,98,111,95,95,49,50,46,48,46,48,95,95,97,110,100,114,111,105,100,95,95,97,110,100,114,111,105,100,49,48,34,44,34,53,48,34,58,34,49,34,44,34,53,49,34,58,34,48,50,58,48,48,58,48,48,58,48,48,58,48,48,58,48,48,34,125]v9 = 0v12= 117 公钥找到了，用Python或者Java还原一下就可以了，测试了下，校验无误。 Python还原一下checktoken和mfp，初始化的时候无uid直接传空就行，第一次注册会返回uid，接下来看did。 3、didjadx搜索，然后结合Frida和抓包，找到did生成的地方，是一个native方法。 Frida主动调用下。 123456789101112131415function call_getDeviceIdNative() { Java.perform(function() { var cls = Java.use(&quot;com.sina.deviceidjnisdk.DeviceId&quot;); var obj = cls.$new(); var current_application = Java.use('android.app.ActivityThread').currentApplication(); var context = current_application.getApplicationContext(); var result = obj.getDeviceIdNative(context, &quot;&quot;, &quot;&quot;, &quot;03:00:00:00:00:00&quot;); console.log(&quot;result: &quot; + result); });}setImmediate(call_getDeviceIdNative) ida查看，静态注册 首先修改参数名称方便分析。 从下往上分析 3、1 MDStringHook一下MDString，验证一下是md5 12345678910111213141516171819202122232425262728293031323334function callSign_name() { Java.perform(function() { var str_name_so = &quot;libweibosdkcore.so&quot;; //要hook的so名 var str_name_func = &quot;MDString&quot;; //要hook的函数名 var n_addr_func = Module.findExportByName(str_name_so, str_name_func); console.log(&quot;func addr is:&quot; + n_addr_func); var arg2_adress; Interceptor.attach(n_addr_func, { //在hook函数之前执行的语句 onEnter: function(args) { console.log(&quot;==================begin========================&quot;) // console.log(&quot;enter:&quot; + Java.vm.getEnv().getStringUtfChars(args[1], null).readCString()) console.log(&quot;enter args0:&quot; + args[0]) console.log(&quot;enter args0 Memory:&quot; + Memory.readCString(args[0])) console.log(&quot;enter args1:&quot; + args[1]) arg2_adress = args[1] console.log(&quot;enter args1 Memory:&quot; + Memory.readCString(args[1])) console.log(&quot;---------------------------------------------------&quot;) }, //在hook函数之后执行的语句 onLeave: function(retval) { console.log(&quot;leave:&quot; + retval) console.log(&quot;leave args1 Memory:&quot; + Memory.readCString(arg2_adress)) console.log(&quot;==================end=========================&quot;) } }); });}// setImmediate(callSign)setTimeout(callSign_name,650) 12345678==================begin========================enter args0:0xb7e00c94enter args0 Memory:02:00:00:00:00:00enter args1:0xdac55348---------------------------------------------------leave:0xdac55348leave args1 Memory:0f607264fc6318a92b9e13c65db7cd3c==================end========================= 3、2 sub_28B0md5(str2+”20220118”+”haogtaok”) genCheckId只是把传值进行了拼接 最后发现did就是，传值的md5就可以了(qaq)，有能力的同学可以自己分析下，checktoken和mfp放在末尾，感兴趣的同学可以自己动手做下。 公众号传送门 *本案例仅做分析参考，如有侵权请联系删除","link":"/20220114/%E6%9F%90%E5%8D%9A-mfp/"},{"title":"安卓逆向 | 某y新闻类APP info","text":"1、user-lc生成处 跟到里面，发现个native方法encrypt IDA查看下，其中int传的是0，走的是下面。 2、info 跟进去发现最里面是个AES，然后外面套了一个encodeToString，java实现的话如下。 1234567891011121314151617181920212223242526272829303132package com;import org.apache.commons.codec.binary.Base64;import javax.crypto.Cipher;import javax.crypto.spec.SecretKeySpec;import java.io.UnsupportedEncodingException;public class spider { private static final String f22500b = &quot;AES&quot;; public byte[] a(byte[] bArr, byte[] bArr2){ SecretKeySpec secretKeySpec = new SecretKeySpec(bArr2, f22500b); try { Cipher instance = Cipher.getInstance(f22500b); instance.init(1, secretKeySpec); System.out.println(&quot;OK&quot;); return instance.doFinal(bArr); } catch (Exception e) { e.printStackTrace(); return null; } } public static void main(String[] args) throws UnsupportedEncodingException { Base64 base64 = new Base64(); String str1 = &quot;AAAAAAAAAAAAAAAAAAAAA&quot;; String str2 = &quot;BBBBBBBBBBBBBBBBBBBBB&quot;; spider s = new spider(); System.out.println(base64.encodeToString(s.a(str3.getBytes(&quot;UTF-8&quot;),str2.getBytes(&quot;UTF-8&quot;)))); }} 3、q hook一下 看了下代码发现是base64 4、signstr9是一个固定值加上时间戳，然后进行md5，之后传入so进行加密。 ida看下so中的逻辑，doEn里面看起来很像AES加密 这三处de猜测是字符串还原。 python还原一下 12345678910111213flag = &quot;D@V*@FG*UNFV2Udaalkb&quot;v3 = len(flag)result = [0]*(len(flag)+1)v5 = 0while v5!=v3: result[v5] =ord(flag[v5])^5 v5+=1 if v5==v3: breakresult[v5] = 0for i in result: print(chr(i),end=&quot;&quot;) D@V*@FG*UNFV2Udaalkb = AES/ECB/PKCS7PaddingGF = BC确定好是AES，于是去找秘钥，发现是在getRandomKey处生成的。采用frida hook一下，用python还原一下就可。 *本案例仅做分析参考，如有侵权请联系删除","link":"/20220214/%E6%9F%90%E6%98%93%E6%96%B0%E9%97%BB-info/"},{"title":"安卓逆向 | 某k新闻类APP sign","text":"一、抓包POST请求，url和header里面都携带一个sign，url中的sign猜测可能是根据From表单进行的加密，修改参数，显示签名错误，header里面可能是根据时间戳进行的加密。 二、Header中的sign1、Java层分析首先分析header中的sign，搜索 **”sign”**，Hook一下，对照抓包找一下，二三都很像挨个试一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344*** entered com.android36kr.a.d.e.interceptarg[0]: [object Object] =&gt; &quot;&lt;instance: okhttp3.Interceptor$Chain, $className: okhttp3.internal.http.RealInterceptorChain&gt;&quot;java.lang.Throwable at com.android36kr.a.d.e.intercept(Native Method) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:147) at okhttp3.internal.http.RealInterceptorChain.proceed(RealInterceptorChain.java:121) at okhttp3.RealCall.getResponseWithInterceptorChain(RealCall.java:257) at okhttp3.RealCall.execute(RealCall.java:93) at retrofit2.OkHttpCall.execute(OkHttpCall.java:174) at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$RequestArbiter.request(RxJavaCallAdapterFactory.java:171) at rx.internal.operators.OperatorSubscribeOn$1$1$1.request(OperatorSubscribeOn.java:80) at rx.Subscriber.setProducer(Subscriber.java:211) at rx.internal.operators.OperatorSubscribeOn$1$1.setProducer(OperatorSubscribeOn.java:76) at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(OnSubscribeMap.java:102) at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(OnSubscribeMap.java:102) at rx.internal.operators.OnSubscribeMap$MapSubscriber.setProducer(OnSubscribeMap.java:102) at rx.Subscriber.setProducer(Subscriber.java:205) at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:152) at retrofit2.adapter.rxjava.RxJavaCallAdapterFactory$CallOnSubscribe.call(RxJavaCallAdapterFactory.java:138) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:48) at rx.internal.operators.OnSubscribeLift.call(OnSubscribeLift.java:30) at rx.Observable.unsafeSubscribe(Observable.java:10200) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33) at rx.Observable.unsafeSubscribe(Observable.java:10200) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33) at rx.Observable.unsafeSubscribe(Observable.java:10200) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:48) at rx.internal.operators.OnSubscribeMap.call(OnSubscribeMap.java:33) at rx.Observable.unsafeSubscribe(Observable.java:10200) at rx.internal.operators.OperatorSubscribeOn$1.call(OperatorSubscribeOn.java:94) at rx.internal.schedulers.CachedThreadScheduler$EventLoopWorker$1.call(CachedThreadScheduler.java:228) at rx.internal.schedulers.ScheduledAction.run(ScheduledAction.java:55) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:462) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:301) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641) at java.lang.Thread.run(Thread.java:919)retval: Response{protocol=h2, code=200, message=, url=https://gateway.36kr.com/api/mis/nav/home/subnav/flow?sign=ebb4df16ad675e551171475c588e1548} =&gt; &quot;&lt;instance: okhttp3.Response&gt;&quot;*** exiting com.android36kr.a.d.e.intercept Hook下入参和出参。 12345*** entered com.android36kr.app.utils.EncryptUtils.signarg[0]: 1642493408 =&gt; &quot;1642493408&quot;retval: a4420dafd3d603546474cfe67e95c352 =&gt; &quot;a4420dafd3d603546474cfe67e95c352&quot;*** exiting com.android36kr.app.utils.EncryptUtils.sign 2、So层分析静态方法 然后hook一下j_decode返回的是**49g@EPf&amp;3AMt9X98@K8%**，出参结果是字符串加时间戳做的md5。 Frida脚本 1234567891011121314151617181920212223242526272829303132function callSign_adress() { Java.perform(function () { var str_name_so = &quot;liben.so&quot;; //要hook的so名 var n_addr_func_offset = 0x3588 ; //要hook的函数在函数里面的偏移 var n_addr_so = Module.findBaseAddress(str_name_so); var n_addr_func = parseInt(n_addr_so, 16) + n_addr_func_offset; var ptr_func = new NativePointer(n_addr_func); console.log(&quot;func addr is:&quot; + ptr_func); Interceptor.attach(ptr_func, { //在hook函数之前执行的语句e onEnter: function (args) { // console.log(&quot;enter:&quot; + Java.vm.getEnv().getStringUtfChars(args[1], null).readCString()) console.log(&quot;enter args0:&quot; + args[0]) // console.log(&quot;enter args0:&quot; + args[1]) console.log(&quot;enter:&quot; + Memory.readCString(args[0])) }, //在hook函数之后执行的语句 onLeave: function (retval) { console.log(&quot;leave:&quot; + retval) console.log(&quot;leave:&quot; + Memory.readCString(retval)) } }); });} 123456func addr is:0xba563588enter args0:0xba5722dcenter:1&lt;bE@Uc#6DHq&lt;]&lt;=EN= leave:0xdacc2280leave:49g@EPf&amp;3AMt9X98@K8% 三、Url中的sign1、Java层分析搜索 **?sign=**，结果只有三个，直接全部hook一下最后确定是com.android36kr.a.d.c.a.a.d，参数二是From表单中的数据。 1234567*** entered com.android36kr.a.d.c.a.a.darg[0]: Request{method=POST, url=https://gateway.36kr.com/api/mis/nav/home/subnav/flow?siteId=1&amp;platformId=1&amp;subnavId=6&amp;subnavType=1&amp;subnavNick=9&amp;pageSize=20&amp;pageEvent=0&amp;pageCallback=eyJmaXJzdElkIjo0NTA3NTE1NzMwLCJsYXN0SWQiOjM1Nzc1MTIyNTEsImZpcnN0Q3JlYXRlVGltZSI6MTY0MjQ5NzAwMDAwMCwibGFzdENyZWF0ZVRpbWUiOjE2NDI0OTcwMDAwMDB9&amp;homeCallback=xxxxxxxxxxx, tags={}} =&gt; &quot;&lt;instance: okhttp3.Request&gt;&quot;arg[1]: {&quot;adid&quot;:&quot;0816c4c266744c9a&quot;,&quot;app&quot;:&quot;36kr&quot;,&quot;device_brand&quot;:&quot;google&quot;,&quot;device_density&quot;:560,&quot;device_height&quot;:2712,&quot;device_id&quot;:&quot;0816c4c266744c9a&quot;,&quot;device_model&quot;:&quot;Pixel 2 XL&quot;,&quot;device_oaid&quot;:&quot;&quot;,&quot;device_orientation&quot;:0,&quot;device_width&quot;:1440,&quot;ip&quot;:&quot;61.135.152.188&quot;,&quot;isp&quot;:&quot;&quot;,&quot;network&quot;:&quot;wifi&quot;,&quot;os_version&quot;:&quot;10&quot;,&quot;param&quot;:{&quot;homeCallback&quot;:&quot;xxxxxxxxxxx&quot;,&quot;pageCallback&quot;:&quot;eyJmaXJzdElkIjo0NTA3NTE1NzMwLCJsYXN0SWQiOjM1Nzc1MTIyNTEsImZpcnN0Q3JlYXRlVGltZSI6MTY0MjQ5NzAwMDAwMCwibGFzdENyZWF0ZVRpbWUiOjE2NDI0OTcwMDAwMDB9&quot;,&quot;pageEvent&quot;:&quot;0&quot;,&quot;pageSize&quot;:&quot;20&quot;,&quot;platformId&quot;:&quot;1&quot;,&quot;siteId&quot;:&quot;1&quot;,&quot;subnavId&quot;:&quot;6&quot;,&quot;subnavNick&quot;:&quot;9&quot;,&quot;subnavType&quot;:&quot;1&quot;},&quot;partner_id&quot;:&quot;android&quot;,&quot;partner_version&quot;:&quot;9.4.2&quot;,&quot;request_id&quot;:&quot;&quot;,&quot;timestamp&quot;:1642497397704,&quot;timestamp_period&quot;:&quot;300&quot;,&quot;user_agent_ad&quot;:&quot;Mozilla/5.0 (Linux; Android 10; Pixel 2 XL Build/QQ3A.200805.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/74.0.3729.186 Mobile Safari/537.36&quot;} retval: Request{method=POST, url=https://gateway.36kr.com/api/mis/nav/home/subnav/flow?sign=6a86126f4b8fa0538493d06d5ce4f128, tags={}} =&gt; &quot;&lt;instance: okhttp3.Request&gt;&quot;*** exiting com.android36kr.a.d.c.a.a.d 2、So层分析j_j_EncryptMD5str猜测是MD5，传进去吃字符串是From表单+”OooCsekkuOZOHZChPO5-WQ”，验证一下，和猜想一样。 四、设备参数 安卓逆向深似海，从此开发是路人，还是要多做多学，逆的多了，也就顺手了。欢迎关注我的公众号，一起讨论爬虫安卓逆向知识。 *本文章仅供学习交流,切勿用于非法通途,如有侵犯贵司请及时联系删除","link":"/20220119/%E6%9F%90%E6%B0%AA-sign/"},{"title":"某豆*__DATA__数据加密","text":"一、确定逻辑获取的数据复制给 window.__DATA__ 全局搜索，确定位置 跟进去发现，在这个位置生成数据 验证一下 二、调试巴拉巴拉 三、搭建解密服务123456789101112131415161718192021222324252627282930313233343536373839var r = &quot;WKVZcEaRd7/………………&quot;;var i = 16var Q = 4096var p = { start: 2, end: 7}var K = {}…………………………………………………………………………………………………………………………………………………此处省略N字……………………………………………………………………………………………………………………………………………………………………………………function decrypt(r) { var a = encry2arr_from(r, &quot;base64&quot;) // 0 , s = Math.max(Math.floor((a.length - 2 * i) / 3), 0) // 40 , u = a_slice(a, s, s + i); // 41 a = concat([a_slice(a, 0, s), a_slice(a, s + i)]); // 43 45 47 var c_data = hash(concat([u, encry2arr_from(&quot;&quot;)])); // 49 67 69 var l = {} l[c_data] = a var data = n_n((l = {}, l[c_data] = a, l)) // console.log(data) // console.log(data.payload.items[0]) var d_temp = data.payload.items var ret_val = JSON.stringify(d_temp) return ret_val}function get_page(arg){ console.log(arg) return decrypt(arg)}module.exports = { get_page} spider_server.js 12345678910111213141516var express = require('express');var douban = require('./douban');var app = express();const multipart = require('connect-multiparty')const multipartyMiddleware = multipart()app.post('/douban', multipartyMiddleware, (req, res) =&gt; { console.log(req) var result = douban.get_page(req.body.p1) res.send(result)})app.listen(23341, function () {}) 123全部代码放在百度云盘了链接：https://pan.baidu.com/s/1Gshwaeg8sKnb6Nx1PEI1Vw 提取码：6666","link":"/20211203/%E6%9F%90%E8%B1%86-DATA-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"title":"安卓逆向 | 某l新闻类APP urlSign","text":"一、目标参数版本：VjcuNzMuNQ== urlSign 二、JAVA层分析搜索出两个关键点，挨个看下。 第二个看起来比第一个像很多，有rand，signVer，urlSign参数，和抓包的参数可以对应上。 跟进去com.sina.sinahttpsignlibrary.a.a(paramsExt, Integer.valueOf(random))，继续看a方法。 a方法主要作用就是对传入的objArr进行处理拼接，然后传入getSecretKey2中，进入getSecretKey2中看下，发现调用了native方法secretKey2。 Hook下secretKey2，看下传参和返回值，结果如下，传值就是url+”_”+rand，返回就是urlSign。 1234*** entered com.sina.sinahttpsignlibrary.HttpSignHelper.secretKey2arg[0]: arg[0]: /feed?lDid=00d31a3d49…………_85retval: 4b936b0a64 =&gt; &quot;4b936b0a64&quot;*** exiting com.sina.sinahttpsignlibrary.HttpSignHelper.secretKey2 再主动调用一下，脚本如下，结果不变还是4b936b0a64。 12345678910function callSign(){ Java.perform(function () { var str1 = &quot;/feed?lDid=00d31a3d4909b1a3&amp;oldChwm=12070_0007&amp;appVersion=7.73.5&amp;upTimes=0&amp;city=&amp;loginType=0&amp;dChannel=news_toutiao&amp;channel=news_toutiao&amp;open_adtype=0&amp;ua=Google-Pixel+2+XL__sinanews__7.73.5__android__10__935&amp;deviceId=00d31a3d4909b1a3&amp;resolution=1440x2712&amp;connectionType=2&amp;weiboUid=&amp;replacedFlag=0&amp;ssoVer=3&amp;osVersion=10&amp;ipv4=61.135.152.137&amp;downTotalTimes=1&amp;chwm=12070_0007&amp;pullTimes=2&amp;app_visibility=foreground&amp;from=6000095012&amp;behavior=manual&amp;udid=00d31a3d4909b1a3&amp;aId=01A86zpEmsX6AIsHfoiIojg0YSpvHKoxIlKfIe2j8lCamfa3s.&amp;localSign=a_f413815d-6ad9-4377-af0b-aeae5a259530&amp;a=&amp;osSdk=29&amp;i=&amp;close_ad=&amp;listCount=14&amp;accessToken=&amp;downTimes=1&amp;m=&amp;o=&amp;open_adid=&amp;seid_v2=eab5292817&amp;s=&amp;dataid=&amp;pullDirection=down&amp;upTotalTimes=0&amp;seId=9455d9ba72&amp;channelName=%E6%8E%A8%E8%8D%90&amp;deviceModel=Google__google__Pixel+2+XL&amp;location=0.0%2C0.0&quot; var rand = &quot;85&quot; var HttpSignHelper = Java.use(&quot;com.sina.sinahttpsignlibrary.HttpSignHelper&quot;) var result = HttpSignHelper.secretKey2(str1+&quot;_&quot;+rand) console.log(result); });}setImmediate(callSign) 1[Pixel 2 XL::com.sina.news]-&gt; 4b936b0a64 三、SO层分析IDA查看，发现是静态注册。 首先做了判断j_check_package_sign，跟进去这个方法，分析主要是判断包名以及apk签名，可以选择修改so，或者通过unidbg patch掉。 再看j_sign_now 在sign_now中有个j_secure_for_sina，跟进去有个md5, 用Frida hook下md5看下传值，结果写在了传入的第二值中。 12345678910111213141516171819202122232425function callSign() { Java.perform(function() { var str_name_so = &quot;libsina_news_util.so&quot;; //要hook的so名 var str_name_func = &quot;secure_for_sina&quot;; //要hook的函数名 var str_name_func = &quot;md5&quot; var n_addr_func = Module.findExportByName(str_name_so, str_name_func); console.log(&quot;func addr is:&quot; + n_addr_func); var arg2_adress; Interceptor.attach(n_addr_func, { //在hook函数之前执行的语句 onEnter: function(args) { // console.log(&quot;enter:&quot; + Java.vm.getEnv().getStringUtfChars(args[1], null).readCString()) console.log(&quot;enter args0:&quot; + args[0]) arg2_adress = args[1] console.log(&quot;enter:&quot; + Memory.readCString(args[0])) }, //在hook函数之后执行的语句 onLeave: function(retval) { console.log(&quot;leave:&quot; + retval) console.log(&quot;leave a2:&quot; + Memory.readCString(arg2_adress)) } }); });}setImmediate(callSign) 发现在url+random后面又拼上了一个E2AC6F3643，这个是在sign_now拼接上的固定值，a1=1。 123456enter args0:0xe8a43f80enter args1:0xb9423610enter:/feed?lDid=00d31a3d4909b1a3&amp;oldChwm=12070_0007&amp;appVersion=7.73.5&amp;upTimes=0&amp;city=&amp;loginType=0&amp;dChannel=news_toutiao&amp;channel=news_toutiao&amp;open_adtype=0&amp;ua=Google-Pixel+2+XL__sinanews__7.73.5__android__10__935&amp;deviceId=00d31a3d4909b1a3&amp;resolution=1440x2712&amp;connectionType=2&amp;weiboUid=&amp;replacedFlag=0&amp;ssoVer=3&amp;osVersion=10&amp;ipv4=61.135.152.137&amp;downTotalTimes=4&amp;chwm=12070_0007&amp;pullTimes=5&amp;app_visibility=foreground&amp;from=6000095012&amp;behavior=manual&amp;udid=00d31a3d4909b1a3&amp;aId=01A86zpEmsX6AIsHfoiIojg0YSpvHKoxIlKfIe2j8lCamfa3s.&amp;localSign=a_4c07a485-b198-48ef-8b39-491aef875454&amp;a=&amp;osSdk=29&amp;i=&amp;close_ad=&amp;listCount=14&amp;accessToken=&amp;downTimes=4&amp;m=&amp;o=&amp;open_adid=&amp;seid_v2=8be054f72e&amp;s=&amp;dataid=&amp;pullDirection=down&amp;upTotalTimes=0&amp;seId=87f0026438&amp;channelName=%E6%8E%A8%E8%8D%90&amp;deviceModel=Google__google__Pixel+2+XL&amp;location=0.0%2C0.0_276_E2AC6F3643enter:leave:0x0leave a2:21cadcb5f3ebe70311e519bfdf323a3e 标准的md5没有进行魔改。 md5后的结果为：21cadcb5f3ebe70311e519bfdf323a3e 23a3e21cad = 23a3e+21cad *本案例仅做分析参考，如有侵权请联系删除","link":"/20220113/%E6%9F%90%E6%B5%AA%E6%96%B0%E9%97%BB-urlSign/"},{"title":"某音5神学习分析","text":"转自：https://bbs.pediy.com/thread-269025.htm 首先吐槽一下某音的更新速度,简直是不要命一样 最短是两天一个小版本,并且吧所有算法秘钥都更新了一遍。 本文全篇以15版本为例,因为老版本的双神走的是XLOG接口,因为年代久远所以就不探讨了(其实也不远,就是抖音更新太快了,一个月多月一个大版本谁能跟的起) 搞逆向的朋友都知道,某音的算法自从最老版本的双神,成功的进阶为5神,但是最近看了17版本好像吧 X-tyhon给整掉了,并且之前的Mssdk 包好像也找不到了. 所谓的5神 由最早引入的 x-gorgon x-khronos 到后来版本的 x-argus x-ladon x-tyhon 命名规则是古希腊神话中的妖魔鬼怪 当然在分析5神 “libmetasec_ml.so”的时候发现了一个官方diss 位没看错,官方DISS 最为致命,导致玻璃心的我当场崩溃 决定把它干翻看看他这馋人的内部到底是什么样子 在大部分时间都是在处理ollvm跟vmp 这种东西枯燥无味就不展开讲了 直接上干货 5神 其中四神都是依赖于x-khronos 的时间戳加密算出来的结果.并且x-argus x-ladon x-tyhon 属于对称加密,导致某音可以直接反解拿到明文,让人十分头大 X-Gorgon抖音自定义算法加密 由(URL+header[x-common-params-v2]的MD5)+(X-SS-STUB)+(x-khronos)+(版本号15.1为0124)组成的20字节的byte加密而成 例如： 10404 c0f10000 d11b879564199a8b8f28972c175c50b88551add7 0404是固定代表算法版本 后八位是4个byte的随机key 而最后的40位就是加密后的byte类型. 所以如果你有算法并且你抓包拿到了随机key 那么你就能算的跟真机算出的结果一样。 X-Khronos毋庸置疑 时间戳 并且神中的时间戳都是由他而来 X-Ladon这个神其实就是由(x-khronos+(-1588093228-1128)) 加密而来 秘钥就是解出base64的前4位+”1128”的MD5 ,如果不信可以用frida hook一下 这样你就会神奇的发现,每次解出base64的前4位都神奇的变成了78563412 X-Tyhon这个东西你用刚才的frida脚本hook一下的话,你也会神奇的发现 他的秘钥是base64解密后的前两位跟后两位 而他的作用呢就是加密MSSDK返回来的一个token,好像17版本直接没了这个神. 也是你这东西能校验得浪费多大的算力.你得保存多少token X-Argus其实我知道,大家其实最关心的是这个神,古希腊神话中的百眼巨人,貌似能看穿一切,而且看他的长度,大家也知道他是最牛的神了. 直接说结果,这个东西解密完就是个protobuf 但是这个神用到了多重加密,跟mssdk的5重加密bqq的三重加密有的一拼 主要用SM3算法计算了你url跟X-SS-STUB 然后把你的deviceID ktoken跟时间戳也放到了protobuf里,所以大家不能用真机hook的方式哦,会被抓到滴 当然如果你登录了他还会在protobuf里增加了一个 xbdlanusk这个值是登录smslogin返回的哦,代表你的个人信息! 所以千万不能用hook的方式哦","link":"/20220125/%E6%9F%90%E9%9F%B35%E7%A5%9E%E5%AD%A6%E4%B9%A0%E5%88%86%E6%9E%90/"},{"title":"正则及XPath基础文档","text":"一、正则表达式匹配规则 模 式 描 述 \\w 匹配字母、数字及下划线 \\W 匹配不是字母、数字及下划线的字符 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f] \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9] \\D 匹配任意非数字的字符 \\A 匹配字符串开头 \\Z 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串 \\z 匹配字符串结尾，如果存在换行，同时还会匹配换行符 \\G 匹配最后匹配完成的位置 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配一行字符串的开头 $ 匹配一行字符串的结尾 . 匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符 […] 用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k [^…] 不在 [] 中的字符，比如 [^abc] 匹配除了 a、b、c 之外的字符 * 匹配 0 个或多个表达式 + 匹配 1 个或多个表达式 ? 匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配 n 个前面的表达式 {n, m} 匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式 ( ) 匹配括号内的表达式，也表示一个组 修饰符 修饰符 描 述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 匹配包括换行在内的所有字符 re.U 根据 Unicode 字符集解析字符。这个标志影响 \\w、\\W、\\b 和 \\B re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 二、XPath常用规则 表 达 式 描 述 nodename 选取此节点的所有子节点 / 从当前节点选取直接子节点 // 从当前节点选取子孙节点 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 节点轴| 表 达 式 | 描 述 || —————– | —————————— || ancestor | 祖先节点 || attribute | 获取所有属性值 || child | 获取所有直接子节点 || descendant | 获取所有子孙节点 || following | 当前节点之后的所有节点 || following-sibling | 获取当前节点之后的所有同级节点 |","link":"/20211110/%E6%AD%A3%E5%88%99%E5%8F%8AXPath%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3/"},{"title":"短视频最新版quic协议解决方案","text":"quic协议是什么QUIC（Quick UDP Internet Connection）是谷歌制定的一种互联网传输层协议，它基于UDP传输层协议，同时兼具TCP、TLS、HTTP/2等协议的可靠性与安全性，可以有效减少连接与传输延迟，更好地应对当前传输层与应用层的挑战。 dddd 对于该app禁止quic相关的so加载即可，记得没错的话该so是lib**cronet.so,通过ida也可以看到相关函数名。 xposed代码如下: 123456789101112131415161718public class Hook implements IXposedHookLoadPackage { @Override public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam) throws Throwable { if (loadPackageParam.packageName.equals(&quot;com.******&quot;)) { XposedBridge.log(&quot; douyin Hooked open!&quot;); Class clazz = loadPackageParam.classLoader.loadClass(&quot;org.chromium.CronetClient&quot;); XposedHelpers.findAndHookMethod(&quot;org.chromium.CronetClient&quot;, loadPackageParam.classLoader, &quot;tryCreateCronetEngine&quot;, Context.class, boolean.class, boolean.class, boolean.class, boolean.class, String.class, Executor.class, boolean.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { XposedBridge.log(&quot;CronetClient disable tryCreateCronetEngine&quot;); param.setResult(null); } }); } }} kkkk 该app使用quic协议比较早，之前由于不同版本混淆，导致hook代码要更新，后来通过看了一部分Cronet网络库的资料，找到该通用型的解决方案，该app的加载的so是libconnection**.so，记得没错的话。 该部分的xposed代码如下: 1234567 XposedHelpers.findAndHookMethod(&quot;com.**.aegon.Aegon&quot;, lpparam.classLoader, &quot;nativeUpdateConfig&quot;, String.class, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable {param.args[0] = &quot;{\\&quot;enable_quic\\&quot;: false, \\&quot;preconnect_num_streams\\&quot;: 2, \\&quot;quic_idle_timeout_sec\\&quot;: 180, \\&quot;quic_use_bbr\\&quot;: true, \\&quot;altsvc_broken_time_max\\&quot;: 600, \\&quot;altsvc_broken_time_base\\&quot;: 60, \\&quot;proxy_host_blacklist\\&quot;: []}&quot;; } }); 转自：https://bbs.pediy.com/thread-268651.htm *本案例仅做分析参考，如有侵权请联系删除","link":"/20220221/%E7%9F%AD%E8%A7%86%E9%A2%91%E6%9C%80%E6%96%B0%E7%89%88quic%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"title":"霸哥磁力搜索apk过签名校验","text":"一、什么是签名校验签名验证，就是在APP中写入自己私钥的hash值，和一个获取当前签名中的私钥hash值的函数两个值相一致，那么就说明APP没有被改动允许APP运行。 如果两值不一致那么说明APP是被二次打包的，APP就自我销毁进程。 签名验证可以在两个地方做，一个是在MainActivity.java的OnCreate函数中做，一个是在原生代码文件的JNI_OnLoad函数中做。 二、验证是否是签名校验用Android killer随意改下smail代码然后重新打包，发现APP闪退。 三、Jadx查看JAVA代码/IDA查看so签名校验一般都是在MainActivity.java的OnCreate函数中做，或者是在原生代码文件的JNI_OnLoad函数中做，首先查看OnCreate，里面有个qian，跟进去看看。 qian里面就是查看APP哈希值是否改变，这是第一个地方。 这里调用了一个bug，而bug写在了so里面，有很大嫌疑，ida看见这个so。 IDA查看bug这个函数采用的是静态注册，里面调用了一个getSignHashCode，跟进去看看。 四、过签名校验首先处理So文件，把exit换成nop，然后到处替换原来的so。 然后修改smail代码，把调用qian的地方给注释掉然后重新打包。 重打包后签名校验已经过掉了。","link":"/20211115/%E9%9C%B8%E5%93%A5%E7%A3%81%E5%8A%9B%E6%90%9C%E7%B4%A2apk%E8%BF%87%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/"},{"title":"Unidbg从入门到再入门之学习笔记","text":"部分内容来自：龙哥星球中Coffee的Unidbg学习笔记 一、初始化项目123456789101112131415161718// 创建模拟器实例,进程名建议依照实际进程名填写，可以规避针对进程名的校验emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;packename&quot;).build();// 获取模拟器的内存操作接口Memory memory = emulator.getMemory();// 设置系统类库解析memory.setLibraryResolver(new AndroidResolver(23));// 创建Android虚拟机,传入APK，Unidbg可以替我们做部分签名校验的工作vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/java/com/l1/lvzhou.apk&quot;));// 加载so文件DalvikModule dm = vm.loadLibrary(new File(&quot;unidbg-android/src/test/java/com/l1/liboasiscore.so&quot;),true);// 获取So文件句柄module = dm.getModule();// 设置JNIvm.setJni(this);// 打印日志vm.setVerbose(true);// 调用JNI Onlodadm.callJNI_OnLoad(emulator); 二、创建context类12345678910111213141516171819202122DvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/content/Context&quot;).newObject(null);// context//或者DvmClass context = vm.resolveClass(&quot;android/content/Context&quot;); DvmClass ContextWrapper = vm.resolveClass(&quot;android/content/ContextWrapper&quot;, context); DvmClass Application = vm.resolveClass(&quot;android/app/Application&quot;,ContextWrapper); return Application.newObject(signature);//补环境的时候要注意@Override public DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) { switch (signature){ case &quot;android/app/ActivityThread- &gt;getApplication()Landroid/app/Application;&quot;:{ DvmClass context = vm.resolveClass(&quot;android/content/Context&quot;); DvmClass Application = vm.resolveClass(&quot;android/app/Application&quot;,context); return Application.newObject(signature); } case &quot;android/content/Context- &gt;getContentResolver()Landroid/content/ContentResolver;&quot;:{ return vm.resolveClass(&quot;android/content/ContentResolver&quot;).newObject(signature); } } return super.callObjectMethodV(vm, dvmObject, signature, vaList); } 三、字符串类型如何构造，字节数组如何构造，对象数组如何构造，参数2的实例对象怎么传？传入Native的JAVA参数，除了八个基本类型外（byte、char、short、int、long、float、double、boolean），都必须vm.addLocalObject添加到局部引用中去。其他的对象类型一律要手动 addLocalObject。 12345678910111213141516171819//字符串list.add(vm.addLocalObject(new StringObject(vm, &quot;12345&quot;)));list.add(vm.addLocalObject(new StringObject(vm, &quot;r0ysue&quot;)));//字节数组ByteArray plainText = new ByteArray(vm, &quot;r0ysue&quot;.getBytes(StandardCharsets.UTF_8));list.add(vm.addLocalObject(plainText));//参数2的实例对象怎么传需要注意的是，以往我一直直接把参数2填0，这是偷懒但有风险的做法，还是建议老老实实初始化类或对象，传hashCode进去，代码如下public DvmClass cNative;cNative = vm.resolveClass(&quot;com/roysue/test623/MainActivity&quot;);DvmObject&lt;?&gt; cnative = cNative.newObject(null);List&lt;Object&gt; list = new ArrayList&lt;&gt;(10);list.add(vm.getJNIEnv()); // 第一个参数是envlist.add(cnative.hashCode()); // 第二个参数，实例方法是jobject，静态方法是jclazz，直接填0这里是不行的，此样本参数2被使用了 四、如何判断是Thumb还是ARMARM模式指令总是4字节长度，Thumb指令长度多数为2字节，少部分指令是4字节。1、找准一行汇编，Alt+G快捷键。Thumb模式是1，ARM模式是0。 代码是Thumb模式，调用的时候别忘了+1，Thumb的+1只在运行和Hook时需要考虑，打Patch和下断点不用 1Number number = module.callFunction(emulator, 0x1E7C + 1, list.toArray())[0]; 五、patch修改指令第一种方法 1234public void patchVerify(){ int patchCode = 0x4FF00100; //mov r0,1 相对应的opcode就是4FF00100 emulator.getMemory().pointer(module.base + 0x1E86).setInt(0,patchCode);} 第二种方法 123456789101112131415161718192021public void patchVerify(){ int patchCode = 0x4FF00100; emulator.getMemory().pointer(module.base+0x1E86).setInt(0,patchCode);}public void patchVerify1(){ Pointer pointer = UnidbgPointer.pointer(emulator, module.base + 0x1E86); assert pointer != null; byte[] code = pointer.getByteArray(0, 4); if (!Arrays.equals(code, new byte[]{ (byte)0xFF, (byte) 0xF7, (byte) 0xEB, (byte) 0xFE })) { // BL sub_1C60 throw new IllegalStateException(Inspector.inspectString(code, &quot;patch32 code=&quot; + Arrays.toString(code))); } try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) { KeystoneEncoded encoded = keystone.assemble(&quot;mov r0,1&quot;); byte[] patch = encoded.getMachineCode(); if (patch.length != code.length) { throw new IllegalStateException(Inspector.inspectString(patch, &quot;patch32 length=&quot; + patch.length)); } pointer.write(0, patch, 0, patch.length); }}; 六、Unidbg Hook使用hookZz 12345678910111213141516171819202122public void HookMDStringOld(){ IHookZz hookZz = HookZz.getInstance(emulator); hookZz.wrap(module.base + 0x1BD0 + 1, new WrapCallback&lt;HookZzArm32RegisterContext&gt;() { @Override // onEnter // 类似于 frida onEnter public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) { // 类似于Frida args[0] Pointer input = ctx.getPointerArg(0); System.out.println(&quot;input:&quot; + input.getString(0)); } @Override // onLeave // 类似于 frida onLeave public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) { Pointer result = ctx.getPointerArg(0); System.out.println(&quot;input:&quot;+result.getString(0)); } });} Inline hook 12345678910public void hook_315B0(){ IHookZz hookZz = HookZz.getInstance(emulator); hookZz.enable_arm_arm64_b_branch(); hookZz.instrument(module.base + 0x315B0 + 1, new InstrumentCallback&lt;Arm32RegisterContext&gt;() { @Override public void dbiCall(Emulator&lt;?&gt; emulator, Arm32RegisterContext ctx, HookEntryInfo info) { // 通过base+offset inline wrap内部函数，在IDA看到为sub_xxx那些 System.out.println(&quot;R2:&quot;+ctx.getR2Long()); } }); } Unidbg 1234567891011121314151617181920212223242526272829303132public void hookByUnicorn(){ emulator.getBackend().hook_add_new(new CodeHook() { @Override public void hook(Backend backend, long address, int size, Object user) { if (address == module.base + 0x9D24){ System.out.println(&quot;Hook By Unicorn&quot;); RegisterContext ctx = emulator.getContext(); Pointer input1 = ctx.getPointerArg(0); Pointer input2 = ctx.getPointerArg(1); Pointer input3 = ctx.getPointerArg(2); // getString的参数i代表index,即input[i:] System.out.println(&quot;参数1：&quot;+input1.getString(0)); System.out.println(&quot;参数2：&quot;+input2.getString(0)); System.out.println(&quot;参数3：&quot;+input3.getString(0)); buffer = ctx.getPointerArg(3); } if(address == (module.base + 0x9d28)){ Inspector.inspect(buffer.getByteArray(0,0x100), &quot;Unicorn hook EncryptWallEncode&quot;); } } @Override public void onAttach(Unicorn.UnHook unHook) { System.out.println(&quot;onAttach&quot;); } @Override public void detach() { System.out.println(&quot;detach&quot;); } },module.base + 0x9D24,module.base + 0x9D28,null);} 七、Unidbg Console Debugger12345public void HookByConsoleDebugger(){ Debugger debugger = emulator.attach(); debugger.addBreakPoint(module.base+0x9d24); debugger.addBreakPoint(module.base+0x9d28);} 八、loadLibrary如果在加载so到虚拟内存的步骤中，参数二设为false(即不执行init相关函数)，会出现乱码。其实其中的道理并不复杂，甚至可以说很简单——SO样本做了字符串的混淆或加密，以此来对抗分析人员，但字符串总是要解密的，不然怎么用呢？这个解密一般发生在Init array节或者JNI OnLoad中，又或者是该字符串使用前的任何一个时机。 1DalvikModule dm = vm.loadLibrary(new File(&quot;unidbg-android\\\\src\\\\test\\\\java\\\\com\\\\zuiyou\\\\libnet_crypto.so&quot;), true); // 加载so到虚拟内存 九、各种补环境补Context 1234567891011@Override public DvmObject&lt;?&gt; callStaticObjectMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) { switch (signature) { case &quot;com/izuiyou/common/base/BaseApplication-&gt;getAppContext()Landroid/content/Context;&quot;: return vm.resolveClass(&quot;android/content/Context&quot;).newObject(null); case &quot;java/util/UUID-&gt;randomUUID()Ljava/util/UUID;&quot;: return dvmClass.newObject(UUID.randomUUID()); } return super.callStaticObjectMethodV(vm, dvmClass, signature, vaList); } 补一个空类 123456789@Overridepublic DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) { switch (signature) { case &quot;android/content/Context-&gt;getClass()Ljava/lang/Class;&quot;:{ return dvmObject.getObjectType(); } } return super.callObjectMethodV(vm, dvmObject, signature, vaList);}; 补具体类名 123456789101112@Override public DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) { switch (signature) { case &quot;android/content/Context-&gt;getClass()Ljava/lang/Class;&quot;:{ return dvmObject.getObjectType(); } case &quot;java/lang/Class-&gt;getSimpleName()Ljava/lang/String;&quot;:{ return new StringObject(vm, &quot;AppController&quot;); } } return super.callObjectMethodV(vm, dvmObject, signature, vaList); }; 补文件路径 12345678910111213141516@Override public DvmObject&lt;?&gt; callObjectMethodV(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VaList vaList) { switch (signature) { case &quot;android/content/Context-&gt;getClass()Ljava/lang/Class;&quot;:{ return dvmObject.getObjectType(); } case &quot;java/lang/Class-&gt;getSimpleName()Ljava/lang/String;&quot;:{ return new StringObject(vm, &quot;AppController&quot;); } case &quot;android/content/Context-&gt;getFilesDir()Ljava/io/File;&quot;: case &quot;java/lang/String-&gt;getAbsolutePath()Ljava/lang/String;&quot;: { return new StringObject(vm, &quot;/data/user/0/cn.xiaochuankeji.tieba/files&quot;); } } return super.callObjectMethodV(vm, dvmObject, signature, vaList); }; 检测是否有调试 12345678910@Override public boolean callStaticBooleanMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) { switch (signature){ case &quot;android/os/Debug-&gt;isDebuggerConnected()Z&quot;:{ return false; } } throw new UnsupportedOperationException(signature); } 使用Unidbg的API返回PID 12345678910@Override public int callStaticIntMethodV(BaseVM vm, DvmClass dvmClass, String signature, VaList vaList) { switch (signature){ case &quot;android/os/Process-&gt;myPid()I&quot;:{ return emulator.getPid(); } } throw new UnsupportedOperationException(signature); } 判断map是否为空 123456789@Override public boolean callBooleanMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) { if (&quot;java/util/Map-&gt;isEmpty()Z&quot;.equals(signature)) { TreeMap&lt;String, String&gt; treeMap = (TreeMap&lt;String, String&gt;)dvmObject.getValue(); return treeMap.isEmpty(); } return super.callBooleanMethod(vm, dvmObject, signature, varArg); } 补map.get 12345678910111213@Override public DvmObject&lt;?&gt; callObjectMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) { switch (signature) { case &quot;java/util/Map-&gt;get(Ljava/lang/Object;)Ljava/lang/Object;&quot;: StringObject keyobject = varArg.getObjectArg(0); String key = keyobject.getValue(); TreeMap&lt;String, String&gt; treeMap = (TreeMap&lt;String, String&gt;)dvmObject.getValue(); String value = treeMap.get(key); return new StringObject(vm, value); } return super.callObjectMethod(vm, dvmObject, signature, varArg); } 补SignedQuery类的init，也就是初始化一个SignedQuery对象 123456789101112131415161718192021222324252627282930313233343536 @Override public DvmObject&lt;?&gt; newObject(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) { switch (signature) { case &quot;com/bilibili/nativelibrary/SignedQuery-&gt;&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;)V&quot;: StringObject stringObject1 = varArg.getObjectArg(0); StringObject stringObject2 = varArg.getObjectArg(1); String str1 = stringObject1.getValue(); String str2 = stringObject2.getValue(); return vm.resolveClass(&quot;com/bilibili/nativelibrary/SignedQuery&quot;).newObject(new SignedQuery(str1, str2)); } return super.newObject(vm, dvmClass, signature, varArg); }@Override public DvmObject&lt;?&gt; newObject(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) { switch (signature) { case &quot;com/bilibili/nativelibrary/SignedQuery-&gt;&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;)V&quot;: StringObject stringObject1 = varArg.getObjectArg(0); StringObject stringObject2 = varArg.getObjectArg(1); String str1 = stringObject1.getValue(); String str2 = stringObject2.getValue(); return vm.resolveClass(&quot;com/bilibili/nativelibrary/SignedQuery&quot;).newObject(new SignedQuery(str1, str2)); } return super.newObject(vm, dvmClass, signature, varArg); } //因为用jadx查看SignedQuery类的代码，有俩成员以及构造函数，所以根据他的成员和构造函数，newObject一个SignedQuery类，搞一个简化版的内部类给它用 public class SignedQuery { public final String a; public final String b; public SignedQuery(String str, String str2) { this.a = str; this.b = str2; } }; 补签名 1234567891011@Override public int callIntMethod(BaseVM vm, DvmObject&lt;?&gt; dvmObject, String signature, VarArg varArg) { switch (signature) { case &quot;android/content/pm/Signature-&gt;hashCode()I&quot;: if (dvmObject instanceof Signature) { Signature sig = (Signature) dvmObject; return sig.getHashCode(); } } return super.callIntMethod(vm, dvmObject, signature, varArg); } 初始化异常类 123456789@Override public DvmObject&lt;?&gt; newObject(BaseVM vm, DvmClass dvmClass, String signature, VarArg varArg) { switch (signature){ case &quot;java/lang/Throwable-&gt;&lt;init&gt;()V&quot;:{ return vm.resolveClass(&quot;java/lang/Throwable&quot;).newObject(new Throwable()); } } return super.newObject(vm, dvmClass, signature, varArg); } 十、文件重定向/文件访问当样本做文件访问时，Unidbg重定向到本机的某个位置，进入 src/main/java/com/github/unidbg/file/BaseFileSystem.java在构造函数第三行加上 System.out.print(“virtual path:” + rootDir); 打印虚拟路径，接下来我们按照要求，在报错提示目录下新建对应文件夹，并把我们的apk复制进去，改名成报错提示需要的apk。 1234public BaseFileSystem(Emulator&lt;T&gt; emulator, File rootDir) { this.emulator = emulator; this.rootDir = rootDir; System.out.print(&quot;virtual path:&quot; + rootDir); 创建模拟器实例的时候，加上setRootDir(new File(“target/rootfs”)，运行代码的时候会自动创建生成target/rootfs目录 1emulator = AndroidEmulatorBuilder.for32Bit().setRootDir(new File(&quot;target/rootfs&quot;)).setProcessName(&quot;com.xunmeng.pinduoduo&quot;).build(); 除此之外，也可以通过代码的方式进行操作 我们的类实现文件重定向的接口即可，只需要三个步骤，如下： 12345678910111213141516171819202122232425262728293031323334// 1 实现IOResolvepublic class NBridge extends AbstractJni implements IOResolver { private final AndroidEmulator emulator; private final VM vm; private final Module module; NBridge(){ emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.meituan&quot;).build(); final Memory memory = emulator.getMemory(); // 模拟器的内存操作接口 memory.setLibraryResolver(new AndroidResolver(23)); // 设置系统类库解析 vm = emulator.createDalvikVM(new File(&quot;C:\\\\Users\\\\pr0214\\\\Desktop\\\\DTA\\\\unidbg\\\\versions\\\\unidbg-2021-5-17\\\\unidbg-master\\\\unidbg-android\\\\src\\\\test\\\\java\\\\com\\\\lession7\\\\mt.apk&quot;)); // 创建Android虚拟机 // 2 绑定IO重定向接口 emulator.getSyscallHandler().addIOResolver(this); vm.setVerbose(true); // 设置是否打印Jni调用细节 DalvikModule dm = vm.loadLibrary(new File(&quot;C:\\\\Users\\\\pr0214\\\\Desktop\\\\DTA\\\\unidbg\\\\versions\\\\unidbg-2021-5-17\\\\unidbg-master\\\\unidbg-android\\\\src\\\\test\\\\java\\\\com\\\\lession7\\\\libmtguard.so&quot;), true); module = dm.getModule(); // vm.setJni(this); dm.callJNI_OnLoad(emulator); } // 3 @Override public FileResult resolve(Emulator emulator, String pathname, int oflags) { if ((&quot;/data/app/com.sankuai.meituan-TEfTAIBttUmUzuVbwRK1DQ==/base.apk&quot;).equals(pathname)) { // 填入想要重定位的文件 return FileResult.success(new SimpleFileIO(oflags, new File(&quot;unidbg-android\\\\src\\\\test\\\\java\\\\com\\\\lession10\\\\mt.apk&quot;), pathname)); } return null; } 补文件 12345678910 @Override public FileResult resolve(Emulator emulator, String pathname, int oflags) { if ((&quot;proc/&quot;+emulator.getPid()+&quot;/cmdline&quot;).equals(pathname)) { return FileResult.success(new ByteArrayFileIO(oflags, pathname, &quot;ctrip.android.view&quot;.getBytes())); } return null; } // 除此之外也可以像上面一样新建一个文件，传入文件return FileResult.success(new SimpleFileIO(oflags, new File(&quot;D:\\\\unidbg-teach\\\\unidbg- android\\\\src\\\\test\\\\java\\\\com\\\\lession1\\\\cmdline&quot;), pathname)); 十一、打印地址所指向的内存，其效果类似于frida中hexdump，push保存，在后面再pop取出12345678910111213141516171819202122232425public void hook65540(){ // 加载HookZz IHookZz hookZz = HookZz.getInstance(emulator); hookZz.wrap(module.base + 0x65540 + 1, new WrapCallback&lt;HookZzArm32RegisterContext&gt;() { // inline wrap导出函数 @Override // 类似于 frida onEnter public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) { // 类似于Frida args[0] Inspector.inspect(ctx.getR0Pointer().getByteArray(0, 0x10), &quot;Arg1&quot;); System.out.println(ctx.getR1Long()); Inspector.inspect(ctx.getR2Pointer().getByteArray(0, 0x10), &quot;Arg3&quot;); ctx.push(ctx.getR2Pointer()); //push保存 }; @Override // 类似于 frida onLeave public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) { // pop 取出 Pointer output = ctx.pop(); Inspector.inspect(output.getByteArray(0, 0x10), &quot;Arg3 after function&quot;); } }); } 十二、如何主动调用一个Native函数1234567891011121314151617181920212223242526272829public void callMd5(){ List&lt;Object&gt; list = new ArrayList&lt;&gt;(10); // arg1 String input = &quot;r0ysue&quot;; // malloc memory MemoryBlock memoryBlock1 = emulator.getMemory().malloc(16, false); // get memory pointer UnidbgPointer input_ptr=memoryBlock1.getPointer(); // write plainText on it input_ptr.write(input.getBytes(StandardCharsets.UTF_8)); // arg2 int input_length = input.length(); // arg3 -- buffer MemoryBlock memoryBlock2 = emulator.getMemory().malloc(16, false); UnidbgPointer output_buffer=memoryBlock2.getPointer(); // 填入参入 list.add(input_ptr); list.add(input_length); list.add(output_buffer); // run module.callFunction(emulator, 0x65540 + 1, list.toArray()); // print arg3 Inspector.inspect(output_buffer.getByteArray(0, 0x10), &quot;output&quot;); }; 十三、unidbg下断点12345普通断点emulator.attach().addBreakPoint(module.base + 0x3161E);内存写入断点emulator.traceWrite(module.base + 0x3A0C0,module.base + 0x3A0C0); 命令 12345678910111213141516171819202122232425262728293031323334353637383940c: continuen: step overbt: back tracest hex: search stackshw hex: search writable heapshr hex: search readable heapshx hex: search executable heapnb: break at next blocks|si: step intos[decimal]: execute specified amount instructions(blx): execute util BLX mnemonic, low performancem(op) [size]: show memory, default size is 0x70, size may hex or decimalmr0-mr7, mfp, mip, msp [size]: show memory of specified registerm(address) [size]: show memory of specified address, address must start with 0xwr0-wr7, wfp, wip, wsp : write specified registerwb(address), ws(address), wi(address) : write (byte, short, integer) memory of specified address, address must start with 0xwx(address) : write bytes to memory at specified address, address must start with 0xb(address): add temporarily breakpoint, address must start with 0x, can be module offsetb: add breakpoint of register PCr: remove breakpoint of register PCblr: add temporarily breakpoint of register LRp (assembly): patch assembly at PC addresswhere: show java stack tracetrace [begin end]: Set trace instructionstraceRead [begin end]: Set trace memory readtraceWrite [begin end]: Set trace memory writevm: view loaded modulesvbs: view breakpointsd|dis: show disassembled(0x): show disassemble at specify addressstop: stop emulationrun [arg]: run testcc size: convert asm from 0x40001ddc - 0x40001ddc + size bytes to c function 十四、unidbg traceCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129emulator.traceCode(module.base, module.base + module.size);//traceCode保存到文件String traceFile = &quot;unidbg-android\\\\src\\\\test\\\\java\\\\com\\\\lession5\\\\qxstrace.txt&quot;;PrintStream traceStream = new PrintStream(new FileOutputStream(traceFile), true);emulator.traceCode(module.base, module.base+module.size).setRedirect(traceStream);//修改unidbg源码，保存关键的寄存器值信息找到代码文件 src/main/java/com/github/unidbg/arm/AbstractARMEmulator.java//添加值显示private void printAssemble(PrintStream out, Capstone.CsInsn[] insns, long address, boolean thumb) { StringBuilder sb = new StringBuilder(); for (Capstone.CsInsn ins : insns) { sb.append(&quot;### Trace Instruction &quot;); sb.append(ARM.assembleDetail(this, ins, address, thumb)); // 打印每条汇编指令里参与运算的寄存器的值 Set&lt;Integer&gt; regset = new HashSet&lt;Integer&gt;(); Arm.OpInfo opInfo = (Arm.OpInfo) ins.operands; for(int i = 0; i&lt;opInfo.op.length; i++){ regset.add(opInfo.op[i].value.reg); } String RegChange = ARM.SaveRegs(this, regset); sb.append(RegChange); sb.append('\\n'); address += ins.size; } out.print(sb);}src/main/java/com/github/unidbg/arm/ARM.java 中，新建SaveRegs方法，实际上就是showregs的代码，只不过从print改成return回来而已。public static String SaveRegs(Emulator&lt;?&gt; emulator, Set&lt;Integer&gt; regs) { Backend backend = emulator.getBackend(); StringBuilder builder = new StringBuilder(); builder.append(&quot;&gt;&gt;&gt;&quot;); Iterator it = regs.iterator(); while(it.hasNext()) { int reg = (int) it.next(); Number number; int value; switch (reg) { case ArmConst.UC_ARM_REG_R0: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; r0=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R1: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; r1=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R2: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; r2=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R3: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; r3=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R4: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; r4=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R5: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; r5=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R6: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; r6=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R7: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; r7=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R8: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; r8=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R9: // UC_ARM_REG_SB number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; sb=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_R10: // UC_ARM_REG_SL number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; sl=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_FP: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; fp=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_IP: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; ip=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_SP: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; SP=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_LR: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; LR=0x%x&quot;, value)); break; case ArmConst.UC_ARM_REG_PC: number = backend.reg_read(reg); value = number.intValue(); builder.append(String.format(Locale.US, &quot; PC=0x%x&quot;, value)); break; } } return builder.toString(); } 十五、开启所有的日志123456Logger.getLogger(&quot;com.github.unidbg.linux.ARM32SyscallHandler&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.unix.UnixSyscallHandler&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.AbstractEmulator&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.linux.android.dvm.DalvikVM&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.linux.android.dvm.BaseVM&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.linux.android.dvm&quot;).setLevel(Level.DEBUG); 十六、注册libAndroid.so虚拟模块1234new AndroidModule(emulator,vm).register(memory);只用这一句即可，需要注意，一定要在样本SO加载前加载它(也就是vm.loadLibrary之前)。道理也很简单，系统SO肯定比用户SO加载早鸭。 Tips: getPackageCodePath 返回android 安装包的完整路径，这个包是一个zip的压缩文件，它包括应用程序的代码和assets文件。 12// 获取当前apk路径adb shell pm path apk包名 方法：getFilesDir释义：返回通过Context.openFileOutput()创建和存储的文件系统的绝对路径，应用程序文件，这些文件会在程序被卸载的时候全部删掉。 方法：getCacheDir释义：返回应用程序指定的缓存目录，这些文件在设备内存不足时会优先被删除掉，所以存放在这里的文件是没有任何保障的，可能会随时丢掉。 方法：getDir释义：这是一个可以存放你自己应用程序自定义的文件，你可以通过该方法返回的File实例来创建或者访问这个目录，注意该目录下的文件只有你自己的程序可以访问。 方法：getExternalCacheDir释义：使用这个方法需要写外部存储的权限“”，调用该方法会返回应用程序的外部文件系统（Environment.getExternalStorageDirectory()）目录的绝对路径，它是用来存放应用的缓存文件，它和getCacheDir目录一样，目录下的文件都会在程序被卸载的时候被清除掉。 方法：getExternalFilesDir释义：使用这个方法需要写外部存储的权限“”，这个目录是与应用程序相关的外部文件系统，它和getExternalCacheDir不一样的是只要应用程序存在它就会一直存在，这些文件只属于你的应用，不能被其它人访问。同样，这个目录下的文件在程序被卸载时也会被一同删除。 方法：getDatabasePath释义：保存通过Context.openOrCreateDatabase 创建的数据库文件 方法：getPackageCodePath释义：返回android 安装包的完整路径，这个包是一个zip的压缩文件，它包括应用程序的代码和assets文件。 方法：getPackageResourcePath释义：返回android 安装包的完整路径，这个包是一个ZIP的要锁文件，它包括应用程序的私有资源。 方法：getObbDir释义：返回应用程序的OBB文件目录（如果有的话），注意如果该应用程序没有任何OBB文件，这个目录是不存在的。","link":"/20220110/Unidbg%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E4%B9%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"密码学 MD5信息摘要算法","text":"一、简介MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5由美国密码学家罗纳德·李维斯特（Ronald Linn Rivest）设计，于1992年公开，用以取代MD4算法。这套算法的程序在 RFC 1321 标准中被加以规范。 1996年后该算法被证实存在弱点，可以被加以破解，对于需要高度安全性的数据，专家一般建议改用其他算法，如SHA-2。2004年，证实MD5算法无法防止碰撞（collision），因此不适用于安全性认证，如SSL公开密钥认证或是数字签名等用途。 二、MD5 哈希算法流程1、按位补充数据在MD5算法中，首先需要对信息进行填充，这个数据按位(bit)补充，要求最终的位数对512求模的结果为448。补位至 N *512+448。即 N *64+56个字节（Bytes），N为一个正整数言而总之，至少补1位，而最多可能补512位 。 2、扩展长度用一个64位的数字表示数据的原始长度b，把b用两个32位数表示。那么只取b的低64位。当遇到b大于2^64这种极少遇到的情况时，数据就被填补成长度为512位的倍数。也就是说，此时的数据长度是16个字（32位）的整数倍数。现在的信息字节长度=N*512+448+64=(N+1)*512，即长度恰好是512的整数倍。 3、初始化MD缓存器MD5运算要用到一个128位的MD5缓存器，用来保存中间变量和最终结果。该缓存器又可看成是4个32位的寄存器A、B、C、D。初始化为: A=0X01234567B=0X89abcdefC=0Xfedcba98D=0X76543210 4、处理数据段将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。以一下是每次操作中用到的四个非线性函数（每轮一个）。 F(X,Y,Z) =(X&amp;Y) | ( (~ X) &amp; Z)G(X,Y,Z) =(X&amp;Z) | (Y&amp;(~ Z))H(X,Y,Z) =X ^ Y ^ ZI(X,Y,Z)=Y^(X | (~ Z))(&amp;是与，|是或，~是非，^是异或) 5、四轮运算首先，应当将初始输入ABCD存起来： 1234567NPUT_A = AINPUT_B = BINPUT_C = CINPUT_D = D 第一轮：F(X,Y,Z) =(X&amp;Y)|((~X)&amp;Z) 12345678910111213141516171819202122232425262728293031A = B+((A+F(B,C,D)+M[0]+T[1])&lt;&lt;&lt;7) D = A+((D+F(A,B,C)+M[1]+T[2])&lt;&lt;&lt;12) C = D+((C+F(D,A,B)+M[2]+T[3])&lt;&lt;&lt;17) B = C+((B+F(C,D,A)+M[3]+T[4])&lt;&lt;&lt;22) A = B+((A+F(B,C,D)+M[4]+T[5])&lt;&lt;&lt;7) D = A+((D+F(A,B,C)+M[5]+T[6])&lt;&lt;&lt;12) C = D+((C+F(D,A,B)+M[6]+T[7])&lt;&lt;&lt;17) B = C+((B+F(C,D,A)+M[7]+T[8])&lt;&lt;&lt;22) A = B+((A+F(B,C,D)+M[8]+T[9])&lt;&lt;&lt;7) D = A+((D+F(A,B,C)+M[9]+T[10])&lt;&lt;&lt;12) C = D+((C+F(D,A,B)+M[10]+T[11])&lt;&lt;&lt;17) B = C+((B+F(C,D,A)+M[11]+T[12])&lt;&lt;&lt;22) A = B+((A+F(B,C,D)+M[12]+T[13])&lt;&lt;&lt;7) D = A+((D+F(A,B,C)+M[13]+T[14])&lt;&lt;&lt;12) C = D+((C+F(D,A,B)+M[14]+T[15])&lt;&lt;&lt;17) B = C+((B+F(C,D,A)+M[15]+T[16])&lt;&lt;&lt;22) 第二轮：G(X,Y,Z) =(X&amp;Z)|(Y&amp;(~Z)) 12345678910111213141516171819202122232425262728293031A = B+((A+G(B,C,D)+M[1]+T[17])&lt;&lt;&lt;5) D = A+((D+G(A,B,C)+M[6]+T[18])&lt;&lt;&lt;9) C = D+((C+G(D,A,B)+M[11]+T[19])&lt;&lt;&lt;14) B = C+((B+G(C,D,A)+M[0]+T[20])&lt;&lt;&lt;20) A = B+((A+G(B,C,D)+M[5]+T[21])&lt;&lt;&lt;5) D = A+((D+G(A,B,C)+M[10]+T[22])&lt;&lt;&lt;9) C = D+((C+G(D,A,B)+M[15]+T[23])&lt;&lt;&lt;14) B = C+((B+G(C,D,A)+M[4]+T[24])&lt;&lt;&lt;20) A = B+((A+G(B,C,D)+M[9]+T[25])&lt;&lt;&lt;5) D = A+((D+G(A,B,C)+M[14]+T[26])&lt;&lt;&lt;9) C = D+((C+G(D,A,B)+M[3]+T[27])&lt;&lt;&lt;14) B = C+((B+G(C,D,A)+M[8]+T[28])&lt;&lt;&lt;20) A = B+((A+G(B,C,D)+M[13]+T[29])&lt;&lt;&lt;5) D = A+((D+G(A,B,C)+M[2]+T[30])&lt;&lt;&lt;9) C = D+((C+G(D,A,B)+M[7]+T[31])&lt;&lt;&lt;14) B = C+((B+G(C,D,A)+M[12]+T[32])&lt;&lt;&lt;20) 第三轮：H(X,Y,Z) =X ^ Y ^ Z 12345678910111213141516171819202122232425262728293031A = B+((A+H(B,C,D)+M[5]+T[33])&lt;&lt;&lt;4) D = A+((D+H(A,B,C)+M[8]+T[34])&lt;&lt;&lt;11) C = D+((C+H(D,A,B)+M[11]+T[35])&lt;&lt;&lt;16) B = C+((B+H(C,D,A)+M[14]+T[36])&lt;&lt;&lt;23) A = B+((A+H(B,C,D)+M[1]+T[37])&lt;&lt;&lt;4) D = A+((D+H(A,B,C)+M[4]+T[38])&lt;&lt;&lt;11) C = D+((C+H(D,A,B)+M[7]+T[39])&lt;&lt;&lt;16) B = C+((B+H(C,D,A)+M[10]+T[40])&lt;&lt;&lt;23) A = B+((A+H(B,C,D)+M[13]+T[41])&lt;&lt;&lt;4) D = A+((D+H(A,B,C)+M[0]+T[42])&lt;&lt;&lt;11) C = D+((C+H(D,A,B)+M[3]+T[43])&lt;&lt;&lt;16) B = C+((B+H(C,D,A)+M[6]+T[44])&lt;&lt;&lt;23) A = B+((A+H(B,C,D)+M[9]+T[45])&lt;&lt;&lt;4) D = A+((D+H(A,B,C)+M[12]+T[46])&lt;&lt;&lt;11) C = D+((C+H(D,A,B)+M[15]+T[47])&lt;&lt;&lt;16) B = C+((B+H(C,D,A)+M[2]+T[48])&lt;&lt;&lt;23) 第四轮：I(X,Y,Z)=Y^(X|(~Z)) 12345678910111213141516171819202122232425262728293031A = B+((A+I(B,C,D)+M[0]+T[33])&lt;&lt;&lt;6) D = A+((D+I(A,B,C)+M[7]+T[34])&lt;&lt;&lt;10) C = D+((C+I(D,A,B)+M[14]+T[35])&lt;&lt;&lt;15) B = C+((B+I(C,D,A)+M[5]+T[36])&lt;&lt;&lt;21) A = B+((A+I(B,C,D)+M[12]+T[37])&lt;&lt;&lt;6) D = A+((D+I(A,B,C)+M[3]+T[38])&lt;&lt;&lt;10) C = D+((C+I(D,A,B)+M[10]+T[39])&lt;&lt;&lt;15) B = C+((B+I(C,D,A)+M[1]+T[40])&lt;&lt;&lt;21) A = B+((A+I(B,C,D)+M[8]+T[41])&lt;&lt;&lt;6) D = A+((D+I(A,B,C)+M[15]+T[42])&lt;&lt;&lt;10) C = D+((C+I(D,A,B)+M[6]+T[43])&lt;&lt;&lt;15) B = C+((B+I(C,D,A)+M[13]+T[44])&lt;&lt;&lt;21) A = B+((A+I(B,C,D)+M[4]+T[45])&lt;&lt;&lt;6) D = A+((D+I(A,B,C)+M[11]+T[46])&lt;&lt;&lt;10) C = D+((C+I(D,A,B)+M[2]+T[47])&lt;&lt;&lt;15) B = C+((B+I(C,D,A)+M[9]+T[48])&lt;&lt;&lt;21) 四轮运算完成后，将此时的ABCD与原始输入分别相加。 1234567A = A + INPUT_AB = B + INPUT_BC = C + INPUT_CD = D + INPUT_D 至此，一次循环就完成了，最后的输出ABCD可以作为下一次的初始输入或最终输出。 三、测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165# coding=utf-8# 引入math模块，因为要用到sin函数import math# 定义常量，用于初始化128位变量，注意字节顺序，文中的A=0x01234567，这里低值存放低字节，即01 23 45 67，所以运算时A=0x67452301，其他类似。# 这里用字符串的形势，是为了和hex函数的输出统一，hex(10)输出为'0xA',注意结果为字符串。A = '0x67452301'B = '0xefcdab89'C = '0x98badcfe'D = '0x10325476'# 定义每轮中用到的函数。L为循环左移，注意左移之后可能会超过32位，所以要和0xffffffff做与运算，确保结果为32位。# (&amp;是与，|是或，~是非，^是异或)F = lambda x, y, z: ((x &amp; y) | ((~x) &amp; z))G = lambda x, y, z: ((x &amp; z) | (y &amp; (~z)))H = lambda x, y, z: (x ^ y ^ z)I = lambda x, y, z: (y ^ (x | (~z)))L = lambda x, n: (((x &lt;&lt; n) | (x &gt;&gt; (32 - n))) &amp; (0xffffffff))# 定义每轮中循环左移的位数，这里用4个元组表示,用元组是因为速度比列表快。shi_1 = (7, 12, 17, 22) * 4shi_2 = (5, 9, 14, 20) * 4shi_3 = (4, 11, 16, 23) * 4shi_4 = (6, 10, 15, 21) * 4# 定义每轮中用到的M[i]次序。m_1 = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)m_2 = (1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12)m_3 = (5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2)m_4 = (0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9)# 定义函数，用来产生常数T[i]，常数有可能超过32位，同样需要&amp;0xffffffff操作。注意返回的是十进制的数。def T(i): result = (int(4294967296 * abs(math.sin(i)))) &amp; 0xffffffff return result# 定义函数，用来将列表中的元素循环右移。原因是在每轮操作中，先运算A的值，然后是D，C，B，16轮之后右恢复原来顺序，所以只要每次操作第一个元素即可。def shift(shift_list): shift_list = [shift_list[3], shift_list[0], shift_list[1], shift_list[2]] return shift_list# 定义主要的函数，参数为当做种子的列表，每轮用到的F，G，H，I，生成的M[]，以及循环左移的位数。该函数完成一轮运算。def fun(fun_list, f, m, shi): count = 0 global Ti_count # 引入全局变量，T(i)是从1到64循环的。 while count &lt; 16: xx = int(fun_list[0], 16) + f(int(fun_list[1], 16), int(fun_list[2], 16), int(fun_list[3], 16)) + int(m[count], 16) + T( Ti_count) xx = xx &amp; 0xffffffff ll = L(xx, shi[count]) fun_list[0] = hex((int(fun_list[1], 16) + ll) &amp; (0xffffffff))[:-1] # 最后的[:-1]是为了去除类似'0x12345678L'最后的'L' fun_list = shift(fun_list) count += 1 Ti_count += 1 print fun_list return fun_list# 该函数生成每轮需要的M[]，最后的参数是为了当有很多分组时，进行偏移。def genM16(order, ascii_list, f_offset): ii = 0 m16 = [0] * 16 f_offset = f_offset * 64 for i in order: i = i * 4 m16[ii] = '0x' + ''.join((ascii_list[i + f_offset] + ascii_list[i + 1 + f_offset] + ascii_list[ i + 2 + f_offset] + ascii_list[i + 3 + f_offset]).split('0x')) ii += 1 for c in m16: ind = m16.index(c) m16[ind] = reverse_hex(c) return m16# 翻转十六进制数的顺序：'0x01234567' =&gt; '0x67452301'def reverse_hex(hex_str): hex_str = hex_str[2:] hex_str_list = [] for i in range(0, len(hex_str), 2): hex_str_list.append(hex_str[i:i + 2]) hex_str_list.reverse() hex_str_result = '0x' + ''.join(hex_str_list) return hex_str_result# 显示结果函数，将最后运算的结果列表进行翻转，合并成字符串的操作。def show_result(f_list): result = '' f_list1 = [0] * 4 for i in f_list: f_list1[f_list.index(i)] = reverse_hex(i)[2:] result = result + f_list1[f_list.index(i)] return result# 程序主循环while True: abcd_list = [A, B, C, D] Ti_count = 1 input_m = raw_input('msg&gt;&gt;&gt;') # 对每一个输入先添加一个'0x80'，即'10000000' ascii_list = map(hex, map(ord, input_m)) msg_lenth = len(ascii_list) * 8 ascii_list.append('0x80') # 补充0 while (len(ascii_list) * 8 + 64) % 512 != 0: ascii_list.append('0x00') # 最后64为存放消息长度，注意长度存放顺序低位在前。 # 例如，消息为'a'，则长度为'0x0800000000000000' msg_lenth_0x = hex(msg_lenth)[2:] msg_lenth_0x = '0x' + msg_lenth_0x.rjust(16, '0') msg_lenth_0x_big_order = reverse_hex(msg_lenth_0x)[2:] msg_lenth_0x_list = [] for i in range(0, len(msg_lenth_0x_big_order), 2): msg_lenth_0x_list.append('0x' + msg_lenth_0x_big_order[i:i + 2]) ascii_list.extend(msg_lenth_0x_list) print ascii_list # 对每个分组进行4轮运算 for i in range(0, len(ascii_list) / 64): # 将最初128位种子存放在变量中， aa, bb, cc, dd = abcd_list # 根据顺序产生每轮M[]列表 order_1 = genM16(m_1, ascii_list, i) order_2 = genM16(m_2, ascii_list, i) order_3 = genM16(m_3, ascii_list, i) order_4 = genM16(m_4, ascii_list, i) # 主要四轮运算，注意打印结果列表已经被进行过右移操作！ abcd_list = fun(abcd_list, F, order_1, shi_1) print '--------------------------------------' abcd_list = fun(abcd_list, G, order_2, shi_2) print '--------------------------------------' abcd_list = fun(abcd_list, H, order_3, shi_3) print '--------------------------------------' abcd_list = fun(abcd_list, I, order_4, shi_4) print '--------------------------------------' # 将最后输出与最初128位种子相加，注意，最初种子不能直接使用abcd_list[0]等，因为abcd_list已经被改变 output_a = hex((int(abcd_list[0], 16) + int(aa, 16)) &amp; 0xffffffff)[:-1] output_b = hex((int(abcd_list[1], 16) + int(bb, 16)) &amp; 0xffffffff)[:-1] output_c = hex((int(abcd_list[2], 16) + int(cc, 16)) &amp; 0xffffffff)[:-1] output_d = hex((int(abcd_list[3], 16) + int(dd, 16)) &amp; 0xffffffff)[:-1] # 将输出放到列表中，作为下一次128位种子 abcd_list = [output_a, output_b, output_c, output_d] # 将全局变量Ti_count恢复，一遍开始下一个分组的操作。 Ti_count = 1 # 最后调用函数，格式化输出 print 'md5&gt;&gt;&gt;' + show_result(abcd_list) 1、test1输入为test1，输出为：5a105e8b9d40e1329780d62ea2265d8a 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071['0x74', '0x65', '0x73', '0x74', '0x31', '0x80', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x28', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00']--------------------------------------------------------['0x10325476', '0xded2a12e', '0xefcdab89', '0x98badcfe']['0x98badcfe', '0x176ffdac', '0xded2a12e', '0xefcdab89']['0xefcdab89', '0xf97d74e7', '0x176ffdac', '0xded2a12e']['0xded2a12e', '0x26fd3c3', '0xf97d74e7', '0x176ffdac']['0x176ffdac', '0xe086ba37', '0x26fd3c3', '0xf97d74e7']['0xf97d74e7', '0x5a3051be', '0xe086ba37', '0x26fd3c3']['0x26fd3c3', '0xf51415b8', '0x5a3051be', '0xe086ba37']['0xe086ba37', '0x15e82801', '0xf51415b8', '0x5a3051be']['0x5a3051be', '0xa1ba8ed5', '0x15e82801', '0xf51415b8']['0xf51415b8', '0xb7e3f287', '0xa1ba8ed5', '0x15e82801']['0x15e82801', '0xafc12002', '0xb7e3f287', '0xa1ba8ed5']['0xa1ba8ed5', '0x5552f02d', '0xafc12002', '0xb7e3f287']['0xb7e3f287', '0xeb342d07', '0x5552f02d', '0xafc12002']['0xafc12002', '0xc3762cbb', '0xeb342d07', '0x5552f02d']['0x5552f02d', '0x82f48799', '0xc3762cbb', '0xeb342d07']['0xeb342d07', '0xbe572662', '0x82f48799', '0xc3762cbb']--------------------------------------------------------['0xc3762cbb', '0x43865dee', '0xbe572662', '0x82f48799']['0x82f48799', '0xbf922972', '0x43865dee', '0xbe572662']['0xbe572662', '0x168853ab', '0xbf922972', '0x43865dee']['0x43865dee', '0x6a3604c7', '0x168853ab', '0xbf922972']['0xbf922972', '0xe42e278f', '0x6a3604c7', '0x168853ab']['0x168853ab', '0xcb94feb', '0xe42e278f', '0x6a3604c7']['0x6a3604c7', '0xa5372ec3', '0xcb94feb', '0xe42e278f']['0xe42e278f', '0x9c671ad9', '0xa5372ec3', '0xcb94feb']['0xcb94feb', '0x34b22af', '0x9c671ad9', '0xa5372ec3']['0xa5372ec3', '0x6a602c81', '0x34b22af', '0x9c671ad9']['0x9c671ad9', '0x839c95de', '0x6a602c81', '0x34b22af']['0x34b22af', '0x48e16471', '0x839c95de', '0x6a602c81']['0x6a602c81', '0x2e5986df', '0x48e16471', '0x839c95de']['0x839c95de', '0xc1c47842', '0x2e5986df', '0x48e16471']['0x48e16471', '0xe0a5ccbb', '0xc1c47842', '0x2e5986df']['0x2e5986df', '0xba1145d5', '0xe0a5ccbb', '0xc1c47842']--------------------------------------------------------['0xc1c47842', '0x565c5ab1', '0xba1145d5', '0xe0a5ccbb']['0xe0a5ccbb', '0x50716d61', '0x565c5ab1', '0xba1145d5']['0xba1145d5', '0xf05377e0', '0x50716d61', '0x565c5ab1']['0x565c5ab1', '0xd2ab23f', '0xf05377e0', '0x50716d61']['0x50716d61', '0x8f719089', '0xd2ab23f', '0xf05377e0']['0xf05377e0', '0x540490fb', '0x8f719089', '0xd2ab23f']['0xd2ab23f', '0xc9924e69', '0x540490fb', '0x8f719089']['0x8f719089', '0x2f01b747', '0xc9924e69', '0x540490fb']['0x540490fb', '0xd949498d', '0x2f01b747', '0xc9924e69']['0xc9924e69', '0x77c1b124', '0xd949498d', '0x2f01b747']['0x2f01b747', '0x469dd12e', '0x77c1b124', '0xd949498d']['0xd949498d', '0x302ba0ac', '0x469dd12e', '0x77c1b124']['0x77c1b124', '0x79894777', '0x302ba0ac', '0x469dd12e']['0x469dd12e', '0x5d993ae5', '0x79894777', '0x302ba0ac']['0x302ba0ac', '0x88fdb561', '0x5d993ae5', '0x79894777']['0x79894777', '0x8b4e9841', '0x88fdb561', '0x5d993ae5']--------------------------------------------------------['0x5d993ae5', '0xf99c7282', '0x8b4e9841', '0x88fdb561']['0x88fdb561', '0x4e11ded8', '0xf99c7282', '0x8b4e9841']['0x8b4e9841', '0x1683cb7', '0x4e11ded8', '0xf99c7282']['0xf99c7282', '0x75a2684a', '0x1683cb7', '0x4e11ded8']['0x4e11ded8', '0x552aef9e', '0x75a2684a', '0x1683cb7']['0x1683cb7', '0x45f6e93a', '0x552aef9e', '0x75a2684a']['0x75a2684a', '0xe6a1b750', '0x45f6e93a', '0x552aef9e']['0x552aef9e', '0x79967ca4', '0xe6a1b750', '0x45f6e93a']['0x45f6e93a', '0xfe24655c', '0x79967ca4', '0xe6a1b750']['0xe6a1b750', '0x2daa3c88', '0xfe24655c', '0x79967ca4']['0x79967ca4', '0x98202a41', '0x2daa3c88', '0xfe24655c']['0xfe24655c', '0x2e2fa843', '0x98202a41', '0x2daa3c88']['0x2daa3c88', '0x2418ed59', '0x2e2fa843', '0x98202a41']['0x98202a41', '0x7a2ad22c', '0x2418ed59', '0x2e2fa843']['0x2e2fa843', '0x961ba399', '0x7a2ad22c', '0x2418ed59']['0x2418ed59', '0x43139514', '0x961ba399', '0x7a2ad22c']-------------------------------------------------------- 2、test2再来看看2个分组的，输入为: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz 输出为：8c0b45ac70826fd5e9e128bb53ccee 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139['0x41', '0x42', '0x43', '0x44', '0x45', '0x46', '0x47', '0x48', '0x49', '0x4a', '0x4b', '0x4c', '0x4d', '0x4e', '0x4f', '0x50', '0x51', '0x52', '0x53', '0x54', '0x55', '0x56', '0x57', '0x58', '0x59', '0x5a', '0x61', '0x62', '0x63', '0x64', '0x65', '0x66', '0x67', '0x68', '0x69', '0x6a', '0x6b', '0x6c', '0x6d', '0x6e', '0x6f', '0x70', '0x71', '0x72', '0x73', '0x74', '0x75', '0x76', '0x77', '0x78', '0x79', '0x7a', '0x41', '0x42', '0x43', '0x44', '0x45', '0x46', '0x47', '0x48', '0x49', '0x4a', '0x4b', '0x4c', '0x4d', '0x4e', '0x4f', '0x50', '0x51', '0x52', '0x53', '0x54', '0x55', '0x56', '0x57', '0x58', '0x59', '0x5a', '0x61', '0x62', '0x63', '0x64', '0x65', '0x66', '0x67', '0x68', '0x69', '0x6a', '0x6b', '0x6c', '0x6d', '0x6e', '0x6f', '0x70', '0x71', '0x72', '0x73', '0x74', '0x75', '0x76', '0x77', '0x78', '0x79', '0x7a', '0x80', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00', '0x40', '0x03', '0x00', '0x00', '0x00', '0x00', '0x00', '0x00']--------------------------------------------------------['0x10325476', '0xc6c10796', '0xefcdab89', '0x98badcfe']['0x98badcfe', '0x99a09999', '0xc6c10796', '0xefcdab89']['0xefcdab89', '0x11067980', '0x99a09999', '0xc6c10796']['0xc6c10796', '0x27bce07a', '0x11067980', '0x99a09999']['0x99a09999', '0xf22e6c4e', '0x27bce07a', '0x11067980']['0x11067980', '0xb4ac9218', '0xf22e6c4e', '0x27bce07a']['0x27bce07a', '0xa95a2fc0', '0xb4ac9218', '0xf22e6c4e']['0xf22e6c4e', '0xa4799506', '0xa95a2fc0', '0xb4ac9218']['0xb4ac9218', '0x1eb3e7c1', '0xa4799506', '0xa95a2fc0']['0xa95a2fc0', '0xa6e70cfe', '0x1eb3e7c1', '0xa4799506']['0xa4799506', '0xca27520b', '0xa6e70cfe', '0x1eb3e7c1']['0x1eb3e7c1', '0x8a7612ec', '0xca27520b', '0xa6e70cfe']['0xa6e70cfe', '0x3cbdcd45', '0x8a7612ec', '0xca27520b']['0xca27520b', '0xc9efd874', '0x3cbdcd45', '0x8a7612ec']['0x8a7612ec', '0x17455fbf', '0xc9efd874', '0x3cbdcd45']['0x3cbdcd45', '0x89d7fc8e', '0x17455fbf', '0xc9efd874']--------------------------------------------------------['0xc9efd874', '0xe73b0bf1', '0x89d7fc8e', '0x17455fbf']['0x17455fbf', '0x325e88e9', '0xe73b0bf1', '0x89d7fc8e']['0x89d7fc8e', '0x20fd8f8e', '0x325e88e9', '0xe73b0bf1']['0xe73b0bf1', '0x411c1487', '0x20fd8f8e', '0x325e88e9']['0x325e88e9', '0x10eb59c9', '0x411c1487', '0x20fd8f8e']['0x20fd8f8e', '0xb39c39a', '0x10eb59c9', '0x411c1487']['0x411c1487', '0x8dc25993', '0xb39c39a', '0x10eb59c9']['0x10eb59c9', '0x70faeaf6', '0x8dc25993', '0xb39c39a']['0xb39c39a', '0x37a8c09a', '0x70faeaf6', '0x8dc25993']['0x8dc25993', '0x199217b2', '0x37a8c09a', '0x70faeaf6']['0x70faeaf6', '0x479a9250', '0x199217b2', '0x37a8c09a']['0x37a8c09a', '0x3f3d97df', '0x479a9250', '0x199217b2']['0x199217b2', '0xdc4e0e2f', '0x3f3d97df', '0x479a9250']['0x479a9250', '0xd46913ec', '0xdc4e0e2f', '0x3f3d97df']['0x3f3d97df', '0x59c74e62', '0xd46913ec', '0xdc4e0e2f']['0xdc4e0e2f', '0x25f142e9', '0x59c74e62', '0xd46913ec']--------------------------------------------------------['0xd46913ec', '0xf5dd15c6', '0x25f142e9', '0x59c74e62']['0x59c74e62', '0x723e2047', '0xf5dd15c6', '0x25f142e9']['0x25f142e9', '0xd9e0033', '0x723e2047', '0xf5dd15c6']['0xf5dd15c6', '0x84194dae', '0xd9e0033', '0x723e2047']['0x723e2047', '0x6de4904b', '0x84194dae', '0xd9e0033']['0xd9e0033', '0xee55001', '0x6de4904b', '0x84194dae']['0x84194dae', '0x4cbfa1d8', '0xee55001', '0x6de4904b']['0x6de4904b', '0x5cb22646', '0x4cbfa1d8', '0xee55001']['0xee55001', '0xf774b565', '0x5cb22646', '0x4cbfa1d8']['0x4cbfa1d8', '0xede6e8f', '0xf774b565', '0x5cb22646']['0x5cb22646', '0x2d3485a6', '0xede6e8f', '0xf774b565']['0xf774b565', '0x2580a2a3', '0x2d3485a6', '0xede6e8f']['0xede6e8f', '0x87945bd7', '0x2580a2a3', '0x2d3485a6']['0x2d3485a6', '0x27824bd1', '0x87945bd7', '0x2580a2a3']['0x2580a2a3', '0x270e6a89', '0x27824bd1', '0x87945bd7']['0x87945bd7', '0x176d32e7', '0x270e6a89', '0x27824bd1']--------------------------------------------------------['0x27824bd1', '0x34946395', '0x176d32e7', '0x270e6a89']['0x270e6a89', '0xe267d287', '0x34946395', '0x176d32e7']['0x176d32e7', '0xaaa7cf2d', '0xe267d287', '0x34946395']['0x34946395', '0x96568b33', '0xaaa7cf2d', '0xe267d287']['0xe267d287', '0xefc1485', '0x96568b33', '0xaaa7cf2d']['0xaaa7cf2d', '0xc9b13eb2', '0xefc1485', '0x96568b33']['0x96568b33', '0x18fb40d9', '0xc9b13eb2', '0xefc1485']['0xefc1485', '0xab4dce79', '0x18fb40d9', '0xc9b13eb2']['0xc9b13eb2', '0xdbf0865d', '0xab4dce79', '0x18fb40d9']['0x18fb40d9', '0x67740c00', '0xdbf0865d', '0xab4dce79']['0xab4dce79', '0xb484f132', '0x67740c00', '0xdbf0865d']['0xdbf0865d', '0xb62723d5', '0xb484f132', '0x67740c00']['0x67740c00', '0x26bda321', '0xb62723d5', '0xb484f132']['0xb484f132', '0x1ab924f4', '0x26bda321', '0xb62723d5']['0xb62723d5', '0x51c3f96a', '0x1ab924f4', '0x26bda321']['0x26bda321', '0xed3e6c31', '0x51c3f96a', '0x1ab924f4']--------------------------------------------------------md5&gt;&gt;&gt;22c6028eba170cdd68d67eea6a79eb2a['0x2aeb796a', '0x3327bf8a', '0xdd0c17ba', '0xea7ed668']['0xea7ed668', '0x60d773a0', '0x3327bf8a', '0xdd0c17ba']['0xdd0c17ba', '0xb3bbbab', '0x60d773a0', '0x3327bf8a']['0x3327bf8a', '0x33880c49', '0xb3bbbab', '0x60d773a0']['0x60d773a0', '0x67dfaf32', '0x33880c49', '0xb3bbbab']['0xb3bbbab', '0x73cb5319', '0x67dfaf32', '0x33880c49']['0x33880c49', '0x6ebe5e61', '0x73cb5319', '0x67dfaf32']['0x67dfaf32', '0xa1c02162', '0x6ebe5e61', '0x73cb5319']['0x73cb5319', '0xd2479cbf', '0xa1c02162', '0x6ebe5e61']['0x6ebe5e61', '0xf2a1af27', '0xd2479cbf', '0xa1c02162']['0xa1c02162', '0x80943325', '0xf2a1af27', '0xd2479cbf']['0xd2479cbf', '0xb893ab4f', '0x80943325', '0xf2a1af27']['0xf2a1af27', '0xfc7e2e4f', '0xb893ab4f', '0x80943325']['0x80943325', '0xc240c8db', '0xfc7e2e4f', '0xb893ab4f']['0xb893ab4f', '0xcc5089c', '0xc240c8db', '0xfc7e2e4f']['0xfc7e2e4f', '0x9fc1b914', '0xcc5089c', '0xc240c8db']--------------------------------------------------------['0xc240c8db', '0x56677bee', '0x9fc1b914', '0xcc5089c']['0xcc5089c', '0xbfaba0fe', '0x56677bee', '0x9fc1b914']['0x9fc1b914', '0x912665b0', '0xbfaba0fe', '0x56677bee']['0x56677bee', '0x9cdf9d1b', '0x912665b0', '0xbfaba0fe']['0xbfaba0fe', '0xed6d6a1', '0x9cdf9d1b', '0x912665b0']['0x912665b0', '0xadfbd03e', '0xed6d6a1', '0x9cdf9d1b']['0x9cdf9d1b', '0xb5b6ce67', '0xadfbd03e', '0xed6d6a1']['0xed6d6a1', '0xee0fdbf3', '0xb5b6ce67', '0xadfbd03e']['0xadfbd03e', '0xd64f4a1f', '0xee0fdbf3', '0xb5b6ce67']['0xb5b6ce67', '0x5abd20bd', '0xd64f4a1f', '0xee0fdbf3']['0xee0fdbf3', '0xe87e3a8b', '0x5abd20bd', '0xd64f4a1f']['0xd64f4a1f', '0xe8656863', '0xe87e3a8b', '0x5abd20bd']['0x5abd20bd', '0xfbb31150', '0xe8656863', '0xe87e3a8b']['0xe87e3a8b', '0x6a89e680', '0xfbb31150', '0xe8656863']['0xe8656863', '0xf242b5fc', '0x6a89e680', '0xfbb31150']['0xfbb31150', '0xbe192fa6', '0xf242b5fc', '0x6a89e680']--------------------------------------------------------['0x6a89e680', '0x8cac2cde', '0xbe192fa6', '0xf242b5fc']['0xf242b5fc', '0xd4ebee29', '0x8cac2cde', '0xbe192fa6']['0xbe192fa6', '0xd95b3468', '0xd4ebee29', '0x8cac2cde']['0x8cac2cde', '0xa1f9c218', '0xd95b3468', '0xd4ebee29']['0xd4ebee29', '0xc271dedb', '0xa1f9c218', '0xd95b3468']['0xd95b3468', '0xdcc8e0eb', '0xc271dedb', '0xa1f9c218']['0xa1f9c218', '0xc927e2b3', '0xdcc8e0eb', '0xc271dedb']['0xc271dedb', '0x8ec40ee0', '0xc927e2b3', '0xdcc8e0eb']['0xdcc8e0eb', '0xf24ab478', '0x8ec40ee0', '0xc927e2b3']['0xc927e2b3', '0x7c5a2e3', '0xf24ab478', '0x8ec40ee0']['0x8ec40ee0', '0x8dd21ea6', '0x7c5a2e3', '0xf24ab478']['0xf24ab478', '0xd48f29f6', '0x8dd21ea6', '0x7c5a2e3']['0x7c5a2e3', '0x27a857b0', '0xd48f29f6', '0x8dd21ea6']['0x8dd21ea6', '0xdc959b1c', '0x27a857b0', '0xd48f29f6']['0xd48f29f6', '0x5d8e7843', '0xdc959b1c', '0x27a857b0']['0x27a857b0', '0x2d5a9b88', '0x5d8e7843', '0xdc959b1c']--------------------------------------------------------['0xdc959b1c', '0xf2ae95ff', '0x2d5a9b88', '0x5d8e7843']['0x5d8e7843', '0x4f0cfbc6', '0xf2ae95ff', '0x2d5a9b88']['0x2d5a9b88', '0x53a616d9', '0x4f0cfbc6', '0xf2ae95ff']['0xf2ae95ff', '0x7c9ac13e', '0x53a616d9', '0x4f0cfbc6']['0x4f0cfbc6', '0x568bab3f', '0x7c9ac13e', '0x53a616d9']['0x53a616d9', '0x47be7649', '0x568bab3f', '0x7c9ac13e']['0x7c9ac13e', '0xb8a4e8ce', '0x47be7649', '0x568bab3f']['0x568bab3f', '0x358f806d', '0xb8a4e8ce', '0x47be7649']['0x47be7649', '0xbacf4cfd', '0x358f806d', '0xb8a4e8ce']['0xb8a4e8ce', '0xabc2313d', '0xbacf4cfd', '0x358f806d']['0x358f806d', '0x1189bee5', '0xabc2313d', '0xbacf4cfd']['0xbacf4cfd', '0x2e9a0149', '0x1189bee5', '0xabc2313d']['0xabc2313d', '0x1e42456a', '0x2e9a0149', '0x1189bee5']['0x1189bee5', '0xc3e0da51', '0x1e42456a', '0x2e9a0149']['0x2e9a0149', '0x15aa0b81', '0xc3e0da51', '0x1e42456a']['0x1e42456a', '0xf8636ab6', '0x15aa0b81', '0xc3e0da51']-------------------------------------------------------- 四、结论MD5作为一种检验手段被广泛应用，特别在用户密码保存方面，因其不可逆和低碰撞的特性更是大受欢迎。安卓逆向中很多时候都会用到MD5，所以了解MD5对于逆向工程师来说是非常有必要的。","link":"/20220126/%E5%AF%86%E7%A0%81%E5%AD%A6-MD5%E4%BF%A1%E6%81%AF%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95/"},{"title":"常见的几种DLL注入技术","text":"原文链接: https://bbs.pediy.com/thread-269910.htm 一、前言这次实验是在WIN7 X86系统上进程，使用的编译器是VS2017。 所谓的DLL注入，其实就是在其他的进程中把我们编写的DLL加载进去。如下图所示 而加载Dll的API就是LoadLibrary，它的参数是保存要加载的DLL的路径的地址。所以DLL注入的核心就是把要注入的DLL的路径写到目标进程中，然后在目标进程中调用LoadLibrary函数，并且指定参数为保存了DLL路径的地址。 要实现DLL注入，首先就要创建一个用来注入的DLL。在VS2017中要生成一个DLL项目，只需要向下图这样创建一个DLL工程就好 在生成的文件中，有个dllmain.cpp，打开以后内容如下 当DLL的状态发生变化的时候，就会调用DllMain函数。而传递的ul_reason_for_call这个参数代表了4种不同的状态变化的情况，我们就可以根据这四种不同的状态根据需要来写出相应的代码，就会让注入的DLL执行我们需要的功能 ul_reason_for_call的值 代表的状态 DLL_PROCESS_ATTACH Dll刚刚映射到进程空间中 DLL_THREAD_ATTACH 进程中有新线程创建 DLL_THREAD_DETACH 进程中有新线程销毁 DLL_PROCESS_DETACH Dll从进程空间中接触映射 不过在实现DLL注入的时候用的DLL几乎都是在Dll刚刚映射到进程空间的时候就执行相关的代码。比如像下面这样，创建一个新线程来执行代码，这里在桌面打开一个文件来并写入加载这个DLL的进程的完成路径名。由于是独占方式打开，此时如果多个线程同时打开这个文件，CreateFile就会出错，错误码就会是32，根据这个来对线程进行休眠，等其他线程使用完了，再次打开文件进行操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &lt;Windows.h&gt;#include &lt;Shlobj.h&gt;#pragma comment(lib, &quot;shell32.lib&quot;) #define FILE_NAME &quot;result.txt&quot; DWORD WINAPI ThreadProc(LPVOID lpParameter){ HANDLE hFile = NULL; CHAR szDesktopFile[MAX_PATH] = { 0 }; //保存系统桌面路径 CHAR szFullFilePath[MAX_PATH] = { 0 }; //保存完成的加载DLL文件的文件路径 DWORD dwRetLen = 0, dwFileLen = 0; BOOL bRet = TRUE; //获取桌面路径 bRet = SHGetSpecialFolderPath(NULL, szDesktopFile, CSIDL_DESKTOP, TRUE); if (bRet) { strcat(szDesktopFile, &quot;\\\\&quot;); strcat(szDesktopFile, FILE_NAME); while (TRUE) { hFile = CreateFile( szDesktopFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) //打开文件错误 { if (GetLastError() == 32) //错误码是不是其他进程正在使用这个文件,是的话等待一会在继续打开 { Sleep(200); continue; } else break; } else { GetModuleFileName(NULL, szFullFilePath, MAX_PATH); //获取加载DLL的进程的完整路径 dwFileLen = strlen(szFullFilePath); szFullFilePath[dwFileLen] = '\\r'; //由于是在WIN7运行，换行符是\\r\\n szFullFilePath[dwFileLen + 1] = '\\n'; SetFilePointer(hFile, 0, NULL, FILE_END); WriteFile(hFile, szFullFilePath, dwFileLen + 2, &amp;dwRetLen, NULL); if (hFile) CloseHandle(hFile); break; } } } return 0;} BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); if (hThread) CloseHandle(hThread); break; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;} 点击生成解决方案以后就可以在项目目录下找到相应的DLL文件，如下图。这个文件就是用来注入到其他进程的DLL。 二、代码框架由于要编写的代码中，只有注入功能不同，但是其他的辅助功能。比如，提权，获取进程PID等等是一样的，为了避免重复就先在这给出代码的框架。后面的不同注入技术只需根据需要加进去就好。注意，如果想要提权成功，需要用管理员权限运行代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;cstdio&gt;#include &lt;Windows.h&gt;#include &lt;TlHelp32.h&gt; #define PROCESS_NAME &quot;taskmgr.exe&quot; //要注入的进程名，这个是任务管理器的进程名#define DLL_NAME &quot;InjectDll.dll&quot; //要注入的DLL的名称 BOOL InjectDll(DWORD dwPid, CHAR szDllName[]); //注入DLLDWORD GetPID(PCHAR pProName); //根据进程名获取PIDVOID ShowError(PCHAR msg); //打印错误信息BOOL EnbalePrivileges(HANDLE hProcess, char *pszPrivilegesName); //提升进程权限 int main(){ CHAR szDllPath[MAX_PATH] = { 0 }; //保存要注入的DLL的路径 DWORD dwPID = 0; //保存要注入的进程的PID // 提升当前进程令牌权限 if (!EnbalePrivileges(GetCurrentProcess(), SE_DEBUG_NAME)) { printf(&quot;权限提升失败\\n&quot;); } dwPID = GetPID(PROCESS_NAME); if (dwPID == 0) { printf(&quot;没有找到要注入的进程\\n&quot;); goto exit; } GetCurrentDirectory(MAX_PATH, szDllPath); //获取程序的目录 strcat(szDllPath, &quot;\\\\&quot;); strcat(szDllPath, DLL_NAME); //与DLL名字拼接得到DLL的完整路径 printf(&quot;要注入的进程名:%s PID:%d\\n&quot;, PROCESS_NAME, dwPID); printf(&quot;要注入的DLL的完整路径%s\\n&quot;, szDllPath); if (InjectDll(dwPID, szDllPath)) { printf(&quot;Dll注入成功\\n&quot;); }exit: system(&quot;pause&quot;); return 0;} BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; return bRet;} DWORD GetPID(PCHAR pProName){ PROCESSENTRY32 pe32 = { 0 }; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); BOOL bRet = FALSE; DWORD dwPID = 0; if (hSnap == INVALID_HANDLE_VALUE) { printf(&quot;CreateToolhelp32Snapshot process %d\\n&quot;, GetLastError()); goto exit; } pe32.dwSize = sizeof(pe32); bRet = Process32First(hSnap, &amp;pe32); while (bRet) { if (lstrcmp(pe32.szExeFile, pProName) == 0) { dwPID = pe32.th32ProcessID; break; } bRet = Process32Next(hSnap, &amp;pe32); } CloseHandle(hSnap);exit: return dwPID;} VOID ShowError(PCHAR msg){ printf(&quot;%s Error %d\\n&quot;, msg, GetLastError());} BOOL EnbalePrivileges(HANDLE hProcess, char *pszPrivilegesName){ HANDLE hToken = NULL; LUID luidValue = { 0 }; TOKEN_PRIVILEGES tokenPrivileges = { 0 }; BOOL bRet = FALSE; DWORD dwRet = 0; // 打开进程令牌并获取具有 TOKEN_ADJUST_PRIVILEGES 权限的进程令牌句柄 if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) { ShowError(&quot;OpenProcessToken&quot;); goto exit; } // 获取本地系统的 pszPrivilegesName 特权的LUID值 if (!LookupPrivilegeValue(NULL, pszPrivilegesName, &amp;luidValue)) { ShowError(&quot;LookupPrivilegeValue&quot;); goto exit; } // 设置提升权限信息 tokenPrivileges.PrivilegeCount = 1; tokenPrivileges.Privileges[0].Luid = luidValue; tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // 提升进程令牌访问权限 if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tokenPrivileges, 0, NULL, NULL)) { ShowError(&quot;AdjustTokenPrivileges&quot;); goto exit; } else { // 根据错误码判断是否特权都设置成功 dwRet = ::GetLastError(); if (ERROR_SUCCESS == dwRet) { bRet = TRUE; goto exit; } else if (ERROR_NOT_ALL_ASSIGNED == dwRet) { ShowError(&quot;ERROR_NOT_ALL_ASSIGNED&quot;); goto exit; } }exit: return bRet;} 三、远程线程注入这种注入方式可以说是最常用的注入方式了，它的核心就是调用Windows提供的CreateRemoteThread函数。该函数可以在其他的进程空间中创建一个新的线程进行执行，该函数在文档中的定义如下 12345678HANDLE WINAPI CreateRemoteThread( __in HANDLE hProcess, __in LPSECURITY_ATTRIBUTES lpThreadAttributes, __in SIZE_T dwStackSize, __in LPTHREAD_START_ROUTINE lpStartAddress, __in LPVOID lpParameter, __in DWORD dwCreationFlags, __out LPDWORD lpThreadId); 参数 说明 hProcess 要创建线程的进程句柄 lpThreadAttributes 新线程的安全描述符 dwStackSize 堆栈起始大小，为0表示默认大小 lpStartAddress 表示要运行线程的起始地址 lpParameter 保存要传递给线程参数的地址 dwCreationFlags 控制线程创建的标志，为0表示创建后立即执行 lpThreadId 指向接收线程标识符变量的指针。为NULL表示不返回线程标识符 其中的关键三个参数分别是 hProcess用来指定在哪个进程中创建新线程 lpStartAddress用来指定将进程中的哪个地址开始作为新线程运行的起始地址 lpParameter保存的也是一个地址，这个地址中保存的就是新线程要用到的参数 那也就是说只要我们指定了一个地址给lpStartAddress，那么我们就可以在其他进程中创建一个线程来执行程序。而再看加载DLL的LoadLibrary函数在文档中的定义如下 1HMODULE WINAPI LoadLibrary(__in LPCTSTR lpFileName); 可以看到，这个函数同样也只需要一个参数，这个参数是一个地址，而这个地址中保存的是我们要加载的DLL的名称的字符串。 根据这些，不难想到，只要我们可以获取新进程中的LoadLibrary函数的地址以及包含有要加载的DLL的字符串的地址就可以通过CreateRemoteThread函数来成功开起一个线程执行LoadLibrary函数来加载我们的DLL。 那么现在的问题就是如何获得LoadLibrary函数的地址以及保存有要加载的DLL路径的字符串的地址。 对于LoadLibrary函数，由于它是在常用的系统DLL，也就是KERNEL32.dll中，所以这个DLL是可以按照它的ImageBase成功装载到每个进程的空间中。这样的话Kernel32.dll在每个进程中的起始地址是一样的，那么LoadLibrary函数的地址也就会一样。那么我们就可以在本进程中查找LoadLibrary函数的地址，并且完全可以相信，在要注入DLL的进程中LoadLibrary的地址也是这个。 至于DLL名称的字符串，我们可以通过在进程中申请一块可以将DLL完整路径写入的内存，并在这个内存中将DLL的完整路径写入，将写入到注入进程DLL完整路径的内存地址作为参数就可以实现进程的注入。 具体代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HANDLE hProcess = NULL, hRemoteThread = NULL; HMODULE hKernel32 = NULL; DWORD dwSize = 0; LPVOID pDllPathAddr = NULL; PVOID pLoadLibraryAddr = NULL; // 打开注入进程，获取进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (NULL == hProcess) { ShowError(&quot;OpenProcess&quot;); bRet = FALSE; goto exit; } // 在注入进程中申请可以容纳DLL完成路径名的内存空间 dwSize = 1 + strlen(szDllName); pDllPathAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (!pDllPathAddr) { ShowError(&quot;VirtualAllocEx&quot;); bRet = FALSE; goto exit; } // 把DLL完整路径名写入进程中 if (!WriteProcessMemory(hProcess, pDllPathAddr, szDllName, dwSize, NULL)) { ShowError(&quot;WriteProcessMemory&quot;); bRet = FALSE; goto exit; } hKernel32 = LoadLibrary(&quot;kernel32.dll&quot;); if (hKernel32 == NULL) { ShowError(&quot;LoadLibrary&quot;); bRet = FALSE; goto exit; } // 获取LoadLibraryA函数地址 pLoadLibraryAddr = GetProcAddress(hKernel32, &quot;LoadLibraryA&quot;); if (pLoadLibraryAddr == NULL) { ShowError(&quot;GetProcAddress &quot;); bRet = FALSE; goto exit; } //创建远程线程进行DLL注入 hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryAddr, pDllPathAddr, 0, NULL); if (hRemoteThread == NULL) { ShowError(&quot;CreateRemoteThread&quot;); bRet = FALSE; goto exit; } exit: if (hKernel32) FreeLibrary(hKernel32); if (hProcess) CloseHandle(hProcess); if (hRemoteThread) CloseHandle(hRemoteThread); return bRet;} 四、加强版远程线程注入上面的方法虽然可以方便的注入DLL。但是在WIN7,WIN10系统上，会由于SESSION 0隔离机制从而导致只能成功注入普通的用户进程，如果注入系统进程就会导致失败。而经过逆向分析发现，使用Kernel32.dll中的CreateRemoteThread进行注入的时候，程序会走到ntdll.dll中的ZwCreateThreadEx函数进行执行。这是一个未导出的函数，所以需要手动获取函数地址来进行调用，相比于CreateRemoteThread更加底层。这个函数在64位和32位系统中的函数声明也不相同，在32位中的声明如下 123456789101112typedef DWORD(WINAPI *pFnZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown); 而在64位中的声明如下 123456789101112typedef DWORD(WINAPI *pFnZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown); 根据逆向分析的结果，在内核6.0(WIN7, WIN10)等系统上调用CreateRemoteThread的时候，当程序走到ZwCreateThreaEx的时候它第7个参数，也就是CreateThreadFlags会被设置为1，如下图 它会导致线程创建的时候就被挂起，随后查看要运行的进程所在的会话层之后再决定是否要恢复线程的运行。所以要破解这种情况只需要将第7个参数设为0就可以，相应代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091typedef DWORD(WINAPI *pFnZwCreateThreadEx)(PHANDLE, ACCESS_MASK, LPVOID, HANDLE, LPTHREAD_START_ROUTINE, LPVOID, BOOL, DWORD, DWORD, DWORD, LPVOID); BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HANDLE hProcess = NULL, hRemoteThread = NULL; HMODULE hKernel32 = NULL, hNtDll = NULL; DWORD dwSize = 0; LPVOID pDllPathAddr = NULL; PVOID pLoadLibraryAddr = NULL; pFnZwCreateThreadEx ZwCreateThreadEx = NULL; // 打开注入进程，获取进程句柄 hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (NULL == hProcess) { ShowError(&quot;OpenProcess&quot;); bRet = FALSE; goto exit; } // 在注入进程中申请可以容纳DLL完成路径名的内存空间 dwSize = 1 + strlen(szDllName); pDllPathAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (!pDllPathAddr) { ShowError(&quot;VirtualAllocEx&quot;); bRet = FALSE; goto exit; } // 把DLL完成路径名写入进程中 if (!WriteProcessMemory(hProcess, pDllPathAddr, szDllName, dwSize, NULL)) { ShowError(&quot;WriteProcessMemory&quot;); bRet = FALSE; goto exit; } hKernel32 = LoadLibrary(&quot;kernel32.dll&quot;); if (hKernel32 == NULL) { ShowError(&quot;LoadLibrary kernel32&quot;); bRet = FALSE; goto exit; } // 获取LoadLibraryA函数地址 pLoadLibraryAddr = GetProcAddress(hKernel32, &quot;LoadLibraryA&quot;); if (pLoadLibraryAddr == NULL) { ShowError(&quot;GetProcAddress LoadLibraryA&quot;); bRet = FALSE; goto exit; } hNtDll = LoadLibrary(&quot;ntdll.dll&quot;); if (hNtDll == NULL) { ShowError(&quot;LoadLibrary ntdll&quot;); bRet = FALSE; goto exit; } ZwCreateThreadEx = (pFnZwCreateThreadEx)GetProcAddress(hNtDll, &quot;ZwCreateThreadEx&quot;); if (!ZwCreateThreadEx) { ShowError(&quot;GetProcAddress ZwCreateThreadEx&quot;); bRet = FALSE; goto exit; } ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pLoadLibraryAddr, pDllPathAddr, 0, 0, 0, 0, NULL); if (hRemoteThread == NULL) { ShowError(&quot;ZwCreateThreadEx&quot;); bRet = FALSE; goto exit; }exit: if (hKernel32) FreeLibrary(hKernel32); if (hNtDll) FreeLibrary(hNtDll); if (hProcess) CloseHandle(hProcess); if (hRemoteThread) CloseHandle(hRemoteThread); return bRet;} 五、APC注入在Windows系统中，每个线程都会维护一个自己的APC队列，这个APC队列中保存了要求线程执行的一些APC函数。对于用户模式的APC队列，当线程处在可警告状态时，就会执行这些APC函数。而要往APC队列中增加APC函数，需要通过QueueUserAPC函数来实现，这个函数在文档中的定义如下 1234DWORD WINAPI QueueUserAPC( __in PAPCFUNC pfnAPC, __in HANDLE hThread, __in ULONG_PTR dwData); 参数 说明 pfnAPC 当满足条件时，要执行的APC函数的地址 hThread 指定增加APC函数的线程句柄 dwData 要执行的APC函数参数地址 可以看到pfnAPC和dwData这两个参数和CreateRemoteThread中的lpStartAddress和lpParameter的作用是一样的。不过这里是对线程进行操作，一个进程有多个线程。所以为了确保程序正确运行，所以需要遍历所有线程，查看是否是要注入的进程的线程，依次获得句柄插入APC函数。具体代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HANDLE hProcess = NULL, hThread = NULL, hSnap = NULL; HMODULE hKernel32 = NULL; DWORD dwSize = 0; PVOID pDllPathAddr = NULL; PVOID pLoadLibraryAddr = NULL; THREADENTRY32 te32 = { 0 }; // 打开注入进程，获取进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (NULL == hProcess) { ShowError(&quot;OpenProcess&quot;); bRet = FALSE; goto exit; } // 在注入进程中申请可以容纳DLL完成路径名的内存空间 dwSize = 1 + strlen(szDllName); pDllPathAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (!pDllPathAddr) { ShowError(&quot;VirtualAllocEx&quot;); bRet = FALSE; goto exit; } // 把DLL完成路径名写入进程中 if (!WriteProcessMemory(hProcess, pDllPathAddr, szDllName, dwSize, NULL)) { ShowError(&quot;WriteProcessMemory&quot;); bRet = FALSE; goto exit; } hKernel32 = LoadLibrary(&quot;kernel32.dll&quot;); if (hKernel32 == NULL) { ShowError(&quot;LoadLibrary&quot;); bRet = FALSE; goto exit; } // 获取LoadLibraryA函数地址 pLoadLibraryAddr = GetProcAddress(hKernel32, &quot;LoadLibraryA&quot;); if (pLoadLibraryAddr == NULL) { ShowError(&quot;GetProcAddress&quot;); bRet = FALSE; goto exit; } //获得线程快照 hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (!hSnap) { ShowError(&quot;CreateToolhelp32Snapshot&quot;); bRet = FALSE; goto exit; } //遍历线程 te32.dwSize = sizeof(te32); if (Thread32First(hSnap, &amp;te32)) { do { //这个线程的进程ID是不是要注入的进程的PID if (te32.th32OwnerProcessID == dwPid) { hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); if (hThread) { QueueUserAPC((PAPCFUNC)pLoadLibraryAddr, hThread, (ULONG_PTR)pDllPathAddr); CloseHandle(hThread); hThread = NULL; } else { ShowError(&quot;OpenThread&quot;); bRet = FALSE; goto exit; } } } while (Thread32Next(hSnap, &amp;te32)); }exit: if (hKernel32) FreeLibrary(hKernel32); if (hProcess) CloseHandle(hProcess); if (hThread) CloseHandle(hThread); return bRet;} 六、AppInit_DLLs注入这种注入方式主要是通过修改注册表中HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows中的AppInit_DLLs和LoadAppInit_Dlls，如下图 只要将AppInit_DLLs设置为要注入的DLL的路径并且将LoadAppInit_DLLs的值改成1。那么，当程序重启的时候，所有加载user32.dll的进程都会根据AppInit_Dlls中的DLL路径加载指定的DLL。 所以这种DLL注入的实现代码如下 1234567891011121314151617181920212223242526272829303132333435BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HKEY hKey = NULL; CHAR szAppKeyName[] = { &quot;AppInit_DLLs&quot; }; CHAR szLoadAppKeyName[] = { &quot;LoadAppInit_DLLs&quot; }; DWORD dwLoadAppInit = 1; //设置LoadAppInit_DLLs的值 //打开相应注册表键 if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, &quot;Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows&quot;, 0, KEY_ALL_ACCESS, &amp;hKey) != ERROR_SUCCESS) { ShowError(&quot;RegOpenKeyEx&quot;); bRet = FALSE; goto exit; } //设置AppInit_DLLs为相应的DLL路径 if (RegSetValueEx(hKey, szAppKeyName, 0, REG_SZ, (PBYTE)szDllName, strlen(szDllName) + 1) != ERROR_SUCCESS) { ShowError(&quot;RegSetValueEx&quot;); bRet = FALSE; goto exit; } //将LoadAppInit_DLLs的值设为1 if (RegSetValueEx(hKey, szLoadAppKeyName, 0, REG_DWORD, (PBYTE)&amp;dwLoadAppInit, sizeof(dwLoadAppInit)) != ERROR_SUCCESS) { ShowError(&quot;RegSetValueEx&quot;); bRet = FALSE; goto exit; }exit: return bRet;} 运行程序以后，会发现相应的键值已经被设置 七、全局钩子注入Windows系统中的大多数应用都是基于消息机制的，也就是说它们都有一个消息过程函数，可以根据收到的不同消息来执行不同的代码。基于这种消息机制，Windows维护了一个OS message queue以及为每个程序维护着一个application message queue。当发生各种事件的时候，比如敲击键盘，点击鼠标等等，操作系统会从OS message queue将消息取出给到相应的程序的application message queue。 而OS message queue和application message queue的中间有一个称为钩链的结果如下 在这个钩链中保存的就是设置的各种钩子函数，而这些钩子函数会比应用程序还早接收到消息并对消息进行处理。所以程序员可以通过在钩子中设置钩子函数，而要设置钩子函数就需要使用SetWindowHookEx来将钩子函数安装到钩链中，函数在文档中的定义如下 1HHOOK SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId); 参数 含义 idHook 要安装的钩子类型，为了挂全局钩子，这里选择WH_GETMESSAGE。表示的是安装一个挂钩过程，它监视发送到消息队列的消息 lpfn 表示的是钩子的回调函数。如果dwThreadId为0，则lpfn指向的钩子过程必须指向DLL中的钩子过程 hMod 包含由lpfn参数执行的钩子过程的DLL句柄 dwThreadId 与钩子过程关联的线程标识符，如果为0则表示与所有线程相关联。 如果函数成功，则返回钩子过程的句柄，否则为NULL。 根据上面的介绍可以得知，想要创建一个全局钩子，就必须在DLL文件中创建。这是因为进程的地址空间是独立的，发生对应事件的进程不能调用其他进程地址空间的钩子函数。如果钩子函数的实现代码在DLL中，则在对应事件发生时，系统会把这个DLL加载到发生事件的进程地址空间中，使它可以调用钩子函数进行处理。 所以只要在系统中安装了全局钩子，那么只要进程接收到可以发出钩子的消息，全局钩子的DLL就会被系统自动或者强行加载到进程空间中，这就可以实现DLL注入。 而这里之所以设置为WH_GETMESSAGE，是因为这种类型的钩子会监视消息队列，又因为Windows系统是基于消息驱动的，所以所有的进程都会有自己的一个消息队列，都会加载WH_GETMESSAGE类型的全局钩子。 当idHook设置为WH_GETMESSAGE的时候，回调函数lpfn的定义如下 123LRESULT CALLBACK GetMsgProc(int code, WPARAM wParam, LPARAM lParam); 参数 含义 code 指定钩子过程是否必须处理该消息。如果代码是HC_ACTION，则钩子过程必须处理该消息。如果代码小于零，则钩子过程必须将消息传递给CallNextHookEx函数而无需进一步处理，并且应该返回CallNextHookEx返回的值 wParam 指定消息是否已从队列中删除。此参数可以是以下值之一。PM_NOREMOVE:指定消息尚未从队列中删除PM_REMOVE:指定消息已从队列中删除 lParam 指向包含消息详细信息的MSG结构体的指针 如果要卸载钩子，则需要使用UnhookWindowsHookEx，该函数定义如下 1BOOL UnhookWindowsHookEx(HHOOK hhk); 参数 含义 hhk 需要卸载的钩子句柄。此参数是通过上一次调用SetWindowsHookEx获得的钩子句柄 由于设置全局钩子的代码需要在DLL文件中完成，所以首先需要新建一个InjectDll.cpp。 随后在文件中写入如下设置全局钩子的函数 1234567891011extern HMODULE g_hDllModule;// 设置全局钩子BOOL SetGlobalHook(){ g_hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, 0); if (NULL == g_hHook) { return FALSE; } return TRUE;} 其中的回调函数的实现如下 12345678// 钩子回调函数LRESULT GetMsgProc( int code, WPARAM wParam, LPARAM lParam){ return CallNextHookEx(g_hHook, code, wParam, lParam);} 这里只是简单的调用CallNextHookEx函数表示将当前钩子传递给钩链中的下一个钩子，第一个参数要指定当前钩子的句柄。如果直接返回0，则表示中断钩子传递，这就实现了对钩子进行拦截。 而g_hDllModule则是在DLL加载的时候被赋值的 当钩子不再使用，可以卸载掉全局钩子，这样此时已经包含钩子回调函数的DLL模块的进程就会释放DLL模块。卸载钩子的代码如下 123456789// 卸载钩子BOOL UnSetGlobalHook(){ if (g_hHook) { UnhookWindowsHookEx(g_hHook); } return TRUE;} 上面的全局钩子的设置，钩子回调函数的实现以及全局钩子的卸载都需要使用到全局钩子的句柄。为了让任意一个独立的进程中对句柄的修改都可以影响到其他进程，就需要在DLL中使用共享内存的，来保证将DLL中加载到多个进程以后，一个进程对它的修改可以影响到其他进程。设置共享内存的方式如下 12345// 共享内存#pragma data_seg(&quot;mydata&quot;)HHOOK g_hHook = NULL;#pragma data_seg()#pragma comment(linker, &quot;/SECTION:mydata,RWS&quot;) 而为了调用设置钩子和卸载钩子的函数，就需要创建一个.def文件来将两个函数导出 此时使用PEID查看InjectDll.dll可以看到导出表有如下的导出函数 接下来只要在代码中将DLL引入并或者对应的函数对它们进行调用就好 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HMODULE hDll = NULL; pFnSetGlobalHook SetGlobalHook = NULL; pFnUnSetGlobalHook UnSetGlobalHook = NULL; hDll = LoadLibrary(szDllName); if (hDll == NULL) { ShowError(&quot;LoadLibrary&quot;); bRet = FALSE; goto exit; } SetGlobalHook = (pFnSetGlobalHook)GetProcAddress(hDll, &quot;SetGlobalHook&quot;); if (SetGlobalHook == NULL) { ShowError(&quot;GetProcAddress SetGlobalHook&quot;); bRet = FALSE; goto exit; } if (!SetGlobalHook()) { printf(&quot;钩子安装失败\\n&quot;); bRet = FALSE; goto exit; } printf(&quot;钩子安装成功,按回车卸载钩子\\n&quot;); system(&quot;pause&quot;); UnSetGlobalHook = (pFnUnSetGlobalHook)GetProcAddress(hDll, &quot;UnSetGlobalHook&quot;); if (UnSetGlobalHook == NULL) { ShowError(&quot;GetProcAddress UnSetGlobalHook&quot;); bRet = FALSE; goto exit; } if (UnSetGlobalHook()) { printf(&quot;已将全局钩子卸载\\n&quot;); }exit: return bRet;} 八、实验结果将编译好的exe文件和dll文件放到同一路径中，运行exe以后会在桌面生成一个result.txt文件。打开文件以后会看到里面的内容是被注入的进程的完整的路径名","link":"/20211220/%E8%BD%AC-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DDLL%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"title":"安卓逆向Hook So","text":"原文链接: https://kevinspider.github.io/fridahookso/ 1、frida-envhttps://github.com/frida/frida-java-bridge/blob/master/lib/env.js 2、IDA判断Thumb指令集和Arm指令集 IDA - Options - General - number of opcode bytes - 设置为 4 此时查看 IDA VIew 中 opcode 的长度, 如果出现 2 个字节和 4 个字节的, 说明为 thumb 指令集 如果都是 4 个字节的, 说明是 arm 指令集; 在 Thumb 指令集下, inline hook 的偏移地址需要进行 +1 操作; 3、枚举内存中的so文件用于查看目标 module 是否被正常加载, 使用 Process.enumerateModules() 将当前加载的所有 so 文件打印出来 1234567891011function hook_native(){ var modules = Process.enumerateModules(); for (var i in modules){ var module = modules[i]; console.log(module.name); if (module.name.indexOf(&quot;target.so&quot;) &gt; -1 ){ console.log(module.base); } }} 4、获取指定 so 文件的基地址1234function hook_module() { var baseAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;); console.log(&quot;baseAddr&quot;, baseAddr);} 5、获取指定 so 文件的函数通过导出函数名定位 native 方法1234function hook_func_from_exports(){ var add_c_addr = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;add_c&quot;); console.log(&quot;add_c_addr is :&quot;,add_c_addr);} 通过 symbols 符号定位 native 方法123456789101112131415161718192021222324252627282930313233343536373839404142function find_func_from_symbols() { var NewStringUTF_addr = null; var symbols = Process.findModuleByName(&quot;libart.so&quot;).enumerateSymbols(); for (var i in symbols) { var symbol = symbols[i]; if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0 ){ if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;= 0) { console.log(&quot;find target symbols&quot;, symbol.name, &quot;address is &quot;, symbol.address); NewStringUTF_addr = symbol.address; } } } console.log(&quot;NewStringUTF_addr is &quot;, NewStringUTF_addr); Interceptor.attach(NewStringUTF_addr, { onEnter: function (args) { console.log(&quot;args0&quot;,args[0]) console.log(&quot;args0&quot;, args[0], hexdump(args[0])); console.log(&quot;args1&quot;, args[1], hexdump(args[1])); var env = Java.vm.tryGetEnv(); if (env != null) { // 直接读取 c 里面的 char console.log(&quot;Memory readCstring is :&quot;, Memory.readCString(args[1])); }else{ console.log(&quot;get env error&quot;); } }, onLeave: function (returnResult) { console.log(&quot;result: &quot;, Java.cast(returnResult, Java.use(&quot;java.lang.String&quot;))); var env = Java.vm.tryGetEnv(); if (env != null) { var jstring = env.newStringUtf(&quot;修改返回值&quot;); returnResult.replace(ptr(jstring)); } } })} 通过地址偏移 inline-hook 任意函数1234567891011121314151617181920212223242526272829function main(){ // get base address of target so; var libnative_lib_addr = Module.findBaseAddress(&quot;libnative-lib.so&quot;); console.log(&quot;base module addr -&gt;&quot;, libnative_lib_addr); if (libnative_lib_addr){ var add_addr1 = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;_Z5r0addii&quot;); var add_addr2 = libnative_lib_addr.add(0x94B2 + 1); // 32位需要加1 console.log(add_addr1); console.log(add_addr2); } // 主动调用 var add1 = new NativeFunction(add_addr1, &quot;int&quot;, [&quot;int&quot;, &quot;int&quot;]); var add2 = new NativeFunction(add_addr2, &quot;int&quot;, [&quot;int&quot;, &quot;int&quot;]); console.log(&quot;add1 result is -&gt;&quot; + add1(10, 20)); console.log(&quot;add2 result is -&gt;&quot; + add2(10, 20));}setImmediate(main);/*base module addr -&gt; 0xd430b0000xd43144b30xd43144b3add1 result is -&gt;30add2 result is -&gt;30*/ 6、通过 Intercept 拦截器打印 native 方法参数和返回值, 并修改返回值 onEnter: 函数(args) : 回调函数, 给定一个参数 args, 用于读取或者写入参数作为 NativePointer 对象的指针; onLeave: 函数(retval) : 回调函数给定一个参数 retval, 该参数是包含原始返回值的 NativePointer 派生对象; 可以调用 retval.replace(1234) 以整数 1234 替换返回值, 或者调用retval.replace(ptr(&quot;0x1234&quot;)) 以替换为指针; 注意: retval 对象会在 onLeave 调用中回收, 因此不要将其存储在回调之外使用, 如果需要存储包含的值, 需要制作深拷贝, 如 ptr(retval.toString()) 12345678910111213141516171819function find_func_from_exports() { var add_c_addr = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;add_c&quot;); console.log(&quot;add_c_addr is :&quot;,add_c_addr); // 添加拦截器 Interceptor.attach(add_c_addr,{ // 打印入参 onEnter: function (args) { console.log(&quot;add_c called&quot;); console.log(&quot;arg1:&quot;,args[0].toInt32()); console.log(&quot;arg2&quot;, args[1].toInt32()); }, // 打印返回值 onLeave: function (returnValue) { console.log(&quot;add_c result is :&quot;, returnValue.toInt32()); // 修改返回值 returnValue.replace(100); } })} 7、通过 Intercept 拦截器替换原方法123456789101112131415161718function frida_Interceptor() { Java.perform(function () { //这个c_getSum方法有两个int参数、返回结果为两个参数相加 //这里用NativeFunction函数自己定义了一个c_getSum函数 var add_method = new NativeFunction(Module.findExportByName('libhello.so', 'c_getSum'), 'int',['int','int']); //输出结果 那结果肯定就是 3 console.log(&quot;result:&quot;,add_method(1,2)); //这里对原函数的功能进行替换实现 Interceptor.replace(add_method, new NativeCallback(function (a, b) { //h不论是什么参数都返回123 return 123; }, 'int', ['int', 'int'])); //再次调用 则返回123 console.log(&quot;result:&quot;,add_method(1,2)); });} 8、so 层方法注册到 js 中, 主动调用1new NativeFunction(address, returnType, argTypes[, options]) address : 函数地址 returnType : 指定返回类型 argTypes : 数组指定参数类型 类型可选: void, pointer, int, uint, long, ulong, char, uchar, float, double, int8, uint8, int16, int32, uint32, int64, uint64; 参照函数所需的 type 来定义即可; 12345678910function invoke_native_func() { var baseAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;); console.log(&quot;baseAddr&quot;, baseAddr); var offset = 0x0000A28C + 1; var add_c_addr = baseAddr.add(offset); var add_c_func = new NativeFunction(add_c_addr, &quot;int&quot;, [&quot;int&quot;,&quot;int&quot;]); var result = add_c_func(1, 2); console.log(result);} 1234567891011121314Java.perform(function () { // 获取 so 文件基地址 var base = Module.findBaseAddress(&quot;libnative-lib.so&quot;); // 获取目标函数偏移 var sub_834_addr = base.add(0x835) // thumb 需要 +1 // 使用 new NativeFunction 将函数注册到 js var sub_834 = new NativeFunction(sub_834_addr, 'pointer', ['pointer']); // 开辟内存, 创建入参 var arg0 = Memory.alloc(10); ptr(arg0).writeUtf8String(&quot;123&quot;); var result = sub_834(arg0); console.log(&quot;result is :&quot;, hexdump(result));}) 9、hook libart 中的 jni 方法jni 全部定在在 /system/lib(64)/libart.so 文件中, 通过枚举 symbols 筛选出指定的方法 12345678910111213141516171819202122232425262728293031323334353637function hook_libart() { var GetStringUTFChars_addr = null; // jni 系统函数都在 libart.so 中 var module_libart = Process.findModuleByName(&quot;libart.so&quot;); var symbols = module_libart.enumerateSymbols(); for (var i = 0; i &lt; symbols.length; i++) { var name = symbols[i].name; if ((name.indexOf(&quot;JNI&quot;) &gt;= 0) &amp;&amp; (name.indexOf(&quot;CheckJNI&quot;) == -1) &amp;&amp; (name.indexOf(&quot;art&quot;) &gt;= 0)) { if (name.indexOf(&quot;GetStringUTFChars&quot;) &gt;= 0) { console.log(name); // 获取到指定 jni 方法地址 GetStringUTFChars_addr = symbols[i].address; } } } Java.perform(function(){ Interceptor.attach(GetStringUTFChars_addr, { onEnter: function(args){ // console.log(&quot;args[0] is : &quot;, args[0]); // console.log(&quot;args[1] is : &quot;, args[1]); console.log(&quot;native args[1] is :&quot;,Java.vm.getEnv().getStringUtfChars(args[1],null).readCString()); console.log('GetStringUTFChars onEnter called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); // console.log(&quot;native args[1] is :&quot;, Java.cast(args[1], Java.use(&quot;java.lang.String&quot;))); // console.log(&quot;native args[1] is :&quot;, Memory.readCString(Java.vm.getEnv().getStringUtfChars(args[1],null))); }, onLeave: function(retval){ // retval const char* console.log(&quot;GetStringUTFChars onLeave : &quot;, ptr(retval).readCString()); } }) })} 10、hook libc 中的系统方法/system/lib(64)/libc.so 导出的符号没有进行 namemanline , 直接过滤筛选即可 123456789101112131415161718192021222324// hook libc.sovar pthread_create_addr = null;// console.log(JSON.stringify(Process.enumerateModules())); // Process.enumerateModules() 枚举加载的so文件var symbols = Process.findModuleByName(&quot;libc.so&quot;).enumerateSymbols();for (var i = 0; i &lt; symbols.length; i++){ if (symbols[i].name === &quot;pthread_create&quot;){ // console.log(&quot;symbols name is -&gt; &quot; + symbols[i].name); // console.log(&quot;symbols address is -&gt; &quot; + symbols[i].address); pthread_create_addr = symbols[i].address; }}Interceptor.attach(pthread_create_addr,{ onEnter: function(args){ console.log(&quot;args is -&gt;&quot; + args[0], args[1], args[2],args[3]); }, onLeave: function(retval){ console.log(retval); }});} libc.so 中方法替换 1234567891011121314151617181920212223242526272829303132333435// hook 检测frida 的方法function main() { // var exports = Process.findModuleByName(&quot;libnative-lib.so&quot;).enumerateExports(); 导出 // var imports = Process.findModuleByName(&quot;libnative-lib.so&quot;).enumerateImports(); 导入 // var symbols = Process.findModuleByName(&quot;libnative-lib.so&quot;).enumerateSymbols(); 符号 var pthread_create_addr = null; var symbols = Process.getModuleByName(&quot;libc.so&quot;).enumerateSymbols(); for (var i = 0; i &lt; symbols.length; i++) { var symbol = symbols[i]; if (symbol.name === &quot;pthread_create&quot;) { pthread_create_addr = symbol.address; console.log(&quot;pthread_create name is -&gt;&quot;, symbol.name); console.log(&quot;pthread_create address is -&gt;&quot;, pthread_create_addr); } } Java.perform(function(){ // 定义方法 之后主动调用的时候使用 var pthread_create = new NativeFunction(pthread_create_addr, 'int', ['pointer', 'pointer','pointer','pointer']) Interceptor.replace(pthread_create_addr,new NativeCallback(function (a0, a1, a2, a3) { var result = null; var detect_frida_loop = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;_Z17detect_frida_loopPv&quot;); console.log(&quot;a0,a1,a2,a3 -&gt;&quot;,a0,a1,a2,a3); if (String(a2) === String(detect_frida_loop)) { result = 0; console.log(&quot;阻止frida反调试启动&quot;); } else { result = pthread_create(a0,a1,a2,a3); console.log(&quot;正常启动&quot;); } return result; }, 'int', ['pointer', 'pointer','pointer','pointer'])); })} 11、hook native 调用栈1234567Interceptor.attach(f, { onEnter: function (args) { console.log('RegisterNatives called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); }}); 12、jnitrace1、安装jnitrace: https://github.com/chame1eon/jnitrace python : pip install jnitrace 2、基础用法ndk 开发是没有办法脱离 [libc.so](http://libc.so) 和 [libart.so](http://libart.so) 进行开发, 所以只要降维打击, 通过 trace 的方式就可以监控到 so 层 3、启动命令jnitrace [options] -l libname packagename 例如: jnitrace -l [libnative-lib.so](http://libnative-lib.so) com.example.myapplication 必要参数 -l libname : 指定要trace的.so文件, 可以同时trace多个.so文件, 直接使用 *来trace所有的.so文件; 如: -l libnative-lib.so -l libanother-lib.so or -l * packagename : 指定要trace的package name 可选参数 -m: 指定是spawn还是attach -b: 指定是fuzzy还是accurate -i &lt;regex&gt;: 指定一个正则表达式来过滤出方法名, 例如: -i Get -i RegisterNatives 就只会打印出名字里包含Get或者RegisterNatives的JNI methods -e &lt;regex&gt;和i相反，同样通过正则表达式来过滤，但这次会将指定的内容忽略掉 -I &lt;string&gt;trace导出的方法，jnitrace认为导出的函数应该是从Java端能够直接调用的函数，所以可以包括使用RegisterNatives来注册的函数，例如I stringFromJNI -I nativeMethod([B)V，就包括导出名里有stringFromJNI，以及使用RegisterNames来注册，并带有nativeMethod([B)V签名的函数。 -o path/output.json，导出输出到文件里。 -p path/to/script.js，用于在加载jnitrace脚本之前将指定路径的Frida脚本加载到目标进程中，这可以用于在jnitrace启动之前对抗反调试。 -a path/to/script.js，用于在加载jnitrace脚本之后将指定路径的Frida脚本加载到目标进程中 -ignore-env，不打印所有的JNIEnv函数 -ignore-vm，不打印所有的JavaVM函数 启动方式默认使用 spawn 启动, 可以通过 -m attach 设置通过 attach 启动 jnitrace -m attach -l[libnative-lib.so](http://libnative-lib.so) com.kevin.demoso1 设置回溯器默认情况下使用 accurate的精确模式来进行回溯, 可以通过 -b fuzzy 修改为模糊模式 jnitrace -l [libnative-lib.so](http://libnative-lib.so) -b fuzzy com.kevin.demoso1 监控指定规则的方法用于指定应该跟踪的方法名, 该选项可以多次提供; jnitrace -l libnative-lib.so -i RegisterNatives com.kevin.demoso1 只过滤出RegisterNatives相关的内容 忽略指定规则的方法用于指定在跟踪中应被忽略的方法名, 这个选项可以被多次提供; 忽略以Find开头的所有方法; jnitrace -l libnative-lib.so -e ^Find com.kevin.demoso 4、jnitace 计算偏移地址 0x8e4f3b1 是方法 initSN 方法的绝对地址 0xd8e4e000 是 [libmyjni.so](http://libmyjni.so) 基地址 使用使用 initSN()V的绝对地址 0xd8e4f3b1 减去 [libmyjni.so](http://libmyjni.so) 的基地址 0xd8e4e000 , 得到偏移 0x13B1 g 进行跳转到 0x13B1 即可进入方法 13、frida-trace文档地址: https://frida.re/docs/frida-trace/ options123456789101112131415161718192021222324252627282930Usage: frida-trace [options] target Options: --version show program's version number and exit -h, --help show this help message and exit -D ID, --device=ID connect to device with the given ID -U, --usb connect to USB device -R, --remote connect to remote frida-server -H HOST, --host=HOST connect to remote frida-server on HOST -f FILE, --file=FILE spawn FILE -F, --attach-frontmost attach to frontmost application -n NAME, --attach-name=NAME attach to NAME -p PID, --attach-pid=PID attach to PID --stdio=inherit|pipe stdio behavior when spawning (defaults to “inherit”) --runtime=duk|v8 script runtime to use (defaults to “duk”) --debug enable the Node.js compatible script debugger -I MODULE, --include-module=MODULE include MODULE -X MODULE, --exclude-module=MODULE exclude MODULE -i FUNCTION, --include=FUNCTION include FUNCTION -x FUNCTION, --exclude=FUNCTION exclude FUNCTION -a MODULE!OFFSET, --add=MODULE!OFFSET add MODULE!OFFSET -T, --include-imports include program's imports -t MODULE, --include-module-imports=MODULE include MODULE imports -m OBJC_METHOD, --include-objc-method=OBJC_METHOD include OBJC_METHOD -M OBJC_METHOD, --exclude-objc-method=OBJC_METHOD exclude OBJC_METHOD -s DEBUG_SYMBOL, --include-debug-symbol=DEBUG_SYMBOL include DEBUG_SYMBOL -q, --quiet do not format output messages -d, --decorate Add module name to generated onEnter log statement -o OUTPUT, --output=OUTPUT dump messages to file 基础使用frida-trace [options] packagename 启动模式默认使用 attach 模式, 可以指定 -f packageName 使用 spawn 模式启动 frida-trace -U -i strcmp -f com.gdufs.xman 文件输出frida-trace -U -i &quot;strcmp&quot; -f com.gdufs.xman -o xman.json -o filepath 指定输出的文件路径, 方便内容过多时进行查看 trace 任意 functionfrida-trace -U -i &quot;strcmp&quot; com.example.demoso1 trace 任意 modulefrida-trace -U -I &quot;libnative-lib.so&quot; com.example.demoso1 根据地址进行 tracefrida-trace -U -a &quot;libnative-lib.so!0x9281&quot; com.example.demoso1 批量 trace源码地址: https://github.com/Pr0214/trace_natives ps: 需要切换到 frida14 版本 1.将traceNatives.py丢进IDA plugins目录中 在ida 的python console中运行如下命令即可找到plugins目录：os.path.join(idaapi.get_user_idadir(), &quot;plugins&quot;) 2.IDA中，Edit-Plugins-traceNatives –&gt; IDA输出窗口就会显示如下字眼：使用方法如下： frida-trace -UF -O C:\\Users\\Lenovo\\Desktop\\2021\\mt\\libmtguard.txt 14、frida-hook-libart下载地址: https://github.com/lasting-yang/frida_hook_libart hook artfrida -U --no-pause -f package_name -l hook_art.js hook_RegisterNativesfrida -U --no-pause -f package_name -l hook_RegisterNatives.js hook_artmethodinit libext first time adb push lib/libext64.so /data/local/tmp/libext64.so adb push lib/libext.so /data/local/tmp/libext.so adb shell su -c &quot;cp /data/local/tmp/libext64.so /data/app/libext64.so&quot; adb shell su -c &quot;cp /data/local/tmp/libext.so /data/app/libext.so&quot; adb shell su -c &quot;chown 1000.1000 /data/app/libext*.so&quot; adb shell su -c &quot;chmod 777 /data/app/libext*.so&quot; adb shell su -c &quot;ls -al /data/app/libext*&quot; use hook_artmethod.jsfrida -U --no-pause -f package_name -l hook_artmethod.js # or frida -U --no-pause -f package_name -l hook_artmethod.js &gt; hook_artmethod.log frida-fart-hook首先拷贝fart.so和fart64.so到/data/app目录下，并使用chmod 777 设置好权限,然后就可以使用了。 如果目标 app 没有 sdcard 权限则需要手动添加; 或者可以修改 frida_fart_hook.js 中的源码, 将 savepath 改为 /data/data/应用包名/; 该frida版fart是使用hook的方式实现的函数粒度的脱壳，仅仅是对类中的所有函数进行了加载，但依然可以解决绝大多数的抽取保护 需要以spawn方式启动app，等待app进入Activity界面后，执行fart()函数即可。如app包名为com.example.test,则 frida -U -f com.example.test -l frida_fart_hook.js --no-pause ，然后等待app进入主界面,执行fart() 高级用法：如果发现某个类中的函数的CodeItem没有dump下来，可以调用dump(classname),传入要处理的类名，完成对该类下的所有函数体的dump,dump下来的函数体会追加到bin文件当中。 15、frida 文件写入(frida/hook libc)frida api 写入文件 123456function writeFile(){ var file = new File(&quot;/sdcard/reg.dat&quot;, &quot;w&quot;); file.write(&quot;content from frida&quot;); file.flush(); file.close();} frida 定义 NativeFunction 写入文件 123456789101112131415161718192021222324function writeFileNative(){ var addr_fopen = Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;); var addr_fputs = Module.findExportByName(&quot;libc.so&quot;, &quot;fputs&quot;); var addr_fclose = Module.findExportByName(&quot;libc.so&quot;, &quot;fclose&quot;); // 将 libc 的系统方法注册到 js 层 var fopen = new NativeFunction(addr_fopen, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); var fputs = new NativeFunction(addr_fputs, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); var fclose = new NativeFunction(addr_fclose, &quot;int&quot;, [&quot;pointer&quot;]); // 在 js 层主动调用 libc 的方法 // 不能直接将 js 的字符串传给 libc中的方法, 需要进行转换 var filename = Memory.allocUtf8String(&quot;/sdcard/reg.dat&quot;); var open_mode = Memory.allocUtf8String(&quot;w&quot;); var file = fopen(filename, open_mode); var buffer = Memory.allocUtf8String(&quot;content from frida&quot;); var result = fputs(buffer, file); console.log(&quot;fputs ret: &quot;, result); // 关闭文件 fclose(file); } 16、hook 读写 std::string12345678910111213141516171819function readStdString(str){ var isTiny = (str.readU8 &amp; 1) === 0; if (isTiny){ return str.add(1).readUtf8String(); } return str.add(2 * Process.pointerSize).readPointer().readUtf8String();}function writeStdString(str, content){ var isTiny = (str.readU8() &amp; 1) === 0; if (isTiny){ str.add(1).writeUtf8String(content); }else{ str.add(2 * Process.pointerSize).readPointer().writeUtf8String(content); }} 17、hook so 文件加载后马上 hook1234567891011121314151617181920212223242526272829303132333435363738394041424344//第一种方式（针对较老的系统版本）var dlopen = Module.findExportByName(null, &quot;dlopen&quot;);console.log(dlopen);if(dlopen != null){ Interceptor.attach(dlopen,{ onEnter: function(args){ var soName = args[0].readCString(); console.log(soName); if(soName.indexOf(&quot;libc.so&quot;) != -1){ this.hook = true; } }, onLeave: function(retval){ if(this.hook) { dlopentodo(); }; } });}//第二种方式（针对新系统版本） android 8.1 使用该方法var android_dlopen_ext = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);console.log(android_dlopen_ext);if(android_dlopen_ext != null){ Interceptor.attach(android_dlopen_ext,{ onEnter: function(args){ var soName = args[0].readCString(); console.log(soName); if(soName.indexOf(&quot;libc.so&quot;) != -1){ this.hook = true; } }, onLeave: function(retval){ if(this.hook) { dlopentodo(); }; } });}function dlopentodo(){ //todo ...} 18、hook libc kill1234567891011function replaceKILL(){ var kill_addr = Module.findExportByName(&quot;libc.so&quot;,&quot;kill&quot;); Interceptor.replace(kill_addr, new NativeCallback(function(arg0, arg1){ console.log(&quot;arg0=&gt; &quot;, arg0); console.log(&quot;arg1=&gt; &quot;, arg1); console.log('libc.so!kill called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); },&quot;int&quot;,[&quot;int&quot;,&quot;int&quot;]))} 19、hook init_array1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//应用以32位在64位终端环境下运行//adb install --abi armeabi-v7a &lt;path to apk&gt;function get_call_function() { var call_function_addr = null; var symbols = Process.getModuleByName(&quot;linker&quot;).enumerateSymbols(); for (var m = 0; m &lt; symbols.length; m++) { if (symbols[m].name == &quot;__dl__ZL13call_functionPKcPFviPPcS2_ES0_&quot;) { call_function_addr = symbols[m].address; console.log(&quot;found call_function_addr =&gt; &quot;, call_function_addr) hook_call_function(call_function_addr) } }}function hook_call_function(_call_function_addr){ console.log(&quot;hook call function begin!hooking address :=&gt;&quot;,_call_function_addr) Interceptor.attach(_call_function_addr,{ onEnter:function(args){ if(args[2].readCString().indexOf(&quot;base.odex&quot;)&lt;0){ console.log(&quot;============================&quot;) console.log(&quot;function_name =&gt;&quot;,args[0].readCString()) var soPath = args[2].readCString() console.log(&quot;so path : =&gt;&quot;,soPath) var soName = soPath.split(&quot;/&quot;).pop(); console.log(&quot;function offset =&gt;&quot;,&quot;0x&quot;+(args[1]-Module.findBaseAddress(soName)).toString(16)) console.log(&quot;============================&quot;) } },onLeave:function(retval){ } })}setImmediate(get_call_function)function hook_constructor() { if (Process.pointerSize == 4) { var linker = Process.findModuleByName(&quot;linker&quot;); } else { var linker = Process.findModuleByName(&quot;linker64&quot;); } var addr_call_function =null; var addr_g_ld_debug_verbosity = null; var addr_async_safe_format_log = null; if (linker) { var symbols = linker.enumerateSymbols(); for (var i = 0; i &lt; symbols.length; i++) { var name = symbols[i].name; if (name.indexOf(&quot;call_function&quot;) &gt;= 0){ addr_call_function = symbols[i].address; } else if(name.indexOf(&quot;g_ld_debug_verbosity&quot;) &gt;=0){ addr_g_ld_debug_verbosity = symbols[i].address; ptr(addr_g_ld_debug_verbosity).writeInt(2); } else if(name.indexOf(&quot;async_safe_format_log&quot;) &gt;=0 &amp;&amp; name.indexOf('va_list') &lt; 0){ addr_async_safe_format_log = symbols[i].address; } } } if(addr_async_safe_format_log){ Interceptor.attach(addr_async_safe_format_log,{ onEnter: function(args){ this.log_level = args[0]; this.tag = ptr(args[1]).readCString() this.fmt = ptr(args[2]).readCString() if(this.fmt.indexOf(&quot;c-tor&quot;) &gt;= 0 &amp;&amp; this.fmt.indexOf('Done') &lt; 0){ this.function_type = ptr(args[3]).readCString(), // func_type this.so_path = ptr(args[5]).readCString(); var strs = new Array(); //定义一数组 strs = this.so_path.split(&quot;/&quot;); //字符分割 this.so_name = strs.pop(); this.func_offset = ptr(args[4]).sub(Module.findBaseAddress(this.so_name)) console.log(&quot;func_type:&quot;, this.function_type, '\\nso_name:',this.so_name, '\\nso_path:',this.so_path, '\\nfunc_offset:',this.func_offset ); } }, onLeave: function(retval){ } }) }}function main() { hook_constructor();}setImmediate(main); 20、frida dumpdocument: https://github.com/lasting-yang/frida_dump frida dump so123456789101112131415161718192021function dump_so(so_name) { Java.perform(function () { var currentApplication = Java.use(&quot;android.app.ActivityThread&quot;).currentApplication(); var dir = currentApplication.getApplicationContext().getFilesDir().getPath(); var libso = Process.getModuleByName(so_name); console.log(&quot;[name]:&quot;, libso.name); console.log(&quot;[base]:&quot;, libso.base); console.log(&quot;[size]:&quot;, ptr(libso.size)); console.log(&quot;[path]:&quot;, libso.path); var file_path = dir + &quot;/&quot; + libso.name + &quot;_&quot; + libso.base + &quot;_&quot; + ptr(libso.size) + &quot;.so&quot;; var file_handle = new File(file_path, &quot;wb&quot;); if (file_handle &amp;&amp; file_handle != null) { Memory.protect(ptr(libso.base), libso.size, 'rwx'); var libso_buffer = ptr(libso.base).readByteArray(libso.size); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(&quot;[dump]:&quot;, file_path); } });} frida dump dex123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161function get_self_process_name() { var openPtr = Module.getExportByName('libc.so', 'open'); var open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var readPtr = Module.getExportByName(&quot;libc.so&quot;, &quot;read&quot;); var read = new NativeFunction(readPtr, &quot;int&quot;, [&quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]); var closePtr = Module.getExportByName('libc.so', 'close'); var close = new NativeFunction(closePtr, 'int', ['int']); var path = Memory.allocUtf8String(&quot;/proc/self/cmdline&quot;); var fd = open(path, 0); if (fd != -1) { var buffer = Memory.alloc(0x1000); var result = read(fd, buffer, 0x1000); close(fd); result = ptr(buffer).readCString(); return result; } return &quot;-1&quot;;}function mkdir(path) { var mkdirPtr = Module.getExportByName('libc.so', 'mkdir'); var mkdir = new NativeFunction(mkdirPtr, 'int', ['pointer', 'int']); var opendirPtr = Module.getExportByName('libc.so', 'opendir'); var opendir = new NativeFunction(opendirPtr, 'pointer', ['pointer']); var closedirPtr = Module.getExportByName('libc.so', 'closedir'); var closedir = new NativeFunction(closedirPtr, 'int', ['pointer']); var cPath = Memory.allocUtf8String(path); var dir = opendir(cPath); if (dir != 0) { closedir(dir); return 0; } mkdir(cPath, 755); chmod(path);}function chmod(path) { var chmodPtr = Module.getExportByName('libc.so', 'chmod'); var chmod = new NativeFunction(chmodPtr, 'int', ['pointer', 'int']); var cPath = Memory.allocUtf8String(path); chmod(cPath, 755);}function dump_dex() { var libart = Process.findModuleByName(&quot;libart.so&quot;); var addr_DefineClass = null; var symbols = libart.enumerateSymbols(); for (var index = 0; index &lt; symbols.length; index++) { var symbol = symbols[index]; var symbol_name = symbol.name; //这个DefineClass的函数签名是Android9的 //_ZN3art11ClassLinker11DefineClassEPNS_6ThreadEPKcmNS_6HandleINS_6mirror11ClassLoaderEEERKNS_7DexFileERKNS9_8ClassDefE if (symbol_name.indexOf(&quot;ClassLinker&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;DefineClass&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;Thread&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;DexFile&quot;) &gt;= 0) { console.log(symbol_name, symbol.address); addr_DefineClass = symbol.address; } } var dex_maps = {}; var dex_count = 1; console.log(&quot;[DefineClass:]&quot;, addr_DefineClass); if (addr_DefineClass) { Interceptor.attach(addr_DefineClass, { onEnter: function(args) { var dex_file = args[5]; //ptr(dex_file).add(Process.pointerSize) is &quot;const uint8_t* const begin_;&quot; //ptr(dex_file).add(Process.pointerSize + Process.pointerSize) is &quot;const size_t size_;&quot; var base = ptr(dex_file).add(Process.pointerSize).readPointer(); var size = ptr(dex_file).add(Process.pointerSize + Process.pointerSize).readUInt(); if (dex_maps[base] == undefined) { dex_maps[base] = size; var magic = ptr(base).readCString(); if (magic.indexOf(&quot;dex&quot;) == 0) { var process_name = get_self_process_name(); if (process_name != &quot;-1&quot;) { var dex_dir_path = &quot;/data/data/&quot; + process_name + &quot;/files/dump_dex_&quot; + process_name; mkdir(dex_dir_path); var dex_path = dex_dir_path + &quot;/class&quot; + (dex_count == 1 ? &quot;&quot; : dex_count) + &quot;.dex&quot;; console.log(&quot;[find dex]:&quot;, dex_path); var fd = new File(dex_path, &quot;wb&quot;); if (fd &amp;&amp; fd != null) { dex_count++; var dex_buffer = ptr(base).readByteArray(size); fd.write(dex_buffer); fd.flush(); fd.close(); console.log(&quot;[dump dex]:&quot;, dex_path); } } } } }, onLeave: function(retval) {} }); }}var is_hook_libart = false;function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, &quot;dlopen&quot;), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(&quot;dlopen:&quot;, path); if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) { this.can_hook_libart = true; console.log(&quot;[dlopen:]&quot;, path); } } }, onLeave: function(retval) { if (this.can_hook_libart &amp;&amp; !is_hook_libart) { dump_dex(); is_hook_libart = true; } } }) Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(&quot;android_dlopen_ext:&quot;, path); if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) { this.can_hook_libart = true; console.log(&quot;[android_dlopen_ext:]&quot;, path); } } }, onLeave: function(retval) { if (this.can_hook_libart &amp;&amp; !is_hook_libart) { dump_dex(); is_hook_libart = true; } } });}setImmediate(dump_dex); frida dump dex class123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193function get_self_process_name() { var openPtr = Module.getExportByName('libc.so', 'open'); var open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var readPtr = Module.getExportByName(&quot;libc.so&quot;, &quot;read&quot;); var read = new NativeFunction(readPtr, &quot;int&quot;, [&quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]); var closePtr = Module.getExportByName('libc.so', 'close'); var close = new NativeFunction(closePtr, 'int', ['int']); var path = Memory.allocUtf8String(&quot;/proc/self/cmdline&quot;); var fd = open(path, 0); if (fd != -1) { var buffer = Memory.alloc(0x1000); var result = read(fd, buffer, 0x1000); close(fd); result = ptr(buffer).readCString(); return result; } return &quot;-1&quot;;}function load_all_class() { if (Java.available) { Java.perform(function () { var DexFileclass = Java.use(&quot;dalvik.system.DexFile&quot;); var BaseDexClassLoaderclass = Java.use(&quot;dalvik.system.BaseDexClassLoader&quot;); var DexPathListclass = Java.use(&quot;dalvik.system.DexPathList&quot;); Java.enumerateClassLoaders({ onMatch: function (loader) { try { var basedexclassloaderobj = Java.cast(loader, BaseDexClassLoaderclass); var pathList = basedexclassloaderobj.pathList.value; var pathListobj = Java.cast(pathList, DexPathListclass) var dexElements = pathListobj.dexElements.value; for (var index in dexElements) { var element = dexElements[index]; try { var dexfile = element.dexFile.value; var dexfileobj = Java.cast(dexfile, DexFileclass); console.log(&quot;dexFile:&quot;, dexfileobj); const classNames = []; const enumeratorClassNames = dexfileobj.entries(); while (enumeratorClassNames.hasMoreElements()) { var className = enumeratorClassNames.nextElement().toString(); classNames.push(className); try { loader.loadClass(className); } catch (error) { console.log(&quot;loadClass error:&quot;, error); } } } catch (error) { console.log(&quot;dexfile error:&quot;, error); } } } catch (error) { console.log(&quot;loader error:&quot;, error); } }, onComplete: function () { } }) console.log(&quot;load_all_class end.&quot;); }); }}var dex_maps = {};function print_dex_maps() { for (var dex in dex_maps) { console.log(dex, dex_maps[dex]); }}function dump_dex() { load_all_class(); for (var base in dex_maps) { var size = dex_maps[base]; console.log(base); var magic = ptr(base).readCString(); if (magic.indexOf(&quot;dex&quot;) == 0) { var process_name = get_self_process_name(); if (process_name != &quot;-1&quot;) { var dex_path = &quot;/data/data/&quot; + process_name + &quot;/files/&quot; + base.toString(16) + &quot;_&quot; + size.toString(16) + &quot;.dex&quot;; console.log(&quot;[find dex]:&quot;, dex_path); var fd = new File(dex_path, &quot;wb&quot;); if (fd &amp;&amp; fd != null) { var dex_buffer = ptr(base).readByteArray(size); fd.write(dex_buffer); fd.flush(); fd.close(); console.log(&quot;[dump dex]:&quot;, dex_path); } } } }}function hook_dex() { var libart = Process.findModuleByName(&quot;libart.so&quot;); var addr_DefineClass = null; var symbols = libart.enumerateSymbols(); for (var index = 0; index &lt; symbols.length; index++) { var symbol = symbols[index]; var symbol_name = symbol.name; //这个DefineClass的函数签名是Android9的 //_ZN3art11ClassLinker11DefineClassEPNS_6ThreadEPKcmNS_6HandleINS_6mirror11ClassLoaderEEERKNS_7DexFileERKNS9_8ClassDefE if (symbol_name.indexOf(&quot;ClassLinker&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;DefineClass&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;Thread&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;DexFile&quot;) &gt;= 0) { console.log(symbol_name, symbol.address); addr_DefineClass = symbol.address; } } console.log(&quot;[DefineClass:]&quot;, addr_DefineClass); if (addr_DefineClass) { Interceptor.attach(addr_DefineClass, { onEnter: function (args) { var dex_file = args[5]; //ptr(dex_file).add(Process.pointerSize) is &quot;const uint8_t* const begin_;&quot; //ptr(dex_file).add(Process.pointerSize + Process.pointerSize) is &quot;const size_t size_;&quot; var base = ptr(dex_file).add(Process.pointerSize).readPointer(); var size = ptr(dex_file).add(Process.pointerSize + Process.pointerSize).readUInt(); if (dex_maps[base] == undefined) { dex_maps[base] = size; console.log(&quot;hook_dex:&quot;, base, size); } }, onLeave: function (retval) {} }); }}var is_hook_libart = false;function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, &quot;dlopen&quot;), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(&quot;dlopen:&quot;, path); if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) { this.can_hook_libart = true; console.log(&quot;[dlopen:]&quot;, path); } } }, onLeave: function (retval) { if (this.can_hook_libart &amp;&amp; !is_hook_libart) { hook_dex(); is_hook_libart = true; } } }) Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(&quot;android_dlopen_ext:&quot;, path); if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) { this.can_hook_libart = true; console.log(&quot;[android_dlopen_ext:]&quot;, path); } } }, onLeave: function (retval) { if (this.can_hook_libart &amp;&amp; !is_hook_libart) { hook_dex(); is_hook_libart = true; } } });}setImmediate(hook_dex); 21、指针运算符和读写 API hook so readPointer()1234567891011Java.perform(function () { var libc_addr = Process.findModuleByName(&quot;libc.so&quot;).base; console.log(&quot;libc address is &quot; + libc_addr); // 0x10 转为十进制为 16, 读取 console.log(libc_addr.readByteArray(0x10)); // readPointer(), 从此内存位置读取 NativePointer console.log(&quot;pointer size&quot;, Process.pointerSize); console.log(&quot;readPointer() is &quot; + libc_addr.readPointer()); console.log(&quot;Memory.readPointer()&quot; + Memory.readPointer(libc_addr.add(Process.pointerSize))); }) hook so writePointer()12345678910111213141516Java.perform(function () { var libc_addr = Process.findModuleByName(&quot;libc.so&quot;).base; console.log(&quot;libc_addr : &quot; + libc_addr); // 分配四个字节的空间地址 const r = Memory.alloc(4); // 将 libc_addr 指针写入刚申请的 r 中 r.writePointer(libc_addr); // 读取 r 指针的数据 var buffer = Memory.readByteArray(r, 4); console.log(buffer); })//libc_addr : 0x7da7fdf000 // 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF// 00000000 00 f0 fd a7 .... hook so readS32(), readU32()从指定内存地址读取有符号或者无符号 8/16/21/etc 或浮点数/双精度值, 并将其作为数字返回; 1234567Java.perform(function () { var libc_addr = Process.findModuleByName(&quot;libc.so&quot;).base; console.log(hexdump(libc_addr)); console.log(libc_addr.readS32(), (libc_addr.readS32()).toString(16)); console.log(libc_addr.readU32(), (libc_addr.readU32()).toString(16)); }) hook so writeS32(), writeU32()将有符号或无符号8/16/32/等或浮点数/双精度值写入此内存位置 1234567891011Java.perform(function () { // 开辟四个字节的内存空间 const r = Memory.alloc(4); r.writeS32(0x12345678); console.log(r.readByteArray(0x10)); })&lt;!-- 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 78 56 34 12 7d 00 00 00 98 c0 bb a8 7d 00 00 00 xV4.}.......}... --&gt; hook so readByteArray(), writeByteArray()12345678910111213Java.perform(function () { // 定义一个需要写入的字节数组 var arr = [ 0x72, 0x6F, 0x79, 0x73, 0x75, 0x65]; //这里申请以arr大小的内存空间 var r = Memory.alloc(arr.length); // 将 arr 写入 r 中 r.writeByteArray(arr); // Memory.writeByteArray(r, arr); 同样可以写入 console.log(&quot;memory readbyteArray: &quot;) console.log(r.readByteArray(arr.length)); console.log(Memory.readByteArray(r, arr.length)); }) hook so readCString(), writeUtf8String()123456789101112Java.perform(function () { // 开辟内存空间 存有字符串 var r = Memory.allocUtf8String(&quot;你好,世界&quot;); // 读取内存中的字符串 console.log(hexdump(r)); console.log(r.readCString()); // 往内存中写入新的字符串 r.writeUtf8String(&quot;Hello,World&quot;); console.log(hexdump(r)); console.log(r.readCString()) }) 22、hook 获取 jni array123456// 获取 jbytesArray 的指针var arg1Ptr = Java.vm.getEnv().getByteArrayElements(this.arg1, null) // 获取到指针后可以直接 hexdump 打印console.log(&quot;arg1Ptr&quot;,hexdump(arg1Ptr));// 如果是字符串可以直接转console.log(&quot;arg1Ptr&quot;,arg1Ptr.readCString()); 23、jni_helper 进入目录 ~/androidFxxk/idaTools/jni_helper java -jar JadxFindJNI/JadxFindJNI.jar &lt;apk.path&gt; &lt;output.json&gt; ida 中Script File运行 jni_help脚本, 路径 ~/androidFxxk/idaTools/jni_helper/ida/jni_helper.py 导入刚才生成的 output.json 文件即可自动识别","link":"/20211227/Frida-Hook-So/"},{"title":"JNI规范文档","text":"JNI规范文档12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094#ifndef JNI_H_#define JNI_H_#include &lt;sys/cdefs.h&gt;#include &lt;stdarg.h&gt;#ifdef HAVE_INTTYPES_H# include &lt;inttypes.h&gt; /* C99 */ //这个是JNI规范中定义的基本数据类型 //typedef 关键字，可以使用它来为类型取一个新的名字。 //举个例子：typedef unsigned char BYTE;在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 */#elsetypedef unsigned char jboolean; /* unsigned 8 bits */typedef signed char jbyte; /* signed 8 bits */typedef unsigned short jchar; /* unsigned 16 bits */typedef short jshort; /* signed 16 bits */typedef int jint; /* signed 32 bits */typedef long long jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 */#endif/* &quot;cardinal indices and sizes&quot; */typedef jint jsize; //表示返回数组的大小#ifdef __cplusplus/* * Reference types, in C++ //与C++有关的定义 */class _jobject {};class _jclass : public _jobject {};class _jstring : public _jobject {};class _jarray : public _jobject {};class _jobjectArray : public _jarray {};class _jbooleanArray : public _jarray {};class _jbyteArray : public _jarray {};class _jcharArray : public _jarray {};class _jshortArray : public _jarray {};class _jintArray : public _jarray {};class _jlongArray : public _jarray {};class _jfloatArray : public _jarray {};class _jdoubleArray : public _jarray {};class _jthrowable : public _jobject {}; //为C++的一些类型进行重新定义typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak;#else /* not __cplusplus *//* * Reference types, in C. //与C有关的，继续为类型起新的名字；有arrary表示按JNI 标准定义的数组类型 */ typedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak;#endif /* not __cplusplus */ //两个方法ID和字段IDstruct _jfieldID; /* opaque structure */typedef struct _jfieldID* jfieldID; /* field IDs */struct _jmethodID; /* opaque structure */typedef struct _jmethodID* jmethodID; /* method IDs */ //定义一个结构体JNIInvokeInterface，是一个调用接口的结构体struct JNIInvokeInterface; //定义一个联合体jvalue，里面有各种类型typedef union jvalue { jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l;} jvalue; //定义一个枚举jobjectRefType，里面有各种枚举元素typedef enum jobjectRefType { JNIInvalidRefType = 0, JNILocalRefType = 1, JNIGlobalRefType = 2, JNIWeakGlobalRefType = 3} jobjectRefType; //定义一个动态注册JNINativeMethod结构体，这个与动态注册有关，里面有三个元素typedef struct { const char* name; //第一个参数 name 是java 方法名； const char* signature; //第二个参数 signature 用于描述方法的参数与返回值，也就是java方法签名信息， void* fnPtr; //第三个参数 fnPtr 是函数指针，指向 jni 函数；} JNINativeMethod; // 其中，第二个参数 signature 使用字符串记录方法的参数与返回值，具体格式形如“()V”、“(II)V”，其中分为两部分，括号内表示的是参数，括号右侧表示的是返回值；struct _JNIEnv;struct _JavaVM; //定义一个JNINativeInterface结构体，表示原生调用接口的结构体typedef const struct JNINativeInterface* C_JNIEnv;#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#else //这里有两个接口，一个是本地接口，一个是调用接口typedef const struct JNINativeInterface* JNIEnv;//JNI本地接口typedef const struct JNIInvokeInterface* JavaVM;//JNI调用接口#endif //本地接口结构体的定义struct JNINativeInterface { void* reserved0; void* reserved1; void* reserved2; void* reserved3; jint (*GetVersion)(JNIEnv *); //jint返回的是版本信息 //jclass，返回的是类 jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*,jsize); jclass (*FindClass)(JNIEnv*, const char*); jmethodID (*FromReflectedMethod)(JNIEnv*, jobject); jfieldID (*FromReflectedField)(JNIEnv*, jobject); jobject (*ToReflectedMethod)(JNIEnv*, jclass, jmethodID, jboolean); jclass (*GetSuperclass)(JNIEnv*, jclass); jboolean (*IsAssignableFrom)(JNIEnv*, jclass, jclass); jobject (*ToReflectedField)(JNIEnv*, jclass, jfieldID, jboolean); //与异常有关的方法 jint (*Throw)(JNIEnv*, jthrowable); jint (*ThrowNew)(JNIEnv *, jclass, const char *); jthrowable (*ExceptionOccurred)(JNIEnv*); void (*ExceptionDescribe)(JNIEnv*); void (*ExceptionClear)(JNIEnv*); void (*FatalError)(JNIEnv*, const char*); jint (*PushLocalFrame)(JNIEnv*, jint); jobject (*PopLocalFrame)(JNIEnv*, jobject); jobject (*NewGlobalRef)(JNIEnv*, jobject); void (*DeleteGlobalRef)(JNIEnv*, jobject); void (*DeleteLocalRef)(JNIEnv*, jobject); jboolean (*IsSameObject)(JNIEnv*, jobject, jobject); jobject (*NewLocalRef)(JNIEnv*, jobject); jint (*EnsureLocalCapacity)(JNIEnv*, jint); //新建object jobject (*AllocObject)(JNIEnv*, jclass); jobject (*NewObject)(JNIEnv*, jclass, jmethodID, ...); jobject (*NewObjectV)(JNIEnv*, jclass, jmethodID, va_list); jobject (*NewObjectA)(JNIEnv*, jclass, jmethodID, jvalue*); jclass (*GetObjectClass)(JNIEnv*, jobject); jboolean (*IsInstanceOf)(JNIEnv*, jobject, jclass); jmethodID (*GetMethodID)(JNIEnv*, jclass, const char*, const char*); //调用方法 jobject (*CallObjectMethod)(JNIEnv*, jobject, jmethodID, ...); jobject (*CallObjectMethodV)(JNIEnv*, jobject, jmethodID, va_list); jobject (*CallObjectMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jboolean (*CallBooleanMethod)(JNIEnv*, jobject, jmethodID, ...); jboolean (*CallBooleanMethodV)(JNIEnv*, jobject, jmethodID, va_list); jboolean (*CallBooleanMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jbyte (*CallByteMethod)(JNIEnv*, jobject, jmethodID, ...); jbyte (*CallByteMethodV)(JNIEnv*, jobject, jmethodID, va_list); jbyte (*CallByteMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jchar (*CallCharMethod)(JNIEnv*, jobject, jmethodID, ...); jchar (*CallCharMethodV)(JNIEnv*, jobject, jmethodID, va_list); jchar (*CallCharMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jshort (*CallShortMethod)(JNIEnv*, jobject, jmethodID, ...); jshort (*CallShortMethodV)(JNIEnv*, jobject, jmethodID, va_list); jshort (*CallShortMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jint (*CallIntMethod)(JNIEnv*, jobject, jmethodID, ...); jint (*CallIntMethodV)(JNIEnv*, jobject, jmethodID, va_list); jint (*CallIntMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jlong (*CallLongMethod)(JNIEnv*, jobject, jmethodID, ...); jlong (*CallLongMethodV)(JNIEnv*, jobject, jmethodID, va_list); jlong (*CallLongMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jfloat (*CallFloatMethod)(JNIEnv*, jobject, jmethodID, ...) __NDK_FPABI__; jfloat (*CallFloatMethodV)(JNIEnv*, jobject, jmethodID, va_list) __NDK_FPABI__; jfloat (*CallFloatMethodA)(JNIEnv*, jobject, jmethodID, jvalue*) __NDK_FPABI__; jdouble (*CallDoubleMethod)(JNIEnv*, jobject, jmethodID, ...) __NDK_FPABI__; jdouble (*CallDoubleMethodV)(JNIEnv*, jobject, jmethodID, va_list) __NDK_FPABI__; jdouble (*CallDoubleMethodA)(JNIEnv*, jobject, jmethodID, jvalue*) __NDK_FPABI__; void (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...); void (*CallVoidMethodV)(JNIEnv*, jobject, jmethodID, va_list); void (*CallVoidMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jobject (*CallNonvirtualObjectMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jobject (*CallNonvirtualObjectMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jobject (*CallNonvirtualObjectMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jboolean (*CallNonvirtualBooleanMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jbyte (*CallNonvirtualByteMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jbyte (*CallNonvirtualByteMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jbyte (*CallNonvirtualByteMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jchar (*CallNonvirtualCharMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jchar (*CallNonvirtualCharMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jchar (*CallNonvirtualCharMethodA)(JNIEnv*, jobject, jclass, jmethodID, jvalue*); jshort (*CallNonvirtualShortMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jshort (*CallNonvirtualShortMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jshort (*CallNonvirtualShortMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jint (*CallNonvirtualIntMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jint (*CallNonvirtualIntMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jint (*CallNonvirtualIntMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jlong (*CallNonvirtualLongMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jlong (*CallNonvirtualLongMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jlong (*CallNonvirtualLongMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jfloat (*CallNonvirtualFloatMethod)(JNIEnv*, jobject, jclass,jmethodID, ...) __NDK_FPABI__; jfloat (*CallNonvirtualFloatMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list) __NDK_FPABI__; jfloat (*CallNonvirtualFloatMethodA)(JNIEnv*, jobject, jclass, jmethodID, jvalue*) __NDK_FPABI__; jdouble (*CallNonvirtualDoubleMethod)(JNIEnv*, jobject, jclass,jmethodID, ...) __NDK_FPABI__; jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list) __NDK_FPABI__; jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*) __NDK_FPABI__; void (*CallNonvirtualVoidMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); void (*CallNonvirtualVoidMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); void (*CallNonvirtualVoidMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); //获取各种字段 jfieldID (*GetFieldID)(JNIEnv*, jclass, const char*, const char*); jobject (*GetObjectField)(JNIEnv*, jobject, jfieldID); jboolean (*GetBooleanField)(JNIEnv*, jobject, jfieldID); jbyte (*GetByteField)(JNIEnv*, jobject, jfieldID); jchar (*GetCharField)(JNIEnv*, jobject, jfieldID); jshort (*GetShortField)(JNIEnv*, jobject, jfieldID); jint (*GetIntField)(JNIEnv*, jobject, jfieldID); jlong (*GetLongField)(JNIEnv*, jobject, jfieldID); jfloat (*GetFloatField)(JNIEnv*, jobject, jfieldID) __NDK_FPABI__; jdouble (*GetDoubleField)(JNIEnv*, jobject, jfieldID) __NDK_FPABI__; //设置各种字段，返回为空 void (*SetObjectField)(JNIEnv*, jobject, jfieldID, jobject); void (*SetBooleanField)(JNIEnv*, jobject, jfieldID, jboolean); void (*SetByteField)(JNIEnv*, jobject, jfieldID, jbyte); void (*SetCharField)(JNIEnv*, jobject, jfieldID, jchar); void (*SetShortField)(JNIEnv*, jobject, jfieldID, jshort); void (*SetIntField)(JNIEnv*, jobject, jfieldID, jint); void (*SetLongField)(JNIEnv*, jobject, jfieldID, jlong); void (*SetFloatField)(JNIEnv*, jobject, jfieldID, jfloat) __NDK_FPABI__; void (*SetDoubleField)(JNIEnv*, jobject, jfieldID, jdouble) __NDK_FPABI__; jmethodID (*GetStaticMethodID)(JNIEnv*, jclass, const char*, const char*); jobject (*CallStaticObjectMethod)(JNIEnv*, jclass, jmethodID, ...); jobject (*CallStaticObjectMethodV)(JNIEnv*, jclass, jmethodID, va_list); jobject (*CallStaticObjectMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jboolean (*CallStaticBooleanMethod)(JNIEnv*, jclass, jmethodID, ...); jboolean (*CallStaticBooleanMethodV)(JNIEnv*, jclass, jmethodID,va_list); jboolean (*CallStaticBooleanMethodA)(JNIEnv*, jclass, jmethodID,jvalue*); jbyte (*CallStaticByteMethod)(JNIEnv*, jclass, jmethodID, ...); jbyte (*CallStaticByteMethodV)(JNIEnv*, jclass, jmethodID, va_list); jbyte (*CallStaticByteMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jchar (*CallStaticCharMethod)(JNIEnv*, jclass, jmethodID, ...); jchar (*CallStaticCharMethodV)(JNIEnv*, jclass, jmethodID, va_list); jchar (*CallStaticCharMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jshort (*CallStaticShortMethod)(JNIEnv*, jclass, jmethodID, ...); jshort (*CallStaticShortMethodV)(JNIEnv*, jclass, jmethodID, va_list); jshort (*CallStaticShortMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jint (*CallStaticIntMethod)(JNIEnv*, jclass, jmethodID, ...); jint (*CallStaticIntMethodV)(JNIEnv*, jclass, jmethodID, va_list); jint (*CallStaticIntMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jlong (*CallStaticLongMethod)(JNIEnv*, jclass, jmethodID, ...); jlong (*CallStaticLongMethodV)(JNIEnv*, jclass, jmethodID, va_list); jlong (*CallStaticLongMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jfloat (*CallStaticFloatMethod)(JNIEnv*, jclass, jmethodID, ...) __NDK_FPABI__; jfloat (*CallStaticFloatMethodV)(JNIEnv*, jclass, jmethodID, va_list) __NDK_FPABI__; jfloat (*CallStaticFloatMethodA)(JNIEnv*, jclass, jmethodID, jvalue*) __NDK_FPABI__; jdouble (*CallStaticDoubleMethod)(JNIEnv*, jclass, jmethodID, ...) __NDK_FPABI__; jdouble (*CallStaticDoubleMethodV)(JNIEnv*, jclass, jmethodID, va_list) __NDK_FPABI__; jdouble (*CallStaticDoubleMethodA)(JNIEnv*, jclass, jmethodID, jvalue*) __NDK_FPABI__; void (*CallStaticVoidMethod)(JNIEnv*, jclass, jmethodID, ...); void (*CallStaticVoidMethodV)(JNIEnv*, jclass, jmethodID, va_list); void (*CallStaticVoidMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jfieldID (*GetStaticFieldID)(JNIEnv*, jclass, const char*,const char*); jobject (*GetStaticObjectField)(JNIEnv*, jclass, jfieldID); jboolean (*GetStaticBooleanField)(JNIEnv*, jclass, jfieldID); jbyte (*GetStaticByteField)(JNIEnv*, jclass, jfieldID); jchar (*GetStaticCharField)(JNIEnv*, jclass, jfieldID); jshort (*GetStaticShortField)(JNIEnv*, jclass, jfieldID); jint (*GetStaticIntField)(JNIEnv*, jclass, jfieldID); jlong (*GetStaticLongField)(JNIEnv*, jclass, jfieldID); jfloat (*GetStaticFloatField)(JNIEnv*, jclass, jfieldID) __NDK_FPABI__; jdouble (*GetStaticDoubleField)(JNIEnv*, jclass, jfieldID) __NDK_FPABI__; void (*SetStaticObjectField)(JNIEnv*, jclass, jfieldID, jobject); void (*SetStaticBooleanField)(JNIEnv*, jclass, jfieldID, jboolean); void (*SetStaticByteField)(JNIEnv*, jclass, jfieldID, jbyte); void (*SetStaticCharField)(JNIEnv*, jclass, jfieldID, jchar); void (*SetStaticShortField)(JNIEnv*, jclass, jfieldID, jshort); void (*SetStaticIntField)(JNIEnv*, jclass, jfieldID, jint); void (*SetStaticLongField)(JNIEnv*, jclass, jfieldID, jlong); void (*SetStaticFloatField)(JNIEnv*, jclass, jfieldID, jfloat) __NDK_FPABI__; void (*SetStaticDoubleField)(JNIEnv*, jclass, jfieldID, jdouble) __NDK_FPABI__; jstring (*NewString)(JNIEnv*, const jchar*, jsize); jsize (*GetStringLength)(JNIEnv*, jstring); const jchar*(*GetStringChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringChars)(JNIEnv*, jstring, const jchar*); jstring (*NewStringUTF)(JNIEnv*, const char*); jsize (*GetStringUTFLength)(JNIEnv*, jstring); const char* (*GetStringUTFChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringUTFChars)(JNIEnv*, jstring, const char*); jsize (*GetArrayLength)(JNIEnv*, jarray); jobjectArray(*NewObjectArray)(JNIEnv*, jsize, jclass, jobject); jobject (*GetObjectArrayElement)(JNIEnv*, jobjectArray, jsize); void (*SetObjectArrayElement)(JNIEnv*, jobjectArray, jsize, jobject); jbooleanArray (*NewBooleanArray)(JNIEnv*, jsize); jbyteArray (*NewByteArray)(JNIEnv*, jsize); jcharArray (*NewCharArray)(JNIEnv*, jsize); jshortArray (*NewShortArray)(JNIEnv*, jsize); jintArray (*NewIntArray)(JNIEnv*, jsize); jlongArray (*NewLongArray)(JNIEnv*, jsize); jfloatArray (*NewFloatArray)(JNIEnv*, jsize); jdoubleArray (*NewDoubleArray)(JNIEnv*, jsize); jboolean* (*GetBooleanArrayElements)(JNIEnv*, jbooleanArray, jboolean*); jbyte* (*GetByteArrayElements)(JNIEnv*, jbyteArray, jboolean*); jchar* (*GetCharArrayElements)(JNIEnv*, jcharArray, jboolean*); jshort* (*GetShortArrayElements)(JNIEnv*, jshortArray, jboolean*); jint* (*GetIntArrayElements)(JNIEnv*, jintArray, jboolean*); jlong* (*GetLongArrayElements)(JNIEnv*, jlongArray, jboolean*); jfloat* (*GetFloatArrayElements)(JNIEnv*, jfloatArray, jboolean*); jdouble* (*GetDoubleArrayElements)(JNIEnv*, jdoubleArray, jboolean*); void (*ReleaseBooleanArrayElements)(JNIEnv*, jbooleanArray,jboolean*, jint); void (*ReleaseByteArrayElements)(JNIEnv*, jbyteArray,jbyte*, jint); void (*ReleaseCharArrayElements)(JNIEnv*, jcharArray,jchar*, jint); void (*ReleaseShortArrayElements)(JNIEnv*, jshortArray,jshort*, jint); void (*ReleaseIntArrayElements)(JNIEnv*, jintArray,jint*, jint); void (*ReleaseLongArrayElements)(JNIEnv*, jlongArray,jlong*, jint); void (*ReleaseFloatArrayElements)(JNIEnv*, jfloatArray,jfloat*, jint); void (*ReleaseDoubleArrayElements)(JNIEnv*, jdoubleArray,jdouble*, jint); void (*GetBooleanArrayRegion)(JNIEnv*, jbooleanArray,jsize,jsize, jboolean*); void (*GetByteArrayRegion)(JNIEnv*, jbyteArray,jsize, jsize,jbyte*); void (*GetCharArrayRegion)(JNIEnv*, jcharArray, jsize, jsize,jchar*); void (*GetShortArrayRegion)(JNIEnv*, jshortArray,jsize, jsize,jshort*); void (*GetIntArrayRegion)(JNIEnv*, jintArray,jsize, jsize, jint*); void (*GetLongArrayRegion)(JNIEnv*, jlongArray,jsize, jsize, jlong*); void (*GetFloatArrayRegion)(JNIEnv*, jfloatArray,jsize, jsize, jfloat*); void (*GetDoubleArrayRegion)(JNIEnv*, jdoubleArray,jsize, jsize, jdouble*); void (*SetBooleanArrayRegion)(JNIEnv*, jbooleanArray,jsize, jsize, const jboolean*); void (*SetByteArrayRegion)(JNIEnv*, jbyteArray,jsize, jsize, const jbyte*); void (*SetCharArrayRegion)(JNIEnv*, jcharArray,jsize, jsize, const jchar*); void (*SetShortArrayRegion)(JNIEnv*, jshortArray,jsize, jsize, const jshort*); void (*SetIntArrayRegion)(JNIEnv*, jintArray,jsize, jsize, const jint*); void (*SetLongArrayRegion)(JNIEnv*, jlongArray, jsize, jsize, const jlong*); void (*SetFloatArrayRegion)(JNIEnv*, jfloatArray, jsize, jsize, const jfloat*); void (*SetDoubleArrayRegion)(JNIEnv*, jdoubleArray,jsize, jsize, const jdouble*); jint (*RegisterNatives)(JNIEnv*, jclass, const JNINativeMethod*,jint); jint (*UnregisterNatives)(JNIEnv*, jclass); jint (*MonitorEnter)(JNIEnv*, jobject); jint (*MonitorExit)(JNIEnv*, jobject); jint (*GetJavaVM)(JNIEnv*, JavaVM**); void (*GetStringRegion)(JNIEnv*, jstring, jsize, jsize, jchar*); void (*GetStringUTFRegion)(JNIEnv*, jstring, jsize, jsize, char*); void* (*GetPrimitiveArrayCritical)(JNIEnv*, jarray, jboolean*); void (*ReleasePrimitiveArrayCritical)(JNIEnv*, jarray, void*, jint); const jchar*(*GetStringCritical)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringCritical)(JNIEnv*, jstring, const jchar*); jweak (*NewWeakGlobalRef)(JNIEnv*, jobject); void (*DeleteWeakGlobalRef)(JNIEnv*, jweak); jboolean (*ExceptionCheck)(JNIEnv*); jobject (*NewDirectByteBuffer)(JNIEnv*, void*, jlong); void* (*GetDirectBufferAddress)(JNIEnv*, jobject); jlong (*GetDirectBufferCapacity)(JNIEnv*, jobject); jobjectRefType (*GetObjectRefType)(JNIEnv*, jobject);};/* * C++ */ //C++的JNI 本地接口结构体的调用struct _JNIEnv { const struct JNINativeInterface* functions;#if defined(__cplusplus) //各种函数 jint GetVersion() { return functions-&gt;GetVersion(this); } jclass DefineClass(const char *name, jobject loader, const jbyte* buf, jsize bufLen) { return functions-&gt;DefineClass(this, name, loader, buf, bufLen); } jclass FindClass(const char* name) { return functions-&gt;FindClass(this, name); } jmethodID FromReflectedMethod(jobject method) { return functions-&gt;FromReflectedMethod(this, method); } jfieldID FromReflectedField(jobject field) { return functions-&gt;FromReflectedField(this, field); } jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic) { return functions-&gt;ToReflectedMethod(this, cls, methodID, isStatic); } jclass GetSuperclass(jclass clazz) { return functions-&gt;GetSuperclass(this, clazz); } jboolean IsAssignableFrom(jclass clazz1, jclass clazz2) { return functions-&gt;IsAssignableFrom(this, clazz1, clazz2); } jobject ToReflectedField(jclass cls, jfieldID fieldID, jboolean isStatic) { return functions-&gt;ToReflectedField(this, cls, fieldID, isStatic); } jint Throw(jthrowable obj) { return functions-&gt;Throw(this, obj); } jint ThrowNew(jclass clazz, const char* message) { return functions-&gt;ThrowNew(this, clazz, message); } jthrowable ExceptionOccurred() { return functions-&gt;ExceptionOccurred(this); } void ExceptionDescribe() { functions-&gt;ExceptionDescribe(this); } void ExceptionClear() { functions-&gt;ExceptionClear(this); } void FatalError(const char* msg) { functions-&gt;FatalError(this, msg); } jint PushLocalFrame(jint capacity) { return functions-&gt;PushLocalFrame(this, capacity); } jobject PopLocalFrame(jobject result) { return functions-&gt;PopLocalFrame(this, result); } jobject NewGlobalRef(jobject obj) { return functions-&gt;NewGlobalRef(this, obj); } void DeleteGlobalRef(jobject globalRef) { functions-&gt;DeleteGlobalRef(this, globalRef); } void DeleteLocalRef(jobject localRef) { functions-&gt;DeleteLocalRef(this, localRef); } jboolean IsSameObject(jobject ref1, jobject ref2) { return functions-&gt;IsSameObject(this, ref1, ref2); } jobject NewLocalRef(jobject ref) { return functions-&gt;NewLocalRef(this, ref); } jint EnsureLocalCapacity(jint capacity) { return functions-&gt;EnsureLocalCapacity(this, capacity); } jobject AllocObject(jclass clazz) { return functions-&gt;AllocObject(this, clazz); } jobject NewObject(jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); jobject result = functions-&gt;NewObjectV(this, clazz, methodID, args); va_end(args); return result; } jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args) { return functions-&gt;NewObjectV(this, clazz, methodID, args); } jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args) { return functions-&gt;NewObjectA(this, clazz, methodID, args); } jclass GetObjectClass(jobject obj) { return functions-&gt;GetObjectClass(this, obj); } jboolean IsInstanceOf(jobject obj, jclass clazz) { return functions-&gt;IsInstanceOf(this, obj, clazz); } jmethodID GetMethodID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetMethodID(this, clazz, name, sig); }#define CALL_TYPE_METHOD(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype Call##_jname##Method(jobject obj, jmethodID methodID, ...) \\ { \\ _jtype result; \\ va_list args; \\ va_start(args, methodID); \\ result = functions-&gt;Call##_jname##MethodV(this, obj, methodID, \\ args); \\ va_end(args); \\ return result; \\ }#define CALL_TYPE_METHODV(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype Call##_jname##MethodV(jobject obj, jmethodID methodID, \\ va_list args) \\ { return functions-&gt;Call##_jname##MethodV(this, obj, methodID, args); }#define CALL_TYPE_METHODA(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype Call##_jname##MethodA(jobject obj, jmethodID methodID, \\ jvalue* args) \\ { return functions-&gt;Call##_jname##MethodA(this, obj, methodID, args); }#define CALL_TYPE(_jtype, _jname) \\ CALL_TYPE_METHOD(_jtype, _jname) \\ CALL_TYPE_METHODV(_jtype, _jname) \\ CALL_TYPE_METHODA(_jtype, _jname) CALL_TYPE(jobject, Object) CALL_TYPE(jboolean, Boolean) CALL_TYPE(jbyte, Byte) CALL_TYPE(jchar, Char) CALL_TYPE(jshort, Short) CALL_TYPE(jint, Int) CALL_TYPE(jlong, Long) CALL_TYPE(jfloat, Float) CALL_TYPE(jdouble, Double) void CallVoidMethod(jobject obj, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-&gt;CallVoidMethodV(this, obj, methodID, args); va_end(args); } void CallVoidMethodV(jobject obj, jmethodID methodID, va_list args) { functions-&gt;CallVoidMethodV(this, obj, methodID, args); } void CallVoidMethodA(jobject obj, jmethodID methodID, jvalue* args) { functions-&gt;CallVoidMethodA(this, obj, methodID, args); }#define CALL_NONVIRT_TYPE_METHOD(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallNonvirtual##_jname##Method(jobject obj, jclass clazz, \\ jmethodID methodID, ...) \\ { \\ _jtype result; \\ va_list args; \\ va_start(args, methodID); \\ result = functions-&gt;CallNonvirtual##_jname##MethodV(this, obj, \\ clazz, methodID, args); \\ va_end(args); \\ return result; \\ }#define CALL_NONVIRT_TYPE_METHODV(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallNonvirtual##_jname##MethodV(jobject obj, jclass clazz, \\ jmethodID methodID, va_list args) \\ { return functions-&gt;CallNonvirtual##_jname##MethodV(this, obj, clazz, \\ methodID, args); }#define CALL_NONVIRT_TYPE_METHODA(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallNonvirtual##_jname##MethodA(jobject obj, jclass clazz, \\ jmethodID methodID, jvalue* args) \\ { return functions-&gt;CallNonvirtual##_jname##MethodA(this, obj, clazz, \\ methodID, args); }#define CALL_NONVIRT_TYPE(_jtype, _jname) \\ CALL_NONVIRT_TYPE_METHOD(_jtype, _jname) \\ CALL_NONVIRT_TYPE_METHODV(_jtype, _jname) \\ CALL_NONVIRT_TYPE_METHODA(_jtype, _jname) CALL_NONVIRT_TYPE(jobject, Object) CALL_NONVIRT_TYPE(jboolean, Boolean) CALL_NONVIRT_TYPE(jbyte, Byte) CALL_NONVIRT_TYPE(jchar, Char) CALL_NONVIRT_TYPE(jshort, Short) CALL_NONVIRT_TYPE(jint, Int) CALL_NONVIRT_TYPE(jlong, Long) CALL_NONVIRT_TYPE(jfloat, Float) CALL_NONVIRT_TYPE(jdouble, Double) void CallNonvirtualVoidMethod(jobject obj, jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-&gt;CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args); va_end(args); } void CallNonvirtualVoidMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) { functions-&gt;CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args); } void CallNonvirtualVoidMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue* args) { functions-&gt;CallNonvirtualVoidMethodA(this, obj, clazz, methodID, args); } jfieldID GetFieldID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetFieldID(this, clazz, name, sig); } jobject GetObjectField(jobject obj, jfieldID fieldID) { return functions-&gt;GetObjectField(this, obj, fieldID); } jboolean GetBooleanField(jobject obj, jfieldID fieldID) { return functions-&gt;GetBooleanField(this, obj, fieldID); } jbyte GetByteField(jobject obj, jfieldID fieldID) { return functions-&gt;GetByteField(this, obj, fieldID); } jchar GetCharField(jobject obj, jfieldID fieldID) { return functions-&gt;GetCharField(this, obj, fieldID); } jshort GetShortField(jobject obj, jfieldID fieldID) { return functions-&gt;GetShortField(this, obj, fieldID); } jint GetIntField(jobject obj, jfieldID fieldID) { return functions-&gt;GetIntField(this, obj, fieldID); } jlong GetLongField(jobject obj, jfieldID fieldID) { return functions-&gt;GetLongField(this, obj, fieldID); } __NDK_FPABI__ jfloat GetFloatField(jobject obj, jfieldID fieldID) { return functions-&gt;GetFloatField(this, obj, fieldID); } __NDK_FPABI__ jdouble GetDoubleField(jobject obj, jfieldID fieldID) { return functions-&gt;GetDoubleField(this, obj, fieldID); } void SetObjectField(jobject obj, jfieldID fieldID, jobject value) { functions-&gt;SetObjectField(this, obj, fieldID, value); } void SetBooleanField(jobject obj, jfieldID fieldID, jboolean value) { functions-&gt;SetBooleanField(this, obj, fieldID, value); } void SetByteField(jobject obj, jfieldID fieldID, jbyte value) { functions-&gt;SetByteField(this, obj, fieldID, value); } void SetCharField(jobject obj, jfieldID fieldID, jchar value) { functions-&gt;SetCharField(this, obj, fieldID, value); } void SetShortField(jobject obj, jfieldID fieldID, jshort value) { functions-&gt;SetShortField(this, obj, fieldID, value); } void SetIntField(jobject obj, jfieldID fieldID, jint value) { functions-&gt;SetIntField(this, obj, fieldID, value); } void SetLongField(jobject obj, jfieldID fieldID, jlong value) { functions-&gt;SetLongField(this, obj, fieldID, value); } __NDK_FPABI__ void SetFloatField(jobject obj, jfieldID fieldID, jfloat value) { functions-&gt;SetFloatField(this, obj, fieldID, value); } __NDK_FPABI__ void SetDoubleField(jobject obj, jfieldID fieldID, jdouble value) { functions-&gt;SetDoubleField(this, obj, fieldID, value); } jmethodID GetStaticMethodID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetStaticMethodID(this, clazz, name, sig); }#define CALL_STATIC_TYPE_METHOD(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallStatic##_jname##Method(jclass clazz, jmethodID methodID, \\ ...) \\ { \\ _jtype result; \\ va_list args; \\ va_start(args, methodID); \\ result = functions-&gt;CallStatic##_jname##MethodV(this, clazz, \\ methodID, args); \\ va_end(args); \\ return result; \\ }#define CALL_STATIC_TYPE_METHODV(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallStatic##_jname##MethodV(jclass clazz, jmethodID methodID, \\ va_list args) \\ { return functions-&gt;CallStatic##_jname##MethodV(this, clazz, methodID, \\ args); }#define CALL_STATIC_TYPE_METHODA(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallStatic##_jname##MethodA(jclass clazz, jmethodID methodID, \\ jvalue* args) \\ { return functions-&gt;CallStatic##_jname##MethodA(this, clazz, methodID, \\ args); }#define CALL_STATIC_TYPE(_jtype, _jname) \\ CALL_STATIC_TYPE_METHOD(_jtype, _jname) \\ CALL_STATIC_TYPE_METHODV(_jtype, _jname) \\ CALL_STATIC_TYPE_METHODA(_jtype, _jname) CALL_STATIC_TYPE(jobject, Object) CALL_STATIC_TYPE(jboolean, Boolean) CALL_STATIC_TYPE(jbyte, Byte) CALL_STATIC_TYPE(jchar, Char) CALL_STATIC_TYPE(jshort, Short) CALL_STATIC_TYPE(jint, Int) CALL_STATIC_TYPE(jlong, Long) CALL_STATIC_TYPE(jfloat, Float) CALL_STATIC_TYPE(jdouble, Double) void CallStaticVoidMethod(jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-&gt;CallStaticVoidMethodV(this, clazz, methodID, args); va_end(args); } void CallStaticVoidMethodV(jclass clazz, jmethodID methodID, va_list args) { functions-&gt;CallStaticVoidMethodV(this, clazz, methodID, args); } void CallStaticVoidMethodA(jclass clazz, jmethodID methodID, jvalue* args) { functions-&gt;CallStaticVoidMethodA(this, clazz, methodID, args); } jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetStaticFieldID(this, clazz, name, sig); } jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticObjectField(this, clazz, fieldID); } jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticBooleanField(this, clazz, fieldID); } jbyte GetStaticByteField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticByteField(this, clazz, fieldID); } jchar GetStaticCharField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticCharField(this, clazz, fieldID); } jshort GetStaticShortField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticShortField(this, clazz, fieldID); } jint GetStaticIntField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticIntField(this, clazz, fieldID); } jlong GetStaticLongField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticLongField(this, clazz, fieldID); } __NDK_FPABI__ jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticFloatField(this, clazz, fieldID); } __NDK_FPABI__ jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticDoubleField(this, clazz, fieldID); } void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value) { functions-&gt;SetStaticObjectField(this, clazz, fieldID, value); } void SetStaticBooleanField(jclass clazz, jfieldID fieldID, jboolean value) { functions-&gt;SetStaticBooleanField(this, clazz, fieldID, value); } void SetStaticByteField(jclass clazz, jfieldID fieldID, jbyte value) { functions-&gt;SetStaticByteField(this, clazz, fieldID, value); } void SetStaticCharField(jclass clazz, jfieldID fieldID, jchar value) { functions-&gt;SetStaticCharField(this, clazz, fieldID, value); } void SetStaticShortField(jclass clazz, jfieldID fieldID, jshort value) { functions-&gt;SetStaticShortField(this, clazz, fieldID, value); } void SetStaticIntField(jclass clazz, jfieldID fieldID, jint value) { functions-&gt;SetStaticIntField(this, clazz, fieldID, value); } void SetStaticLongField(jclass clazz, jfieldID fieldID, jlong value) { functions-&gt;SetStaticLongField(this, clazz, fieldID, value); } __NDK_FPABI__ void SetStaticFloatField(jclass clazz, jfieldID fieldID, jfloat value) { functions-&gt;SetStaticFloatField(this, clazz, fieldID, value); } __NDK_FPABI__ void SetStaticDoubleField(jclass clazz, jfieldID fieldID, jdouble value) { functions-&gt;SetStaticDoubleField(this, clazz, fieldID, value); } jstring NewString(const jchar* unicodeChars, jsize len) { return functions-&gt;NewString(this, unicodeChars, len); } jsize GetStringLength(jstring string) { return functions-&gt;GetStringLength(this, string); } const jchar* GetStringChars(jstring string, jboolean* isCopy) { return functions-&gt;GetStringChars(this, string, isCopy); } void ReleaseStringChars(jstring string, const jchar* chars) { functions-&gt;ReleaseStringChars(this, string, chars); } jstring NewStringUTF(const char* bytes) { return functions-&gt;NewStringUTF(this, bytes); } jsize GetStringUTFLength(jstring string) { return functions-&gt;GetStringUTFLength(this, string); } const char* GetStringUTFChars(jstring string, jboolean* isCopy) { return functions-&gt;GetStringUTFChars(this, string, isCopy); } void ReleaseStringUTFChars(jstring string, const char* utf) { functions-&gt;ReleaseStringUTFChars(this, string, utf); } jsize GetArrayLength(jarray array) { return functions-&gt;GetArrayLength(this, array); } jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement) { return functions-&gt;NewObjectArray(this, length, elementClass, initialElement); } jobject GetObjectArrayElement(jobjectArray array, jsize index) { return functions-&gt;GetObjectArrayElement(this, array, index); } void SetObjectArrayElement(jobjectArray array, jsize index, jobject value) { functions-&gt;SetObjectArrayElement(this, array, index, value); } jbooleanArray NewBooleanArray(jsize length) { return functions-&gt;NewBooleanArray(this, length); } jbyteArray NewByteArray(jsize length) { return functions-&gt;NewByteArray(this, length); } jcharArray NewCharArray(jsize length) { return functions-&gt;NewCharArray(this, length); } jshortArray NewShortArray(jsize length) { return functions-&gt;NewShortArray(this, length); } jintArray NewIntArray(jsize length) { return functions-&gt;NewIntArray(this, length); } jlongArray NewLongArray(jsize length) { return functions-&gt;NewLongArray(this, length); } jfloatArray NewFloatArray(jsize length) { return functions-&gt;NewFloatArray(this, length); } jdoubleArray NewDoubleArray(jsize length) { return functions-&gt;NewDoubleArray(this, length); } jboolean* GetBooleanArrayElements(jbooleanArray array, jboolean* isCopy) { return functions-&gt;GetBooleanArrayElements(this, array, isCopy); } jbyte* GetByteArrayElements(jbyteArray array, jboolean* isCopy) { return functions-&gt;GetByteArrayElements(this, array, isCopy); } jchar* GetCharArrayElements(jcharArray array, jboolean* isCopy) { return functions-&gt;GetCharArrayElements(this, array, isCopy); } jshort* GetShortArrayElements(jshortArray array, jboolean* isCopy) { return functions-&gt;GetShortArrayElements(this, array, isCopy); } jint* GetIntArrayElements(jintArray array, jboolean* isCopy) { return functions-&gt;GetIntArrayElements(this, array, isCopy); } jlong* GetLongArrayElements(jlongArray array, jboolean* isCopy) { return functions-&gt;GetLongArrayElements(this, array, isCopy); } jfloat* GetFloatArrayElements(jfloatArray array, jboolean* isCopy) { return functions-&gt;GetFloatArrayElements(this, array, isCopy); } jdouble* GetDoubleArrayElements(jdoubleArray array, jboolean* isCopy) { return functions-&gt;GetDoubleArrayElements(this, array, isCopy); } void ReleaseBooleanArrayElements(jbooleanArray array, jboolean* elems, jint mode) { functions-&gt;ReleaseBooleanArrayElements(this, array, elems, mode); } void ReleaseByteArrayElements(jbyteArray array, jbyte* elems, jint mode) { functions-&gt;ReleaseByteArrayElements(this, array, elems, mode); } void ReleaseCharArrayElements(jcharArray array, jchar* elems, jint mode) { functions-&gt;ReleaseCharArrayElements(this, array, elems, mode); } void ReleaseShortArrayElements(jshortArray array, jshort* elems, jint mode) { functions-&gt;ReleaseShortArrayElements(this, array, elems, mode); } void ReleaseIntArrayElements(jintArray array, jint* elems, jint mode) { functions-&gt;ReleaseIntArrayElements(this, array, elems, mode); } void ReleaseLongArrayElements(jlongArray array, jlong* elems, jint mode) { functions-&gt;ReleaseLongArrayElements(this, array, elems, mode); } void ReleaseFloatArrayElements(jfloatArray array, jfloat* elems, jint mode) { functions-&gt;ReleaseFloatArrayElements(this, array, elems, mode); } void ReleaseDoubleArrayElements(jdoubleArray array, jdouble* elems, jint mode) { functions-&gt;ReleaseDoubleArrayElements(this, array, elems, mode); } void GetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, jboolean* buf) { functions-&gt;GetBooleanArrayRegion(this, array, start, len, buf); } void GetByteArrayRegion(jbyteArray array, jsize start, jsize len, jbyte* buf) { functions-&gt;GetByteArrayRegion(this, array, start, len, buf); } void GetCharArrayRegion(jcharArray array, jsize start, jsize len, jchar* buf) { functions-&gt;GetCharArrayRegion(this, array, start, len, buf); } void GetShortArrayRegion(jshortArray array, jsize start, jsize len, jshort* buf) { functions-&gt;GetShortArrayRegion(this, array, start, len, buf); } void GetIntArrayRegion(jintArray array, jsize start, jsize len, jint* buf) { functions-&gt;GetIntArrayRegion(this, array, start, len, buf); } void GetLongArrayRegion(jlongArray array, jsize start, jsize len, jlong* buf) { functions-&gt;GetLongArrayRegion(this, array, start, len, buf); } void GetFloatArrayRegion(jfloatArray array, jsize start, jsize len, jfloat* buf) { functions-&gt;GetFloatArrayRegion(this, array, start, len, buf); } void GetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, jdouble* buf) { functions-&gt;GetDoubleArrayRegion(this, array, start, len, buf); } void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, const jboolean* buf) { functions-&gt;SetBooleanArrayRegion(this, array, start, len, buf); } void SetByteArrayRegion(jbyteArray array, jsize start, jsize len, const jbyte* buf) { functions-&gt;SetByteArrayRegion(this, array, start, len, buf); } void SetCharArrayRegion(jcharArray array, jsize start, jsize len, const jchar* buf) { functions-&gt;SetCharArrayRegion(this, array, start, len, buf); } void SetShortArrayRegion(jshortArray array, jsize start, jsize len, const jshort* buf) { functions-&gt;SetShortArrayRegion(this, array, start, len, buf); } void SetIntArrayRegion(jintArray array, jsize start, jsize len, const jint* buf) { functions-&gt;SetIntArrayRegion(this, array, start, len, buf); } void SetLongArrayRegion(jlongArray array, jsize start, jsize len, const jlong* buf) { functions-&gt;SetLongArrayRegion(this, array, start, len, buf); } void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len, const jfloat* buf) { functions-&gt;SetFloatArrayRegion(this, array, start, len, buf); } void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, const jdouble* buf) { functions-&gt;SetDoubleArrayRegion(this, array, start, len, buf); } jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods) { return functions-&gt;RegisterNatives(this, clazz, methods, nMethods); } jint UnregisterNatives(jclass clazz) { return functions-&gt;UnregisterNatives(this, clazz); } jint MonitorEnter(jobject obj) { return functions-&gt;MonitorEnter(this, obj); } jint MonitorExit(jobject obj) { return functions-&gt;MonitorExit(this, obj); } jint GetJavaVM(JavaVM** vm) { return functions-&gt;GetJavaVM(this, vm); } void GetStringRegion(jstring str, jsize start, jsize len, jchar* buf) { functions-&gt;GetStringRegion(this, str, start, len, buf); } void GetStringUTFRegion(jstring str, jsize start, jsize len, char* buf) { return functions-&gt;GetStringUTFRegion(this, str, start, len, buf); } void* GetPrimitiveArrayCritical(jarray array, jboolean* isCopy) { return functions-&gt;GetPrimitiveArrayCritical(this, array, isCopy); } void ReleasePrimitiveArrayCritical(jarray array, void* carray, jint mode) { functions-&gt;ReleasePrimitiveArrayCritical(this, array, carray, mode); } const jchar* GetStringCritical(jstring string, jboolean* isCopy) { return functions-&gt;GetStringCritical(this, string, isCopy); } void ReleaseStringCritical(jstring string, const jchar* carray) { functions-&gt;ReleaseStringCritical(this, string, carray); } jweak NewWeakGlobalRef(jobject obj) { return functions-&gt;NewWeakGlobalRef(this, obj); } void DeleteWeakGlobalRef(jweak obj) { functions-&gt;DeleteWeakGlobalRef(this, obj); } jboolean ExceptionCheck() { return functions-&gt;ExceptionCheck(this); } jobject NewDirectByteBuffer(void* address, jlong capacity) { return functions-&gt;NewDirectByteBuffer(this, address, capacity); } void* GetDirectBufferAddress(jobject buf) { return functions-&gt;GetDirectBufferAddress(this, buf); } jlong GetDirectBufferCapacity(jobject buf) { return functions-&gt;GetDirectBufferCapacity(this, buf); } /* added in JNI 1.6 */ jobjectRefType GetObjectRefType(jobject obj) { return functions-&gt;GetObjectRefType(this, obj); }#endif /*__cplusplus*/};/* * JNI invocation interface. */ //调用接口结构体JNIInvokeInterface的定义struct JNIInvokeInterface { void* reserved0; void* reserved1; void* reserved2; jint (*DestroyJavaVM)(JavaVM*); jint (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*); jint (*DetachCurrentThread)(JavaVM*); jint (*GetEnv)(JavaVM*, void**, jint); jint (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);};/* * C++ version. */struct _JavaVM { const struct JNIInvokeInterface* functions;#if defined(__cplusplus) jint DestroyJavaVM() { return functions-&gt;DestroyJavaVM(this); } jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) { return functions-&gt;AttachCurrentThread(this, p_env, thr_args); } jint DetachCurrentThread() { return functions-&gt;DetachCurrentThread(this); } jint GetEnv(void** env, jint version) { return functions-&gt;GetEnv(this, env, version); } jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) { return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); }#endif /*__cplusplus*/};struct JavaVMAttachArgs { jint version; /* must be &gt;= JNI_VERSION_1_2 */ const char* name; /* NULL or name of thread as modified UTF-8 str */ jobject group; /* global ref of a ThreadGroup object, or NULL */};typedef struct JavaVMAttachArgs JavaVMAttachArgs;/* * JNI 1.2+ initialization. (As of 1.6, the pre-1.2 structures are no * longer supported.) */typedef struct JavaVMOption { const char* optionString; void* extraInfo;} JavaVMOption;typedef struct JavaVMInitArgs { jint version; /* use JNI_VERSION_1_2 or later */ jint nOptions; JavaVMOption* options; jboolean ignoreUnrecognized;} JavaVMInitArgs;#ifdef __cplusplusextern &quot;C&quot; {#endif/* * VM initialization functions. * * Note these are the only symbols exported for JNI by the VM. */#if 0 /* In practice, these are not exported by the NDK so don't declare them */jint JNI_GetDefaultJavaVMInitArgs(void*);jint JNI_CreateJavaVM(JavaVM**, JNIEnv**, void*);jint JNI_GetCreatedJavaVMs(JavaVM**, jsize, jsize*);#endif#define JNIIMPORT#define JNIEXPORT __attribute__ ((visibility (&quot;default&quot;)))#define JNICALL __NDK_FPABI__/* * Prototypes for functions exported by loadable shared libs. These are * called by JNI, not provided by JNI. */JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);#ifdef __cplusplus}#endif/* * Manifest constants. */#define JNI_FALSE 0#define JNI_TRUE 1#define JNI_VERSION_1_1 0x00010001#define JNI_VERSION_1_2 0x00010002#define JNI_VERSION_1_4 0x00010004#define JNI_VERSION_1_6 0x00010006#define JNI_OK (0) /* no error */#define JNI_ERR (-1) /* generic error */#define JNI_EDETACHED (-2) /* thread detached from the VM */#define JNI_EVERSION (-3) /* JNI version error */#define JNI_COMMIT 1 /* copy content, do not free buffer */#define JNI_ABORT 2 /* free buffer w/o copying back */#endif /* JNI_H_ */","link":"/20211201/JNI%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3/"},{"title":"Hook All In Unidbg","text":"原文链接: https://blog.csdn.net/qq_38851536/category_11102404.html 更多Unidbg使用和算法还原的教程可见龙哥星球。 本文总结了Unidbg Hook and Call 的知识，部分Hook代码采用Frida 与 Unidbg 对照的方式，帮助熟悉Frida但不熟悉Unidbg的读者快速入门。样例前往百度云下载。 链接：https://pan.baidu.com/s/1ZRPtQrx4QAPEQhrpq6gbgg 提取码：6666 一、基础知识1.获取SO基地址Ⅰfrida 获取基地址1var baseAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;); Ⅱ Unidbg 获取基地址123456// 加载so到虚拟内存DalvikModule dm = vm.loadLibrary(&quot;libnative-lib.so&quot;, true);// 加载好的so对应为一个模块module = dm.getModule();// 打印libnative-lib.so在Unidbg虚拟内存中的基地址System.out.println(&quot;baseAddr:&quot;+module.base); 加载了多个SO的情况 1234// 获取某个具体SO的句柄Module yourModule = emulator.getMemory().findModule(&quot;yourModuleName&quot;);// 打印其基地址System.out.println(&quot;baseAddr:&quot;+yourModule.base); 如果只主动加载一个SO，其基址恒为0x40000000 ,这是一个检测Unidbg的点，可以在 com/github/unidbg/memory/Memory.java 中做修改 1234567891011public interface Memory extends IO, Loader, StackMemory { long STACK_BASE = 0xc0000000L; int STACK_SIZE_OF_PAGE = 256; // 1024k // 修改内存映射的起始地址 long MMAP_BASE = 0x40000000L; UnidbgPointer allocateStack(int size); UnidbgPointer pointer(long address); void setStackPoint(long sp); 2.获取函数地址Ⅰ Frida 获取导出函数地址1Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;) Ⅱ Unidbg 获取导出函数地址12345// 加载so到虚拟内存DalvikModule dm = vm.loadLibrary(&quot;libnative-lib.so&quot;, true);// 加载好的 libscmain.so对应为一个模块module = dm.getModule();int address = (int) module.findSymbolByName(&quot;funcNmae&quot;).getAddress(); Ⅲ Frida 获取非导出函数地址12var soAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;);var FuncAddr = soAddr.add(0x1768 + 1); Ⅳ Unidbg 获取非导出函数地址12345678// 加载so到虚拟内存DalvikModule dm = vm.loadLibrary(&quot;libnative-lib.so&quot;, true);// 加载好的so对应为一个模块module = dm.getModule();// offset，在IDA中查看int offset = 0x1768;// 真实地址 = baseAddr + offsetint address = (int) (module.base + offset); Hook 非导出函数时，不管是Frida还是Unidbg都需要考虑thumb2下地址+1的问题。 3.Unidbg Hook 大盘点Unidbg 在Android 上支持两大类Hook方案 Unidbg 内置的第三方Hook框架，包括xHook/Whale/HookZz Unicorn Hook以及基于它封装的Console Debugger，主要就指Console Debugger。 第一类是Unidbg支持并内置的第三方Hook框架，有Dobby(前身HookZz)/Whale这样的Inline Hook框架，也有xHook这样的PLT Hook 框架，支持这些Hook框架的使用，证明了Unidbg确实相对完善。但支持Frida还有很远的路要走，Frida比Dobby或者xHook都复杂的多，使用到了多线程、信号处理等Unidbg尚不支持的机制。总体来说，Dobby + Whale + xHook 也绝对够用了，没有非Frida不可的需求。 第二类是Unicorn Hook，只有当Unidbg的底层引擎选择为Unicorn时（默认引擎），才能使用。Unicorn提供了各种级别和粒度的Hook，内存Hook/指令/基本块 Hook/异常Hook 等等，十分强大，Unidbg基于它封装了更便于使用的Console Debugger，Unidbg也支持IDA/GDB的联合调试，但仍处于实验性质，不建议尝试。 该选择哪一类Hook方案？这得看使用Unidbg的目的。如果用于模拟执行，那么建议使用第一类Hook，为什么？这得从Unidbg支持的汇编执行引擎说起。Unidbg支持多种底层引擎，最早也是默认的引擎是Unicorn，从名字也能看出，Unidbg和Unicorn有很大关系。但后续Unidbg又支持了数个引擎，丰富了Unidbg的底层生态。但我们知道，任何提高程序复杂度的行为，肯定都为了解决什么问题。 hypervisor 引擎用于搭载了 Apple Silicon 芯片的设备； KVM 引擎用于树莓派； Dynarmic 引擎是为了更快的模拟执行； Unicorn 是最强大最完善的模拟执行引擎，但它相比Dynarmic太慢了，同场景下，Dynarmic比Unicorn模拟执行快数倍甚至十数倍。因此在生产环境中，采用 Dynarmic 引擎配上 unidbg-boot-server 实现高并发。 Dynarmic引擎使用 123456private static AndroidEmulator createARMEmulator() { return AndroidEmulatorBuilder.for32Bit() // 切换为Dynarmic引擎 .addBackendFactory(new DynarmicFactory(true)) .build();} Unicorn 默认引擎 1234private static AndroidEmulator createARMEmulator() { return AndroidEmulatorBuilder.for32Bit() .build();} 使用Unidbg的第二个场景是辅助算法还原，即模拟执行只作为算法还原的前奏，在模拟执行输出结果无误后，再使用Unidbg辅助算法还原。这种情况下对执行速度要求不高，那肯定使用更强大的Unicorn引擎。这时候两大类Hook方案都可以使用，选择哪类？我倾向于自始至终使用第二类方案，即基于Unicorn Hook的方案。 我个人认为有三点优势 HookZz或者xHook等方案，都可以基于其Hook实现原理进行检测，但Unicorn 原生Hook不容易被检测。 Unicorn Hook 没有局限，其他方案局限性较大。比如Inline Hook方案不能Hook短函数，或者两个相邻的地址；PLT Hook 不能 Hook Sub_xxx 子函数。 两类方案混用时，一定几率触发bug，事实上，单使用Unicorn的某些Hook功能都有bug，因此统一用原生Hook可以少一些bug。 总结如下 Ⅰ 以模拟执行为目的使用第三方Hook方案，arm32下HookZz的支持较好，arm64下Dobby的支持较好，HookZz/Dobby Hook不成功时，如果函数是导出函数就用xHook，否则使用 Whale。 Ⅱ 以算法还原为目的使用Console Debugger 和 Unicorn Hook，不优先使用第三方Hook方案。 4.本篇的基础代码即模拟执行demo的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.tutorial;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.arm.HookStatus;import com.github.unidbg.arm.backend.Backend;import com.github.unidbg.arm.backend.CodeHook;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.hook.HookContext;import com.github.unidbg.hook.ReplaceCallback;import com.github.unidbg.hook.hookzz.*;import com.github.unidbg.hook.whale.IWhale;import com.github.unidbg.hook.whale.Whale;import com.github.unidbg.hook.xhook.IxHook;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.XHookImpl;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.DvmObject;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import com.github.unidbg.utils.Inspector;import com.sun.jna.Pointer;import unicorn.ArmConst;import unicorn.Unicorn;import java.io.File;public class hookInUnidbg { private final AndroidEmulator emulator; private final VM vm; private final Module module; hookInUnidbg() { // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for32Bit().build(); // 模拟器的内存操作接口 final Memory memory = emulator.getMemory(); // 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); // 创建Android虚拟机 vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&quot;));// emulator.attach().addBreakPoint(0x40000000+0xa80); // 加载so到虚拟内存 DalvikModule dm = vm.loadLibrary(&quot;hookinunidbg&quot;, true); // 加载好的 libhookinunidbg.so对应为一个模块 module = dm.getModule(); // 执行JNIOnLoad（如果有的话） dm.callJNI_OnLoad(emulator); } public void call(){ DvmClass dvmClass = vm.resolveClass(&quot;com/example/hookinunidbg/MainActivity&quot;); String methodSign = &quot;call()V&quot;; DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(null); dvmObject.callJniMethodObject(emulator, methodSign); } public static void main(String[] args) { hookInUnidbg mydemo = new hookInUnidbg(); mydemo.call(); }} 运行时有一些日志输出，为正常逻辑。 二、Hook 函数demo hookInunidbg中运行了数个函数，在本节中关注其中运行的base64_encode函数。 12unsigned intbase64_encode(const unsigned char *in, unsigned int inlen, char *out); 参数解释如下 char *out：一块buffer的首地址，用来存放转码后的内容。 char *in：原字符串的首地址，指向原字符串内容。 int inlen：原字符串长度。 返回值：正常情况下返回转换后字符串的实际长度。 本节的任务就是打印base64编码前的内容，以及编码后的内容。 1.Frida1234567891011121314151617181920212223242526272829// Frida Versionfunction main(){ // get base address of target so; var base_addr = Module.findBaseAddress(&quot;libhookinunidbg.so&quot;); if (base_addr){ var func_addr = Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;base64_encode&quot;); console.log(&quot;hook base64_encode function&quot;) Interceptor.attach(func_addr,{ // 打印入参 onEnter: function (args) { console.log(&quot;\\n input:&quot;) this.buffer = args[2]; var length = args[1]; console.log(hexdump(args[0],{length: length.toUInt32()})) console.log(&quot;\\n&quot;) }, // 打印返回值 onLeave: function () { console.log(&quot; output:&quot;) console.log(this.buffer.readCString()); } }) }}setImmediate(main); 2.Console DebuggerConsole Debugger 是快速打击、快速验证的交互调试器，在call JNIOnLoad之前下断点。 12// debugemulator.attach().addBreakPoint(module.findSymbolByName(&quot;base64_encode&quot;).getAddress()); 需要重申和强调几个概念 运行到对应地址时触发断点，类似于GDB调试或者IDA调试，时机为目标指令执行前。 断点不具有函数的种种概念，需要从汇编指令的角度去理解函数。 Console Debugger 用于辅助算法分析，快速分析、确认某个函数的功能。在Unicorn 引擎下才可以用。 针对第二条做补充 根据ARM ATPCS调用约定，当参数个数小于等于4个的时候，子程序间通过R0~R3来传递参数（即R0-R3代表参数1-参数4），如果参数个数大于4个，余下的参数通过sp所指向的数据栈进行参数传递。而函数的返回值总是通过R0传递回来。 以目标函数为例，函数调用前，调用方把三个参数依次放在R0-R2中。 立即数可以直接看，比如此处参数2是5。如果怀疑不是立即数而是指针，比如参数1和参数3，那么在交互调试中输入 mxx 查看其指向的内存，等价于Frida中的hexdump(xxx)。写法有两种，以此处r0为例，既可以 mr0 也可以 m0x400022e0 。 Unidbg 在数据展示上，相较于Frida Hexdump，有一些不同，体现在两方面 Frida hexdump时，左侧基地址从当前地址开始，而Unidbg从0开始。 Unidbg 给出了所打印数据块的md5值，方便对比两块数据块内容是否一致，而且还展示数据的Hex String，方便在大量日志中搜索。 Console Debugger 支持许多调试、分析的命令，如下： 12345678910111213141516171819202122232425262728293031323334353637383940c: continuen: step overbt: back tracest hex: search stackshw hex: search writable heapshr hex: search readable heapshx hex: search executable heapnb: break at next blocks|si: step intos[decimal]: execute specified amount instructions(blx): execute util BLX mnemonic, low performancem(op) [size]: show memory, default size is 0x70, size may hex or decimalmr0-mr7, mfp, mip, msp [size]: show memory of specified registerm(address) [size]: show memory of specified address, address must start with 0xwr0-wr7, wfp, wip, wsp &lt;value&gt;: write specified registerwb(address), ws(address), wi(address) &lt;value&gt;: write (byte, short, integer) memory of specified address, address must start with 0xwx(address) &lt;hex&gt;: write bytes to memory at specified address, address must start with 0xb(address): add temporarily breakpoint, address must start with 0x, can be module offsetb: add breakpoint of register PCr: remove breakpoint of register PCblr: add temporarily breakpoint of register LRp (assembly): patch assembly at PC addresswhere: show java stack tracetrace [begin end]: Set trace instructionstraceRead [begin end]: Set trace memory readtraceWrite [begin end]: Set trace memory writevm: view loaded modulesvbs: view breakpointsd|dis: show disassembled(0x): show disassemble at specify addressstop: stop emulationrun [arg]: run testcc size: convert asm from 0x400008a0 - 0x400008a0 + size bytes to c function 在Frida代码中，用 console.log(hexdump(args[0],{length: args[1].toUInt32()}))来打印 参数1指向的内存块，长度为参数2的值 ，Unidbg中同样可以指定长度。 1234567mr0 5&gt;-----------------------------------------------------------------------------&lt;[23:41:37 891]r0=RX@0x400022e0[libhookinunidbg.so]0x22e0, md5=f5704182e75d12316f5b729e89a499df, hex=6c696c6163size: 50000: 6C 69 6C 61 63 lilac^-----------------------------------------------------------------------------^ 目前Console Debugger 还不支持 mr0 r1这样的语法。 至此实现了Frida OnEnter的功能，接下来要获取OnLeave即函数执行完的时机。在ARM编程中，LR寄存器存放了程序的返回地址，当函数跑到LR所指向的地址时，意味着函数结束跳转了出来。又因为断点是在目标地址执行前触发，所以在LR处的断点断下时，目标函数执行完且刚执行完，这就是Frida OnLeave 时机点的原理。在Console Debugger交互调试中，使用 blr 命令可以在 lr 处下一个临时断点，它只会触发一次。 整体逻辑如下 在目标函数的地址处下断点 运行到断点处，进入Console Debugger 交互调试 mxx 系列查看参数 blr 在函数返回处下断点 c 使程序继续运行，到返回值处断下 查看此时的buffer 需要注意的是，在onLeave时机中通过mr2查看入参3是胡闹。R2只在程序入口处表示参数3，在函数运算的过程中，R2作为通用寄存器被用于存储、运算，它已经不是指向buffer的地址了。在Frida中也存在这个问题，所以我们在OnEnter里将args[2]即R2的值保存在this.buffer中，OnLeave中再取出来打印。而在Console Debugger交互调试中，办法更简单粗暴——鼠标往上拉一下，看看原来r2的值是什么，发现是0x401d2000，然后m0x401d2000即可。 这样我们就实现了Frida的等价功能。似乎有点麻烦，但熟练后你会发现Console Debugger 是最快最稳的Hook &amp; Debug 工具。除此之外，当函数被调用了三五百次时，我们不希望它反复停下来，然后不停“c”来继续运行。Console Debugger 也可以做持久化的Hook，代码如下。 123456789101112131415161718192021222324public void HookByConsoleDebugger(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;base64_encode&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext context = emulator.getContext(); Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); Pointer buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), &quot;base64 input&quot;); // OnLeave emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { // onHit返回ture时，断点触发时不会进入交互界面；为false时会。 String result = buffer.getString(0); System.out.println(&quot;base64 result:&quot;+result); return true; } }); return true; } });} 3.第三方Hook框架如下目标函数均在JNIOnLoad前调用 ⅠxHook123456789101112131415161718192021public void HookByXhook(){ IxHook xHook = XHookImpl.getInstance(emulator); xHook.register(&quot;libhookinunidbg.so&quot;, &quot;base64_encode&quot;, new ReplaceCallback() { @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) { Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); Pointer buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), &quot;base64 input&quot;); context.push(buffer); return HookStatus.RET(emulator, originFunction); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) { Pointer buffer = context.pop(); System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }, true); // 使其生效 xHook.refresh();} xHook是爱奇艺开源的Android PLT hook框架，优点是挺稳定好用，缺点是不能Hook Sub_xxx 子函数。这是其原理所限。 Ⅱ HookZz1234567891011121314151617181920public void HookByHookZz(){ IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz，支持inline hook hookZz.enable_arm_arm64_b_branch(); // 测试enable_arm_arm64_b_branch，可有可无 hookZz.wrap(module.findSymbolByName(&quot;base64_encode&quot;), new WrapCallback&lt;HookZzArm32RegisterContext&gt;() { @Override public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) { Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); Pointer buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), &quot;base64 input&quot;); context.push(buffer); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) { Pointer buffer = context.pop(); System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }); hookZz.disable_arm_arm64_b_branch();} HookZz 也可以实现类似于单行断点的Hook，但在Unidbg 的Hook大环境下感觉用处不大，不建议使用。 1234567IHookZz hookZz = HookZz.getInstance(emulator);hookZz.instrument(module.base + 0x978 + 1, new InstrumentCallback&lt;RegisterContext&gt;() { @Override public void dbiCall(Emulator&lt;?&gt; emulator, RegisterContext ctx, HookEntryInfo info) { System.out.println(ctx.getIntArg(0)); }}); HookZz是老名字，现在叫Dobby，Unidbg中HookZz和Dobby是两个独立的Hook库，因为Unidbg作者认为HookZz在arm32上支持较好，Dobby在arm64上支持较好。HookZz或者说Dobby采用的是inline hook方案，因此可以Hook Sub_xxx，缺点是短函数可能出bug，受限于其 inline Hook 原理。 Ⅲ Whale1234567891011121314151617181920public void HookByWhale(){ IWhale whale = Whale.getInstance(emulator); whale.inlineHookFunction(module.findSymbolByName(&quot;base64_encode&quot;), new ReplaceCallback() { Pointer buffer; @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, long originFunction) { RegisterContext context = emulator.getContext(); Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), &quot;base64 input&quot;); return HookStatus.RET(emulator, originFunction); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) { System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }, true);} Whale 是一个跨平台的Hook框架，在Andorid Native Hook 上也是inline Hook方案，具体情况我了解不多。 4.Unicorn Hook如果想对某个函数进行集中的、高强度的、同时又灵活的调试，Unicorn CodeHook是一个好选择。比如我想查看目标函数第一条指令的r1，第二条指令的r2，第三条指令的r3，类似于这种需求。 hook_add_new 第一个参数是Hook回调，我们这里选择CodeHook，它是逐条指令Hook，参数2是起始地址，参数3是结束地址，参数4一般填null。这意味着从起始地址到终止地址这个执行范围内的每条指令，我们都可以在其执行前处理它。 找到目标函数的代码范围 123456789101112131415161718192021222324252627282930313233public void HookByUnicorn(){ long start = module.base+0x97C; long end = module.base+0x97C+0x17A; emulator.getBackend().hook_add_new(new CodeHook() { @Override public void hook(Backend backend, long address, int size, Object user) { RegisterContext registerContext = emulator.getContext(); if(address == module.base + 0x97C){ int r0 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R0); System.out.println(&quot;0x97C 处 r0:&quot;+Integer.toHexString(r0)); } if(address == module.base + 0x97C + 2){ int r2 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R2); System.out.println(&quot;0x97C +2 处 r2:&quot;+Integer.toHexString(r2)); } if(address == module.base + 0x97C + 4){ int r4 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R4); System.out.println(&quot;0x97C +4 处 r4:&quot;+Integer.toHexString(r4)); } } @Override public void onAttach(Unicorn.UnHook unHook) { } @Override public void detach() { } }, start, end, null);} 三、Replace 参数和返回值1.替换参数需求：入参改为hello world，对应的入参长度也要改，正确结果是 **aGVsbG8gd29ybGQ=**，供验证效果。 ⅠFrida12345678910111213141516171819202122232425262728// Frida Versionfunction main(){ // get base address of target so; var base_addr = Module.findBaseAddress(&quot;libhookinunidbg.so&quot;); if (base_addr){ var func_addr = Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;base64_encode&quot;); console.log(&quot;hook base64_encode function&quot;) var fakeinput = &quot;hello world&quot; var fakeinputPtr = Memory.allocUtf8String(fakeinput); Interceptor.attach(func_addr,{ onEnter: function (args) { args[0] = fakeinputPtr; args[1] = ptr(fakeinput.length); this.buffer = args[2]; }, // 打印返回值 onLeave: function () { console.log(&quot; output:&quot;) console.log(this.buffer.readCString()); } }) }}setImmediate(main); Ⅱ Console DebuggerConsole Debugger 如何实现这一目标？ ①下断点，运行代码后进入debugger 1emulator.attach().addBreakPoint(module.findSymbolByName(&quot;base64_encode&quot;).getAddress()); ②通过命令修改参数1和2，字符串得通过hexstring的形式传入 12345678910wx0x40002403 68656c6c6f20776f726c64&gt;-----------------------------------------------------------------------------&lt;[14:06:46 165]RX@0x40002403[libhookinunidbg.so]0x2403, md5=5eb63bbbe01eeed093cb22bb8f5acdc3, hex=68656c6c6f20776f726c64size: 110000: 68 65 6C 6C 6F 20 77 6F 72 6C 64 hello world^-----------------------------------------------------------------------------^wr1 11&gt;&gt;&gt; r1=0xb Console Debugger 支持下列写操作 123wr0-wr7, wfp, wip, wsp &lt;value&gt;: write specified registerwb(address), ws(address), wi(address) &lt;value&gt;: write (byte, short, integer) memory of specified address, address must start with 0xwx(address) &lt;hex&gt;: write bytes to memory at specified address, address must start with 0x 但这其实并不方便，还是做持久化比较舒服。 12345678910111213141516171819202122232425262728public void ReplaceArgByConsoleDebugger(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;base64_encode&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext context = emulator.getContext(); String fakeInput = &quot;hello world&quot;; int length = fakeInput.length(); // 修改r1值为新长度 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R1, length); MemoryBlock fakeInputBlock = emulator.getMemory().malloc(length, true); fakeInputBlock.getPointer().write(fakeInput.getBytes(StandardCharsets.UTF_8)); // 修改r0为指向新字符串的新指针 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, fakeInputBlock.getPointer().peer); Pointer buffer = context.getPointerArg(2); // OnLeave emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { String result = buffer.getString(0); System.out.println(&quot;base64 result:&quot;+result); return true; } }); return true; } });} Ⅲ 第三方Hook框架原理和Unicorn Hook完全不同，但得益于良好的封装，代码是类似的。 ① xHook 123456789101112131415161718192021222324252627public void ReplaceArgByXhook(){ IxHook xHook = XHookImpl.getInstance(emulator); xHook.register(&quot;libhookinunidbg.so&quot;, &quot;base64_encode&quot;, new ReplaceCallback() { @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) { String fakeInput = &quot;hello world&quot;; int length = fakeInput.length(); // 修改r1值为新长度 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R1, length); MemoryBlock fakeInputBlock = emulator.getMemory().malloc(length, true); fakeInputBlock.getPointer().write(fakeInput.getBytes(StandardCharsets.UTF_8)); // 修改r0为指向新字符串的新指针 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, fakeInputBlock.getPointer().peer); Pointer buffer = context.getPointerArg(2); context.push(buffer); return HookStatus.RET(emulator, originFunction); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) { Pointer buffer = context.pop(); System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }, true); // 使其生效 xHook.refresh();} ② HookZz 12345678910111213141516171819202122public void ReplaceArgByHookZz(){ IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz，支持inline hook hookZz.enable_arm_arm64_b_branch(); // 测试enable_arm_arm64_b_branch，可有可无 hookZz.wrap(module.findSymbolByName(&quot;base64_encode&quot;), new WrapCallback&lt;HookZzArm32RegisterContext&gt;() { @Override public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) { Pointer input = context.getPointerArg(0); String fakeInput = &quot;hello world&quot;; input.setString(0, fakeInput); context.setR1(fakeInput.length()); Pointer buffer = context.getPointerArg(2); context.push(buffer); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) { Pointer buffer = context.pop(); System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }); hookZz.disable_arm_arm64_b_branch();} 因为可以用HookZzArm32RegisterContext，相对来说代码简单一些。 2.修改返回值修改返回值的逻辑和替换参数并没什么区别，但它可以引出第四节，所以还是仔细讲一下。 在demo 中，有一个verifyApkSign函数，它总是返回1，并导致APK校验失败，因此目标就是让它返回0。 12345678910111213141516extern &quot;C&quot;JNIEXPORT void JNICALLJava_com_example_hookinunidbg_MainActivity_call(JNIEnv *env, jobject thiz) { int verifyret = verifyApkSign(); if(verifyret == 1){ LOGE(&quot;APK sign verify failed!&quot;); } else{ LOGE(&quot;APK sign verify success!&quot;); } testBase64();}extern &quot;C&quot; int verifyApkSign(){ LOGE(&quot;verify apk sign&quot;); return 1;}; ⅠFrida1234567891011121314151617181920212223// Frida Versionfunction main(){ // get base address of target so; var base_addr = Module.findBaseAddress(&quot;libhookinunidbg.so&quot;); if (base_addr){ var func_addr = Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;verifyApkSign&quot;); console.log(&quot;hook verifyApkSign function&quot;) Interceptor.attach(func_addr,{ onEnter: function (args) { }, onLeave: function (retval) { // 修改返回值为0 retval.replace(0); } }) }}setImmediate(main); Ⅱ Console Debugger123456789101112131415161718public void ReplaceRetByConsoleDebugger(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;verifyApkSign&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext context = emulator.getContext(); // OnLeave emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { // 修改返回值为0 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0); return true; } }); return true; } });} 我们的Hook生效了，但 verifyApkSign 函数里的log 还是打印出来了。在一些情况中，我们并不希望函数执行本来的逻辑，这就引出了第四节，即需要彻底的函数替换——替换并使用自己的函数。 四、替换函数1.Frida12345const verifyApkSignPtr = Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;verifyApkSign&quot;);Interceptor.replace(verifyApkSignPtr, new NativeCallback(() =&gt; { console.log(&quot;replace verifyApkSign Function&quot;) return 0;}, 'void', [])); Frida 这部分门道还挺多，但不是我们这里的重点。 2.第三方Hook框架这里只演示xHook 12345678910public void ReplaceFuncByHookZz(){ HookZz hook = HookZz.getInstance(emulator); hook.replace(module.findSymbolByName(&quot;verifyApkSign&quot;).getAddress(), new ReplaceCallback() { @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) { emulator.getBackend().reg_write(Unicorn.UC_ARM_REG_R0,0); return HookStatus.RET(emulator,context.getLR()); } });} xHook的版本很清晰易懂，我们做了两件事 R0 赋值为0 LR 赋值给 PC，这意味着函数一行不执行就返回了，又因为R0赋值0所以返回值为0。 3.Console Debugger123456789101112public void ReplaceFuncByConsoleDebugger(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;verifyApkSign&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { System.out.println(&quot;替换函数 verifyApkSign&quot;); RegisterContext registerContext = emulator.getContext(); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_PC, registerContext.getLRPointer().peer); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0); return true; } });} 非常清晰易懂。 五、Call 函数分析具体算法时，常需要对其进行主动调用，进行更灵活和细致的分析。举两个例子 1是主动调用base64_encode 函数 2是一个更复杂一些的函数。 1.Frida2.Unidbg六、Patch 与内存检索1.PatchPatch 就是直接对二进制文件进行修改，Patch本质上只有两种形式 patch 二进制文件 在内存里 patch Patch的应用场景很多，有时候比Hook更简单好用，所以要介绍它。Patch 二进制文件大家都很熟悉，在IDA中使用KeyPatch即可。但这里我们关注内存Patch。 0x8CA处调用了签名校验函数，第三四节中通过Replace返回值或函数的方式来处理它，但实际上，修改0x8CA处这条四字节指令也是好办法。 需要注意的是，本文只讨论了arm32，指令集只考虑最常见的thumb2，arm以及arm64可以自行测试。 ⅠFrida①方法一 12345678var str_name_so = &quot;libhookinunidbg.so&quot;; //要hook的so名var n_addr_func_offset = 0x8CA; //要hook的函数在函数里面的偏移,thumb要+1var n_addr_so = Module.findBaseAddress(str_name_so);var n_addr_assemble = n_addr_so.add(n_addr_func_offset);Memory.protect(n_addr_assemble, 4, 'rwx'); // 修改内存属性,使程序段可写n_addr_assemble.writeByteArray([0x00, 0x20, 0x00, 0xBF]); 但这并不是最佳代码，Patch存在两个问题 是否存在多个线程同时读写这块内存？是否有冲突 arm 的缓存刷新机制 所以Frida 提供了更安全可靠的API来修改内存中的字节 ②方法二 123456789101112131415161718var str_name_so = &quot;libhookinunidbg.so&quot;; //要hook的so名var n_addr_func_offset = 0x8CA; //要hook的函数在函数里面的偏移,thumb要+1var n_addr_so = Module.findBaseAddress(str_name_so);var n_addr_assemble = n_addr_so.add(n_addr_func_offset);// safely modify bytes at addressMemory.patchCode(n_addr_assemble, 4, function () { // 以 thumb的方式获取一个patch对象 var cw = new ThumbWriter(n_addr_assemble); // 小端序 // 00 20 cw.putInstruction(0x2000) // 00 BF cw.putInstruction(0xBF00); cw.flush(); // 内存刷新 console.log(hexdump(n_addr_assemble))}); Ⅱ UnidbgUnidbg在修改内存上，既可以传机器码，也可以传汇编指令，方法一和方法二其实没区别。 ①方法一 12345public void Patch1(){ // 00 20 00 bf int patchCode = 0xBF002000; // movs r0,0 emulator.getMemory().pointer(module.base + 0x8CA).setInt(0,patchCode);} ②方法二 1234public void Patch2(){ byte[] patchCode = {0x00, 0x20, 0x00, (byte) 0xBF}; emulator.getBackend().mem_write(module.base + 0x8CA, patchCode);} ③方法三 1234567public void Patch3(){ try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) { KeystoneEncoded encoded = keystone.assemble(&quot;movs r0,0;nop&quot;); byte[] patchCode = encoded.getMachineCode(); emulator.getMemory().pointer(module.base + 0x8CA).write(0, patchCode, 0, patchCode.length); }} 2.内存检索假设SO存在碎片化，比如要分析某个SO的多个版本，需要Patch签名校验或者某处汇编，其地址在不同版本中不一样，而且不是导出函数。内存检索+Patch就是一个好办法，可以很好适应多版本、碎片化。 搜索特征片段，可能是搜索函数开头十字节，也可能是搜索目标地址上下字节或者其他特征。 ⅠFrida123456789101112131415161718192021222324function searchAndPatch() { var module = Process.findModuleByName(&quot;libhookinunidbg.so&quot;); var pattern = &quot;80 b5 6f 46 84 b0 03 90 02 91&quot; var matches = Memory.scanSync(module.base, module.size, pattern); console.log(matches.length) if (matches.length !== 0) { var n_addr_assemble = matches[0].address.add(10); // safely modify bytes at address Memory.patchCode(n_addr_assemble, 4, function () { // 以 thumb的方式获取一个patch对象 var cw = new ThumbWriter(n_addr_assemble); // 小端序 // 00 20 cw.putInstruction(0x2000) // 00 BF cw.putInstruction(0xBF00); cw.flush(); // 内存刷新 console.log(hexdump(n_addr_assemble)) }); }}setImmediate(searchAndPatch); Ⅱ Unidbg12345678910111213141516171819202122232425262728public void SearchAndPatch(){ byte[] patterns = {(byte) 0x80, (byte) 0xb5,0x6f,0x46, (byte) 0x84, (byte) 0xb0,0x03, (byte) 0x90,0x02, (byte) 0x91}; Collection&lt;Pointer&gt; pointers = searchMemory(module.base, module.base+module.size, patterns); if(pointers.size() &gt; 0){ try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) { KeystoneEncoded encoded = keystone.assemble(&quot;movs r0,0;nop&quot;); byte[] patchCode = encoded.getMachineCode(); ((ArrayList&lt;Pointer&gt;) pointers).get(0).write(10, patchCode, 0, patchCode.length); } }}private Collection&lt;Pointer&gt; searchMemory(long start, long end, byte[] data) { List&lt;Pointer&gt; pointers = new ArrayList&lt;&gt;(); for (long i = start, m = end - data.length; i &lt; m; i++) { byte[] oneByte = emulator.getBackend().mem_read(i, 1); if (data[0] != oneByte[0]) { continue; } if (Arrays.equals(data, emulator.getBackend().mem_read(i, data.length))) { pointers.add(UnidbgPointer.pointer(emulator, i)); i += (data.length - 1); } } return pointers;} 值得一提的是，本节的内容也可用 LIEF Patch二进制文件实现。 七、Hook时机过晚问题上文中，Hook代码都位于 SO加载后， 执行JNI_OnLoad之前，和如下Frida代码Spawn注入进程等价。 123456789101112131415161718var android_dlopen_ext = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);if (android_dlopen_ext != null) { Interceptor.attach(android_dlopen_ext, { onEnter: function (args) { this.hook = false; var soName = args[0].readCString(); if (soName.indexOf(&quot;libhookinunidbg.so&quot;) !== -1) { this.hook = true; } }, onLeave: function (retval) { if (this.hook) { this.hook = false; // your code } } });} 而Unidbg Hook代码位于JNI_OnLoad后时，和如下Frida代码Spawn注入进程等价 123456789101112131415161718192021222324252627282930var android_dlopen_ext = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);if (android_dlopen_ext != null) { Interceptor.attach(android_dlopen_ext, { onEnter: function (args) { this.hook = false; var soName = args[0].readCString(); if (soName.indexOf(&quot;libhookinunidbg.so&quot;) !== -1) { this.hook = true; } }, onLeave: function (retval) { if (this.hook) { this.hook = false; var jniOnload = Module.findExportByName(&quot;libhookinunidbg.so&quot;,&quot;JNI_OnLoad&quot;); if(jniOnload != null){ Interceptor.attach(jniOnload, { onEnter:function(args){ console.log(&quot;Enter libkwsgmain JNIOnLoad&quot;) }, onLeave:function(retval){ console.log(&quot;After libkwsgmain JNIOnLoad&quot;); // your code } }); } } } });} 但如果**.init和.init_array段**存在代码逻辑（init→init_array→JNIOnLoad），我们想捕获这个时机，那么上述的时机点都太晚了，这种情况下就需要将Hook时机点提前到init执行前。在Frida中，为了实现这一点，通常做法是Hook Linker中的call_function或call_constructor函数。 以我们的demo hookInUnidbg为例，其中init段里就有如下逻辑，比较两个字符串的大小。 123456789101112131415161718192021222324252627// 编译生成后在.init段 [名字不可更改]extern &quot;C&quot; void _init(void) { char str1[15]; char str2[15]; int ret; strcpy(str1, &quot;abcdef&quot;); strcpy(str2, &quot;ABCDEF&quot;); ret = strcmp(str1, str2); if(ret &lt; 0) { LOGI(&quot;str1 小于 str2&quot;); } else if(ret &gt; 0) { LOGI(&quot;str1 大于 str2&quot;); } else { LOGI(&quot;str1 等于 str2&quot;); }} 当前显示str1 大于 str2，我们的Hook目标是让其显示 str1 小于 str2。如果还想之前那样，在JNIOnLoad之前下断，是断不下来的，因为时机太晚了，Unidbg中可以使用下面几个办法。 1.提前加载libc提前加载libc，然后hook strcmp函数，修改其返回值为-1是一个办法。如下是完整代码，提供了Console Debugger 以及 HookZz 两个版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.tutorial;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.hook.hookzz.*;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import unicorn.ArmConst;import java.io.File;public class hookInUnidbg { private final AndroidEmulator emulator; private final VM vm; private final Module module; private final Module moduleLibc; hookInUnidbg() { // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for32Bit().build(); // 模拟器的内存操作接口 final Memory memory = emulator.getMemory(); // 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); // 创建Android虚拟机 vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&quot;)); // 先加载libc.so DalvikModule dmLibc = vm.loadLibrary(new File(&quot;unidbg-android/src/main/resources/android/sdk23/lib/libc.so&quot;), true); moduleLibc = dmLibc.getModule(); // hook hookStrcmpByUnicorn(); // 或者 // hookStrcmpByHookZz(); // 加载so到虚拟内存 DalvikModule dm = vm.loadLibrary(&quot;hookinunidbg&quot;, true); // 加载好的 libhookinunidbg.so对应为一个模块 module = dm.getModule(); // 执行JNIOnLoad（如果有的话） dm.callJNI_OnLoad(emulator); } public void call(){ DvmClass dvmClass = vm.resolveClass(&quot;com/example/hookinunidbg/MainActivity&quot;); String methodSign = &quot;call()V&quot;; DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(null); dvmObject.callJniMethodObject(emulator, methodSign); } public static void main(String[] args) { hookInUnidbg mydemo = new hookInUnidbg(); mydemo.call(); } public void hookStrcmpByUnicorn(){ emulator.attach().addBreakPoint(moduleLibc.findSymbolByName(&quot;strcmp&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext registerContext = emulator.getContext(); String arg1 = registerContext.getPointerArg(0).getString(0); emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { if(arg1.equals(&quot;abcdef&quot;)){ emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, -1); } return true; } }); return true; } }); } public void hookStrcmpByHookZz(){ IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz，支持inline hook hookZz.enable_arm_arm64_b_branch(); // 测试enable_arm_arm64_b_branch，可有可无 hookZz.wrap(moduleLibc.findSymbolByName(&quot;strcmp&quot;), new WrapCallback&lt;HookZzArm32RegisterContext&gt;() { String arg1; @Override public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) { arg1 = ctx.getPointerArg(0).getString(0); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) { if(arg1.equals(&quot;abcdef&quot;)){ ctx.setR0(-1); } } }); hookZz.disable_arm_arm64_b_branch(); }} 但如果想hook的目标函数不是libc里的函数，就没效果了。比如想在0x978下个断点。 2.固定地址下断点这是最常用也最方便的方式，但只有Unicorn引擎下可以使用。 通过 vm.loadLibrary 加载的第一个用户SO，其基地址是0x40000000，因此可以在IDA中看函数偏移，通过绝对地址Console Debugger Hook。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.tutorial;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.hook.hookzz.*;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import unicorn.ArmConst;import java.io.File;public class hookInUnidbg { private final AndroidEmulator emulator; private final VM vm; private final Module module; private Module moduleLibc; hookInUnidbg() { // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for32Bit().build(); // 模拟器的内存操作接口 final Memory memory = emulator.getMemory(); // 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); // 创建Android虚拟机 vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&quot;)); emulator.attach().addBreakPoint(0x40000000 + 0x978); // 加载so到虚拟内存 DalvikModule dm = vm.loadLibrary(&quot;hookinunidbg&quot;, true); // 加载好的 libhookinunidbg.so对应为一个模块 module = dm.getModule(); // 执行JNIOnLoad（如果有的话） dm.callJNI_OnLoad(emulator); } public void call(){ DvmClass dvmClass = vm.resolveClass(&quot;com/example/hookinunidbg/MainActivity&quot;); String methodSign = &quot;call()V&quot;; DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(null); dvmObject.callJniMethodObject(emulator, methodSign); } public static void main(String[] args) { hookInUnidbg mydemo = new hookInUnidbg(); mydemo.call(); } } 如果加载了多个用户SO，可以先运行一遍代码，确认目标SO的基地址（Unidbg中不存在地址随机化，目标函数每次地址都固定。）然后在loadLibrary前Hook该地址，即可保证Hook不遗漏。 3.使用Unidbg提供的模块监听器实现自己的模块监听器 12345678910111213141516171819202122232425262728293031package com.tutorial;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.ModuleListener;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.hook.hookzz.HookEntryInfo;import com.github.unidbg.hook.hookzz.HookZz;import com.github.unidbg.hook.hookzz.InstrumentCallback;public class MyModuleListener implements ModuleListener { private HookZz hook; @Override public void onLoaded(Emulator&lt;?&gt; emulator, Module module) { // 提前加载Hook框架 if(module.name.equals(&quot;libc.so&quot;)){ hook = HookZz.getInstance(emulator); } // 在目标函数中Hook if(module.name.equals(&quot;libhookinunidbg.so&quot;)){ hook.instrument(module.base + 0x978 + 1, new InstrumentCallback&lt;RegisterContext&gt;() { @Override public void dbiCall(Emulator&lt;?&gt; emulator, RegisterContext ctx, HookEntryInfo info) { System.out.println(ctx.getIntArg(0)); } }); } }} 通过memory.addModuleListener绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.tutorial;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import java.io.File;public class hookInUnidbg{ private final AndroidEmulator emulator; private final VM vm; hookInUnidbg() { // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for32Bit().build(); // 模拟器的内存操作接口 final Memory memory = emulator.getMemory(); // 添加模块加载监听器 memory.addModuleListener(new MyModuleListener()); // 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); // 创建Android虚拟机 vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&quot;)); // 加载so到虚拟内存 DalvikModule dm = vm.loadLibrary(&quot;hookinunidbg&quot;, true); // 加载好的 libhookinunidbg.so对应为一个模块 Module module = dm.getModule(); // 执行JNIOnLoad（如果有的话） dm.callJNI_OnLoad(emulator); } public void call(){ DvmClass dvmClass = vm.resolveClass(&quot;com/example/hookinunidbg/MainActivity&quot;); String methodSign = &quot;call()V&quot;; DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(null); dvmObject.callJniMethodObject(emulator, methodSign); } public static void main(String[] args) { hookInUnidbg mydemo = new hookInUnidbg(); mydemo.call(); }} 每种方法都有对应使用场景，按需使用。除此之外也可以修改Unidbg源码，在 callInitFunction函数前添加自己的逻辑。 八、条件断点在算法分析时，条件断点可以减少干扰信息。以strcmp为例，整个进程的所有模块都可能调用strcmp函数。 1.限定于某SOⅠFrida123456789101112Interceptor.attach( Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;), { onEnter: function(args) { var moduleName = Process.getModuleByAddress(this.returnAddress).name; console.log(&quot;strcmp arg1:&quot;+args[0].readCString()) // 可以根据moduleName筛选打印 console.log(&quot;call from :&quot;+moduleName) }, onLeave: function(ret) { } }); Ⅱ Unidbg123456789101112131415public void hookstrcmp(){ long address = module.findSymbolByName(&quot;strcmp&quot;).getAddress(); emulator.attach().addBreakPoint(address, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext registerContext = emulator.getContext(); String arg1 = registerContext.getPointerArg(0).getString(0); String moduleName = emulator.getMemory().findModuleByAddress(registerContext.getLRPointer().peer).name; if(moduleName.equals(&quot;libhookinunidbg.so&quot;)){ System.out.println(&quot;strcmp arg1:&quot;+arg1); } return true; } });} 在Unidbg中，“Hook限定于目标SO内”的使用场景可能不那么多，因为Unidbg虚拟进程里只有我们的目标SO在活跃，但Android系统中，目标进程里可能有数十个模块。当我们想hook strlen 来窥探目标SO里的字符串操作时，如果不加筛选，会被其他模块的大量调用干扰。或者我们想替换pthread_create函数，观察或者阻止子线程创建的时候，也会发现libart等模块也在创建子线程，除此之外替换时间等操作也都要注意这个问题。 123456789101112131415// 替换目标函数里对pthread_create的访问function hookPthreadCreate(){ var p_pthread_create = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;); var pthread_create = new NativeFunction( p_pthread_create, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]); Interceptor.replace( p_pthread_create, new NativeCallback(function (ptr0, ptr1, ptr2, ptr3) { var moduleName = Process.getModuleByAddress(this.returnAddress).name; if (moduleName === &quot;target.so&quot;) { console.log(&quot;loading fake pthread_create&quot;); return -1; } else { return pthread_create(ptr0,ptr1,ptr2,ptr3); } }, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]));} 2.限定于某函数比如某个函数在SO中被大量使用，现在只想分析这个函数在函数A中的使用。 ⅠFrida123456789101112131415161718192021222324var show = false;Interceptor.attach( Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;), { onEnter: function(args) { if(show){ console.log(&quot;strcmp arg1:&quot;+args[0].readCString()) } }, onLeave: function(ret) { } });Interceptor.attach( Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;targetfunction&quot;),{ onEnter: function(args) { show = this; }, onLeave: function(ret) { show = false; } }) Ⅱ Unidbg1234567891011121314151617181920212223242526272829303132// 早先声明全局变量 public boolean show = false;public void hookstrcmp(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;targetfunction&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext registerContext = emulator.getContext(); show = true; emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { show = false; return true; } }); return true; } }); emulator.attach().addBreakPoint(module.findSymbolByName(&quot;strcmp&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext registerContext = emulator.getContext(); String arg1 = registerContext.getPointerArg(0).getString(0); if(show){ System.out.println(&quot;strcmp arg1:&quot;+arg1); } return true; } });} 3.限定于某处 比如上图，只关注0xA00 处发生的strcmp。一个办法是hook strcmp函数，只在lr寄存器=module.base + 0xA00 + 4 + 1时打印输出。 另一个办法是Console Debugger ,也很方便。 12emulator.attach().addBreakPoint(module, 0xA00);emulator.attach().addBreakPoint(module, 0xA04); 一定要掌握这些知识，并做到灵活变通。在实际使用中，诸如“A hook生效后再打印B函数的输出“这样的需求是很常见的，否则每个函数都打印成百上千行会迷人眼，干扰对关键信息的寻找。 九、系统调用拦截——以时间为例这里说的系统调用拦截，并不是要对系统调用进行Hook，比如 frida - syscall - intercceptor 这样，系统调用全部是Unidbg自己实现的，日志一开就能看，显然也没有Hook的必要。Unidbg的系统调用拦截是为了替换系统调用，修改Unidbg中系统调用的实现。 有两个问题需要解释 为什么要修改系统调用？ Unidbg中部分系统调用没实现或者没实现好，以及有时候想要固定其输出，比如获取时间的系统调用，这些需求需要我们修复或修改Unidbg中系统调用的实现。 为什么不直接修改Unidbg源码 1是灵活性较差，2是我们的实现或修改并不是完美的，直接改Unidbg源码是对运行环境的污染，影响其他项目。 在分析算法时，输入不变的前提下，如果输出在不停变化，会干扰算法分析，这种情况的一大来源是时间戳参与了运算。在Frida中，为了控制这种干扰因素，常常会Hook libc的gettimeodfay这个时间获取函数。 1.Fridahook time 123456789101112var time = Module.findExportByName(null, &quot;time&quot;);if (time != null) { Interceptor.attach(time, { onEnter: function (args) { }, onLeave: function (retval) { // time返回秒级时间戳，修改返回值为100 retval.replace(100); } })} hook gettimeofday 1234567891011121314151617function hook_gettimeofday() { var addr_gettimeofday = Module.findExportByName(null, &quot;gettimeofday&quot;); var gettimeofday = new NativeFunction(addr_gettimeofday, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); Interceptor.replace(addr_gettimeofday, new NativeCallback(function (ptr_tz, ptr_tzp) { var result = gettimeofday(ptr_tz, ptr_tzp); if (result == 0) { console.log(&quot;hook gettimeofday:&quot;, ptr_tz, ptr_tzp, result); var t = new Int32Array(ArrayBuffer.wrap(ptr_tz, 8)); t[0] = 0xAAAA; t[1] = 0xBBBB; console.log(hexdump(ptr_tz)); } return result; }, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]));} 但Frida做这件事并不容易做圆满，单是libc.so，就有time、gettimeodfay、clock_gettime、clock 这四个库函数可以获取时间戳，而且样本可以通过内联汇编使用系统调用，获取时间戳。 2.UnidbgUnidbg中可以更方便、更大范围的固定时间，不必像Frida那般。time和gettimeodfay库函数基于gettimeodfay这个系统调用，clock_gettime和clock基于clock_gettime系统调用。所以只要在Unidbg中固定gettimeodfay和clock_gettime这两个系统调用获取的时间戳，就可以一劳永逸。 首先实现时间相关的系统调用处理器，其中的*System.currentTimeMillis()和System.nanoTime()*改成定数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.tutorial;import com.github.unidbg.Emulator;import com.github.unidbg.linux.ARM32SyscallHandler;import com.github.unidbg.memory.SvcMemory;import com.github.unidbg.pointer.UnidbgPointer;import com.github.unidbg.unix.struct.TimeVal32;import com.github.unidbg.unix.struct.TimeZone;import com.sun.jna.Pointer;import unicorn.ArmConst;import java.util.Calendar;public class TimeSyscallHandler extends ARM32SyscallHandler { public TimeSyscallHandler(SvcMemory svcMemory) { super(svcMemory); } @Override protected boolean handleUnknownSyscall(Emulator emulator, int NR) { switch (NR) { case 78: // gettimeofday mygettimeofday(emulator); return true; case 263: // clock_gettime myclock_gettime(emulator); return true; } return super.handleUnknownSyscall(emulator, NR); } private void mygettimeofday(Emulator&lt;?&gt; emulator) { Pointer tv = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0); Pointer tz = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, mygettimeofday(tv, tz)); }; private int mygettimeofday(Pointer tv, Pointer tz) { long currentTimeMillis = System.currentTimeMillis(); long tv_sec = currentTimeMillis / 1000; long tv_usec = (currentTimeMillis % 1000) * 1000; TimeVal32 timeVal = new TimeVal32(tv); timeVal.tv_sec = (int) tv_sec; timeVal.tv_usec = (int) tv_usec; timeVal.pack(); if (tz != null) { Calendar calendar = Calendar.getInstance(); int tz_minuteswest = -(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 1000); TimeZone timeZone = new TimeZone(tz); timeZone.tz_minuteswest = tz_minuteswest; timeZone.tz_dsttime = 0; timeZone.pack(); } return 0; } private static final int CLOCK_REALTIME = 0; private static final int CLOCK_MONOTONIC = 1; private static final int CLOCK_THREAD_CPUTIME_ID = 3; private static final int CLOCK_MONOTONIC_RAW = 4; private static final int CLOCK_MONOTONIC_COARSE = 6; private static final int CLOCK_BOOTTIME = 7; private final long nanoTime = System.nanoTime(); private int myclock_gettime(Emulator&lt;?&gt; emulator) { int clk_id = emulator.getBackend().reg_read(ArmConst.UC_ARM_REG_R0).intValue(); Pointer tp = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1); long offset = clk_id == CLOCK_REALTIME ? System.currentTimeMillis() * 1000000L : System.nanoTime() - nanoTime; long tv_sec = offset / 1000000000L; long tv_nsec = offset % 1000000000L; switch (clk_id) { case CLOCK_REALTIME: case CLOCK_MONOTONIC: case CLOCK_MONOTONIC_RAW: case CLOCK_MONOTONIC_COARSE: case CLOCK_BOOTTIME: tp.setInt(0, (int) tv_sec); tp.setInt(4, (int) tv_nsec); return 0; case CLOCK_THREAD_CPUTIME_ID: tp.setInt(0, 0); tp.setInt(4, 1); return 0; } throw new UnsupportedOperationException(&quot;clk_id=&quot; + clk_id); }} 在自己的模拟器上使用它，原先模拟器创建是这么一句 12// 创建模拟器实例emulator = AndroidEmulatorBuilder.for32Bit().build(); 修改如下 123456789101112131415// 创建模拟器实例AndroidEmulatorBuilder builder = new AndroidEmulatorBuilder(false) { public AndroidEmulator build() { return new AndroidARMEmulator(processName, rootDir, backendFactories) { @Override protected UnixSyscallHandler&lt;AndroidFileIO&gt; createSyscallHandler(SvcMemory svcMemory) { return new TimeSyscallHandler(svcMemory); } }; }};emulator = builder.build(); 十、Hook 检测Anti Unidbg的方法浩如烟海，但事实上几乎没有主动Anti Unidbg的样本，有两方面原因 Unidbg 自身的多个重大弱点没有解决，比如多线程和信号机制尚未实现。 Unidbg 普及率和推广度还不高。 所以本节专注于Hook 检测。 1.检测第三方Hook框架基于其Hook实现原理，可以对应检测。 ⅠInline Hook以我熟悉的inline Hook 检测为例，inline Hook 需要修改Hook处的前几个字节，跳转到自己的地方实现逻辑，最后再跳转回来。那么就有两类思路实现检测，首先开辟一个检测线程，对关键函数做如下二选一循环操作 函数开头前几个字节是否被篡改 函数体是否完整未被修改，常使用crc32校验，为什么不用md5或其他哈希函数？因为crc32极快，性能影响小，碰撞率又在可接受的范围内 相关项目：check_fish_inline_hook Ⅱ Got Hook相关项目：SliverBullet5563/CheckGotHook: 检测got hook（使用xhook测试） 2.检测Unicorn Based HookUnicorn Hook 似乎不可检测，但Unicorn也是可检测的。在星球的Anti-Unidbg系列，就提到过一种检测方式。在Android系统中，只支持对四字节对齐的内存地址做读写操作，所以通过内联汇编尝试向SP+1的位置做读写，在真机上会导致App崩溃，而Unidbg模拟执行不会出任何问题。当然，我们并不希望App崩溃，所以需要在代码中实现自己的信号处理函数，当此处发生异常时，信号处理函数接收信号并做出某种处理，因为Unidbg中程序不会异常，所以也不会走到信号处理函数，这里面可以设计形成差异。 除此之外，Unicorn下断点调试或者做指令追踪时，必然会导致函数运行时间超出常理，基于运行时间的反调试策略也可行。 十一、Unidbg Trace 五件套基于Frida 存在许多trace 方案，比如用于 trace JNI函数的 JNItrace，用于trace Java调用的 ZenTrace、r0tracer，又或者是官方的多功能 trace 工具 frida-trace，用于指令级 trace 的 Frida Stalker，又或者是trace SO中所有函数的 trace_natives ，以及Linux上著名的strace 或者 基于Frida 的 frida-syscall-interceptor，用于 trace 系统调用。 在Unidbg 上，上述的大部分trace，只需要调整日志等级就能实现。我们这里所讲的trace，聚焦于如何让使用者对代码执行流有更强的掌控。 1.Instruction tracing令追踪包括两部分 记录每条指令的执行，打印地址、机器码、汇编等信息 打印每条指令相关的寄存器值 Unidbg 基于 Unicorn CodeHook 封装了指令追踪，方法和效果如下 1234567/** * trace instruction * note: low performance */TraceHook traceCode();TraceHook traceCode(long begin, long end);TraceHook traceCode(long begin, long end, TraceCodeListener listener); Unidbg的指令追踪，在第一部分的工作做得很好，采用 模块名+相对偏移+机器码+绝对地址+汇编 的展示形式，但美中不足的是，它并没有做第二部分的工作，可以使用如下的脚本在Unidbg中实现完善的指令追踪，其原理也是实现了一个自己的codehook。 增加trace的部分 by dqzg12300 · Pull Request #214 2.Function Tracing指令Trace是最细粒度的Trace，优点是细，缺点是动辄数百上千万行，让人迷失其中。函数粒度的trace则不然，粗糙但容易理解全貌，在算法还原的一些场景中会起到帮助。在IDA Debug中，即可选择函数追踪来记录函数调用，包括了有符号函数以及IDA识别并命名为Sub_addr的子函数。 在Frida上，可以使用 trace_natives 对 一个SO中的全部函数进行Trace，并形成如下调用图。 Unidbg中可以做到这一点吗？不妨看一下 Frida trace_natives 脚本，其中有三个关注点。 如何获得一个SO的全部函数列表，就像IDA一样 如何Hook函数 如何获得调用层级关系，形成树结构 关于问题1，trace_natives怎么解决的？直接编写IDA脚本获取IDA的函数列表 12345678910def getFunctionList(): functionlist = &quot;&quot; minLength = 10 maxAddress = ida_ida.inf_get_max_ea() for func in idautils.Functions(0, maxAddress): if len(list(idautils.FuncItems(func))) &gt; minLength: functionName = str(idaapi.ida_funcs.get_func_name(func)) oneFunction = hex(func) + &quot;!&quot; + functionName + &quot;\\t\\n&quot; functionlist += oneFunction return functionlist 脚本获取了函数以及对应函数名列表，同时通过minLength过滤较短的函数，至少包含10条汇编指令的函数才会被计入。这么做有两个原因 过短的函数可能导致Frida Hook失败（inline hook 原理所致） 过短的函数可能是工具函数，调用次数多，但价值不大，让调用图变得臃肿不堪 完整的IDA插件 getFunctions 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import osimport timeimport ida_idaimport ida_naltimport idaapiimport idautilsfrom idaapi import plugin_tfrom idaapi import PLUGIN_PROCfrom idaapi import PLUGIN_OKdef getFunctionList(): functionlist = &quot;&quot; minLength = 10 maxAddress = ida_ida.inf_get_max_ea() for func in idautils.Functions(0, maxAddress): if len(list(idautils.FuncItems(func))) &gt; minLength: functionName = str(idaapi.ida_funcs.get_func_name(func)) oneFunction = hex(func) + &quot;!&quot; + functionName + &quot;\\t\\n&quot; functionlist += oneFunction return functionlist# 获取SO文件名和路径def getSoPathAndName(): fullpath = ida_nalt.get_input_file_path() filepath, filename = os.path.split(fullpath) return filepath, filenameclass getFunctions(plugin_t): flags = PLUGIN_PROC comment = &quot;getFunctions&quot; help = &quot;&quot; wanted_name = &quot;getFunctions&quot; wanted_hotkey = &quot;&quot; def init(self): print(&quot;getFunctions(v0.1) plugin has been loaded.&quot;) return PLUGIN_OK def run(self, arg): so_path, so_name = getSoPathAndName() functionlist = getFunctionList() script_name = so_name.split(&quot;.&quot;)[0] + &quot;_functionlist_&quot; + str(int(time.time())) + &quot;.txt&quot; save_path = os.path.join(so_path, script_name) with open(save_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as F: F.write(functionlist) F.close() print(f&quot;location: {save_path}&quot;) def term(self): passdef PLUGIN_ENTRY(): return getFunctions() 关于问题2：使用Frida Native Hook 关于问题3：Frida的frida-trace自带调用层级关系，所以trace_Natives脚本依赖Frida-trace，展示出了树结构的调用图。分析源码发现，frida-trace 使用了Frida在 Interceptor.attach 环境中的depth 如下代码中的this.depth），depth表示了调用深度。那深度的值哪来的呢？其最终依赖于Frida的栈回溯。 123456789101112131415161718192021222324Interceptor.attach(Module.getExportByName(null, 'read'), { onEnter(args) { console.log('Context information:'); console.log('Context : ' + JSON.stringify(this.context)); console.log('Return : ' + this.returnAddress); console.log('ThreadId : ' + this.threadId); console.log('Depth : ' + this.depth); console.log('Errornr : ' + this.err); // Save arguments for processing in onLeave. this.fd = args[0].toInt32(); this.buf = args[1]; this.count = args[2].toInt32(); }, onLeave(result) { console.log('----------') // Show argument 1 (buf), saved during onEnter. const numBytes = result.toInt32(); if (numBytes &gt; 0) { console.log(hexdump(this.buf, { length: numBytes, ansi: true })); } console.log('Result : ' + numBytes); }}) 这三个问题能在Unidbg中解决吗？如果能解决，那就有了Unidbg 版的Function Tracing。 首先问题一，只是一个获取函数列表的插件，与使用Frida还是Unidbg无关，构不成问题。我们还可以更进一步思考，trace_Natives 依赖IDA实现对SO 函数的识别，但与此同时也增加了使用的复杂度，而且加壳的SO无法直接识别函数，必须得先dump+fix SO，其实还挺折腾人，不如不依赖IDA，换个办法识别函数。ARM中，函数序言常常以 push 指令开始，这可以代表绝大多数函数。配合Unidbg的BlockHook 或者 CodeHook，就可以解析并 Hook 这些函数，问题二也顺带解决了。少部分函数会遗漏，但也无关痛痒。BlockHook 还会提供当前基本块的大小，我们设置对较小的块不予理睬。 接下来就是问题三，栈回溯这块，Unidbg也实现了arm unwind栈回溯，一些情况下有Bug，但总体应该能用。但Unidbg没有提供打印深度的函数，在Unwinder类中添加一个它。 src/main/java/com/github/unidbg/unwind/Unwinder.java 1234567891011public final int depth(){ int count = 0; Frame frame = null; while((frame = unw_step(emulator, frame)) != null) { if(frame.isFinish()){ return count; } count++; } return count;} 接下来三步骤合一，组装代码 12345678910111213141516171819202122232425262728293031323334353637PrintStream traceStream = null;try { // 保存文件 String traceFile = &quot;unidbg-android/src/test/resources/app/traceFunctions.txt&quot;; traceStream = new PrintStream(new FileOutputStream(traceFile), true);} catch (FileNotFoundException e) { e.printStackTrace();}final PrintStream finalTraceStream = traceStream;emulator.getBackend().hook_add_new(new BlockHook() { @Override public void hookBlock(Backend backend, long address, int size, Object user) { if(size&gt;8){ Capstone.CsInsn[] insns = emulator.disassemble(address, 4, 0); if(insns[0].mnemonic.equals(&quot;push&quot;)){ int level = emulator.getUnwinder().depth(); assert finalTraceStream != null; for(int i = 0 ; i &lt; level ; i++){ finalTraceStream.print(&quot; | &quot;); } finalTraceStream.println(&quot; &quot;+&quot;sub_&quot;+Integer.toHexString((int) (address-module.base))+&quot; &quot;); } } } @Override public void onAttach(Unicorn.UnHook unHook) { } @Override public void detach() { }}, module.base, module.base+module.size, 0); 可以发现代码非常的简洁优雅，效果也不错 它还有三个明显的缺陷 1是时机过晚，init或者init_arrayz里的内容无法Hook到，可以结合第七节的方法进行完善。 2是有符号的函数也以sub_xxx 显示 3是导入表中的函数无法包括在内，因为原理上讲，只扫描so内push开头的函数。 3.Memory Search4.Unidbg-FindKeyUnidbg_FindKey 这是我写的小工具，具体原理见星球，目前支持查找AES-128/AES-256的密钥，理论上还可以将更多的加密算法包括进去，只需要算法满足以下三点： 1.程序的预处理（最典型的场景即密钥编排）会产生某个结构 2.这个结构是可分辨的 3.这个结构可以解码出原始Key AES完美符合这三点，SM4也很适用，过往的研究表明，DES、RSA、TwoFish、Separnt等加密算法都满足或者部分满足上述三条件。 5.Unidbg-FindcryptFindcrypt是老牌经典工具，Unidbg版的Findcrypt是要做啥？解决什么痛点？有三个主要原因 Findcrypt 处理不了加壳SO Findcrypt 中说存在某种加密，但SO中并不一定用，我们的目标函数更不一定用。 从Findcrypt提示的常数不一定能找到对应函数，静态交叉分析有局限 // TODO 十二、固定随机数// TODO 十三、杂项无需Hook，Unidbg中通过其他方式实现 // TODO","link":"/20220106/Hook-All-In-Unidbg/"},{"title":"某外买APP设备指纹风控分析","text":"本文章转自看雪论坛 “我是小三” 如有侵权,请作者联系删除.(由于原作者发帖不久被删帖,故转发该贴到本个人博客) 一、电商类APP业务风险类型电商行业的各个业务场景面临不同的风险种类：客户端漏洞利用、协议逆向、注册小号、商品信息被抓取、推广渠道作弊、营销活动被薅羊毛、商品秒杀等。大多的防御方案是通过端上安全、链路安全、接口和数据传输安全保护，再借助设备安全核验技术、人机识别及时发现各种模拟行为和异操作风险、同时集合风控策略实现多节点防护。 二、设备指纹在业务中的应用设备指纹技术是使用更多的信息来完成对终端设备的唯一性识别，在业务中可以有效辨别设备是真实用户还是机器在注册、登录，及时检测出单设备登入多帐号、防止批量注册、登录等操作行为。 三、整体框架因为框架流程过于复杂，我将框架分为两个部分，一是初始化，二是设备指纹，这样会更清楚些，如图3-1与3-2所示： 四、初始化流程分析4.1、初始化准备java层调用init()初始化，获取Context，包名，AppInfo，XML配置信息等，然后加载so libmtguard.so 在so中注册一个Native方法，该Native方法传入不同的数字代表不同的功能，代码如下所示： 1234Lcom/meituan/android/common/mtguard/MTGuard;-&gt;loadSo(Ljava/lang/String;)VSystem.loadLibrary(&quot;mtguard&quot;);//注册Native方法private static native Object[] main(int arg0, Object[] arg1)//arg0:传入不同的编号走不同的逻辑，arg1:参数 4.2、系统环境检测调用Native层Object[] v12_2 = NBridge.main3(1, new Object[1])，传入参数为1,表示检测环境， 检测系统目录中是否有ls文件且是否为elf格式: 123456789101112131415161718192021222324252627282930313233343536373839404142.text:B1BF744E 01 26 MOVS R6, #1.text:B1BF7450 2E 70 STRB R6, [R5].text:B1BF7452 20 48 LDR R0, =(aSystemBinLs - 0xB1BF7458) ; &quot;/system/bin/ls&quot;.text:B1BF7454 78 44 ADD R0, PC ; &quot;/system/bin/ls&quot; ; file.text:B1BF7456 00 25 MOVS R5, #0.text:B1BF7458 29 00 MOVS R1, R5 ; oflag.text:B1BF745A CF F7 A0 EC BLX open.text:B1BF745E 04 00 MOVS R4, R0.text:B1BF7460 00 2C CMP R4, #0.text:B1BF7462 25 DB BLT loc_B1BF74B0.text:B1BF7464 01 AD ADD R5, SP, #0x28+buf.text:B1BF7466 14 22 MOVS R2, #0x14 ; nbytes.text:B1BF7468 20 00 MOVS R0, R4 ; fd.text:B1BF746A 29 00 MOVS R1, R5 ; buf.text:B1BF746C CF F7 10 EE BLX read.text:B1BF7470 14 28 CMP R0, #0x14.text:B1BF7472 18 D1 BNE loc_B1BF74A6.text:B1BF7474 28 78 LDRB R0, [R5].text:B1BF7476 7F 28 CMP R0, #0x7F.text:B1BF7478 15 D1 BNE loc_B1BF74A6.text:B1BF747A 01 A8 ADD R0, SP, #0x28+buf.text:B1BF747C 40 78 LDRB R0, [R0,#1].text:B1BF747E 45 28 CMP R0, #0x45 ; 'E'.text:B1BF7480 11 D1 BNE loc_B1BF74A6.text:B1BF7482 01 A8 ADD R0, SP, #0x28+buf.text:B1BF7484 80 78 LDRB R0, [R0,#2].text:B1BF7486 4C 28 CMP R0, #0x4C ; 'L'.text:B1BF7488 0D D1 BNE loc_B1BF74A6.text:B1BF748A 01 A8 ADD R0, SP, #0x28+buf.text:B1BF748C C0 78 LDRB R0, [R0,#3].text:B1BF748E 46 28 CMP R0, #0x46 ; 'F'.text:B1BF7490 09 D1 BNE loc_B1BF74A6.text:B1BF7492 01 A8 ADD R0, SP, #0x28+buf.text:B1BF7494 80 7C LDRB R0, [R0,#0x12].text:B1BF7496 3E 28 CMP R0, #0x3E ; '&gt;'.text:B1BF7498 01 D0 BEQ loc_B1BF749E.text:B1BF749A 03 28 CMP R0, #3.text:B1BF749C 03 D1 BNE loc_B1BF74A6.text:B1BF749E.text:B1BF749E loc_B1BF749E.text:B1BF749E 20 00 MOVS R0, R4 ; fd.text:B1BF74A0 CF F7 88 EC BLX close 检测XPOSED、代理、ROM是否为自己编译的 1234567//检测de.robv.android.xposed.XposedBridge //检测代理http.proxyHosthttps.proxyHostgetProperty 检测关键方法是否被hook 12345678//检测方法是否被hook传入方法首地址进行对比 0x780x5F 0xF8DF//如果检测到第一个方法被hook，结果如下1|如果检测到第2个方法被hook，结果如下1|2|如果检测到第3个方法被hook，结果如下1|2|3| 其它检测，代码如下: 1234567891011121314boolean v2 = MTGuard.isEmu();boolean v3 = MTGuard.isRoot();boolean v4 = MTGuard.hasMalware();boolean v5 = MTGuard.isDarkSystem();boolean v6 = MTGuard.isVirtualLocation();boolean v7 = MTGuard.isRemoteCall();boolean v8 = MTGuard.isSigCheckOK();boolean v11 = MTGuard.inSandBox();boolean v13 = MTGuard.isHook();boolean v14 = MTGuard.isDebug();boolean v15 = MTGuard.isProxy();boolean v16 = MTGuard.isCameraHack();最终都会走到Native方法中去private static native Object[] main(int arg0, Object[] arg1); 4.3、读取资源文件并解密4.3.1、读文件META-INF/SANKUAI.RSA计算MD5代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172.text:B65E1FE4 F0 B5 PUSH {R4-R7,LR}.text:B65E1FE6 03 AF ADD R7, SP, #0xC.text:B65E1FE8 8F B0 SUB SP, SP, #0x3C.text:B65E1FEA 0E 00 MOVS R6, R1.text:B65E1FEC 2D 49 LDR R1, =(__stack_chk_guard_ptr - 0xB65E1FF2).text:B65E1FEE 79 44 ADD R1, PC ; __stack_chk_guard_ptr.text:B65E1FF0 0C 68 LDR R4, [R1] ; __stack_chk_guard.text:B65E1FF2 21 68 LDR R1, [R4].text:B65E1FF4 0E 91 STR R1, [SP,#0x48+var_10].text:B65E1FF6 0A 21 MOVS R1, #0xA.text:B65E1FF8 CA 43 MVNS R2, R1.text:B65E1FFA 01 68 LDR R1, [R0] ; file.text:B65E1FFC 48 1E SUBS R0, R1, #1.text:B65E1FFE 82 58 LDR R2, [R0,R2].text:B65E2000 00 25 MOVS R5, #0.text:B65E2002 E8 43 MVNS R0, R5.text:B65E2004 00 2A CMP R2, #0.text:B65E2006 43 D0 BEQ loc_B65E2090.text:B65E2008 00 25 MOVS R5, #0.text:B65E200A 05 95 STR R5, [SP,#0x48+var_34].text:B65E200C 04 90 STR R0, [SP,#0x48+var_38].text:B65E200E 06 90 STR R0, [SP,#0x48+var_30].text:B65E2010 07 95 STR R5, [SP,#0x48+var_2C].text:B65E2012 08 90 STR R0, [SP,#0x48+var_28].text:B65E2014 0C 90 STR R0, [SP,#0x48+var_18].text:B65E2016 0D 95 STR R5, [SP,#0x48+var_14].text:B65E2018 E8 43 MVNS R0, R5.text:B65E201A 0B 90 STR R0, [SP,#0x48+var_1C].text:B65E201C 0A 90 STR R0, [SP,#0x48+var_20].text:B65E201E 04 A8 ADD R0, SP, #0x48+var_38 ; int.text:B65E2020 0D F0 40 FF BL openfile_sub_C6BADEA4 ; R3：要读取的文件.text:B65E2024 01 30 ADDS R0, #1.text:B65E2026 30 D0 BEQ loc_B65E208A.text:B65E2028 02 96 STR R6, [SP,#0x48+var_40].text:B65E202A 04 A8 ADD R0, SP, #0x48+var_38.text:B65E202C 1E 49 LDR R1, =(sub_B65E20AC+1 - 0xB65E2032).text:B65E202E 79 44 ADD R1, PC ; sub_B65E20AC.text:B65E2030 0E F0 C8 F9 BL size_sub_C6BAE3C4.text:B65E2034 06 00 MOVS R6, R0.text:B65E2036 00 2E CMP R6, #0.text:B65E2038 27 D0 BEQ loc_B65E208A.text:B65E203A 00 25 MOVS R5, #0.text:B65E203C 03 95 STR R5, [SP,#0x48+byte_count].text:B65E203E 04 A8 ADD R0, SP, #0x48+var_38.text:B65E2040 03 AA ADD R2, SP, #0x48+byte_count.text:B65E2042 31 00 MOVS R1, R6.text:B65E2044 0E F0 2E FB BL read_sub_C6BAE6A4.text:B65E2048 03 99 LDR R1, [SP,#0x48+byte_count].text:B65E204A 00 29 CMP R1, #0.text:B65E204C 1D D0 BEQ loc_B65E208A.text:B65E204E 00 28 CMP R0, #0.text:B65E2050 1B D0 BEQ loc_B65E208A.text:B65E2052 08 00 MOVS R0, R1 ; byte_count.text:B65E2054 01 91 STR R1, [SP,#0x48+var_44].text:B65E2056 EF F7 48 EE BLX malloc ; 分配存放空间.text:B65E205A 02 00 MOVS R2, R0.text:B65E205C 00 28 CMP R0, #0.text:B65E205E 14 D0 BEQ loc_B65E208A.text:B65E2060 00 21 MOVS R1, #0.text:B65E2062 15 00 MOVS R5, R2.text:B65E2064 28 00 MOVS R0, R5.text:B65E2066 01 9A LDR R2, [SP,#0x48+var_44].text:B65E2068 16 F0 2A FA BL memset_sub_C6BB64C0.text:B65E206C 04 A8 ADD R0, SP, #0x48+var_38.text:B65E206E 31 00 MOVS R1, R6.text:B65E2070 2A 00 MOVS R2, R5.text:B65E2072 0E F0 6B FB BL ReadFile_unzip_sub_C6BAE74C ; 读取并解压.text:B65E2076 00 28 CMP R0, #0.text:B65E2078 03 D0 BEQ loc_B65E2082.text:B65E207A 03 98 LDR R0, [SP,#0x48+byte_count].text:B65E207C 02 99 LDR R1, [SP,#0x48+var_40].text:B65E207E 08 60 STR R0, [R1] 读取的数据与APk包中的内容是一样的。 12345678910111213B3C7B000 30 82 03 F5 06 09 2A 86 48 86 F7 0D 01 07 02 A0 0.......H.......B3C7B010 82 03 E6 30 82 03 E2 02 01 01 31 0F 30 0D 06 09 ..........1.0...B3C7B020 60 86 48 01 65 03 04 02 01 05 00 30 0B 06 09 2A `.H.e......0...*B3C7B030 86 48 86 F7 0D 01 07 01 A0 82 02 83 30 82 02 7F .H..........0...B3C7B040 30 82 01 E8 A0 03 02 01 02 02 04 4D 69 1B B8 30 0..........Mi..0B3C7B050 0D 06 09 2A 86 48 86 F7 0D 01 01 05 05 00 30 81 ...*.H........0.B3C7B060 82 31 0B 30 09 06 03 55 04 06 13 02 43 4E 31 10 .1.0...U....CN1.B3C7B070 30 0E 06 03 55 04 08 13 07 42 65 69 6A 69 6E 67 0...U....BeijingB3C7B080 31 10 30 0E 06 03 55 04 07 13 07 42 65 69 6A 69 1.0...U....BeijiB3C7B090 6E 67 31 24 30 22 06 03 55 04 0A 13 1B 53 61 6E ng1$0&quot;..U....SanB3C7B0A0 6B 75 61 69 20 54 65 63 68 6E 6F 6C 6F 67 79 20 kuai TechnologyB3C7B0B0 43 6F 2E 20 4C 74 64 2E 31 14 30 12 06 03 55 04 Co. Ltd.1.0...U.B3C7B0C0 0B 13 0B 6D 65 69 74 75 61 6E 2E 63 6F 6D 31 13 ...meituan.com1. 检测是否为RSA文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243.text:B65EFCBC isRSA_sub_CB471CBC.text:B65EFCBC ; __unwind { // FDA46000.text:B65EFCBC D0 B5 PUSH {R4,R6,R7,LR}.text:B65EFCBE 02 AF ADD R7, SP, #8.text:B65EFCC0 01 00 MOVS R1, R0.text:B65EFCC2 00 20 MOVS R0, #0.text:B65EFCC4 00 29 CMP R1, #0.text:B65EFCC6 1B D0 BEQ locret_B65EFD00.text:B65EFCC8 0A 78 LDRB R2, [R1].text:B65EFCCA 30 2A CMP R2, #0x30 ; '0'.text:B65EFCCC 18 D1 BNE locret_B65EFD00.text:B65EFCCE 01 22 MOVS R2, #1.text:B65EFCD0 8C 56 LDRSB R4, [R1,R2].text:B65EFCD2 7F 22 MOVS R2, #0x7F.text:B65EFCD4 22 40 ANDS R2, R4.text:B65EFCD6 FF 23 MOVS R3, #0xFF.text:B65EFCD8 23 40 ANDS R3, R4.text:B65EFCDA 00 2C CMP R4, #0.text:B65EFCDC 00 DB BLT loc_B65EFCE0.text:B65EFCDE 1A 00 MOVS R2, R3.text:B65EFCE0.text:B65EFCE0 loc_B65EFCE0 .text:B65EFCE0 04 2A CMP R2, #4.text:B65EFCE2 0D D8 BHI locret_B65EFD00.text:B65EFCE4 00 2A CMP R2, #0.text:B65EFCE6 0B D0 BEQ locret_B65EFD00.text:B65EFCE8 02 31 ADDS R1, #2.text:B65EFCEA D3 00 LSLS R3, R2, #3.text:B65EFCEC 08 3B SUBS R3, #8.text:B65EFCEE 00 20 MOVS R0, #0.text:B65EFCF0.text:B65EFCF0 loc_B65EFCF0 .text:B65EFCF0 0C 78 LDRB R4, [R1].text:B65EFCF2 9C 40 LSLS R4, R3.text:B65EFCF4 20 43 ORRS R0, R4.text:B65EFCF6 01 3A SUBS R2, #1.text:B65EFCF8 08 3B SUBS R3, #8.text:B65EFCFA 01 31 ADDS R1, #1.text:B65EFCFC 00 2A CMP R2, #0.text:B65EFCFE F7 D1 BNE loc_B65EFCF0.text:B65EFD00.text:B65EFD00 locret_B65EFD00 .text:B65EFD00 D0 BD POP {R4,R6,R7,PC} 计算MD5值 123456789101112131415161718int __fastcall md5_sub_C6FEF398(int a1, int a2, int a3){ int i; // r0 int v8[26]; // [sp+10h] [bp-68h] BYREF memset_sub_C6BB64C0(v8, 0, 88); v8[0] = 0; v8[1] = 0; v8[2] = 1732584193; v8[3] = -271733879; v8[4] = -1732584194; v8[5] = 271733878; sub_B65F11F4(v8, a1, a2); sub_B65F1294(v8, a3); for ( i = 0; i != 88; ++i ) *((_BYTE *)v8 + i) = 0; return _stack_chk_guard - v8[22];} 计算后的值为： 1638C81261479C2104EDE3F2518E91725 该值会作为解密资源密钥的一部分。 4.3.2、解密assets/ms_com.sankuai.meituan组合密钥：包名+常量字符(WU@TEN)+META-INF/SANKUAI.RSA(md5) 1com.sankuai.meituanWU@TEN638C81261479C2104EDE3F2518E91725 将组合后的字符串加密Sha1值 12345678910111213141516171819202122232425262728293031323334353637383940.text:C1D52AA4 F0 B5 PUSH {R4-R7,LR}.text:C1D52AA6 03 AF ADD R7, SP, #0xC.text:C1D52AA8 8F B0 SUB SP, SP, #0x3C.text:C1D52AAA 15 00 MOVS R5, R2.text:C1D52AAC 0E 00 MOVS R6, R1.text:C1D52AAE 02 90 STR R0, [SP,#0x48+var_40].text:C1D52AB0 1A 48 LDR R0, =(__stack_chk_guard_ptr - 0xC1D52AB6).text:C1D52AB2 78 44 ADD R0, PC ; __stack_chk_guard_ptr.text:C1D52AB4 04 68 LDR R4, [R0] ; __stack_chk_guard.text:C1D52AB6 20 68 LDR R0, [R4].text:C1D52AB8 0E 90 STR R0, [SP,#0x48+var_10].text:C1D52ABA 00 2E CMP R6, #0.text:C1D52ABC 1F D0 BEQ loc_C1D52AFE.text:C1D52ABE 00 2D CMP R5, #0.text:C1D52AC0 1D D0 BEQ loc_C1D52AFE.text:C1D52AC2 01 94 STR R4, [SP,#0x48+var_44].text:C1D52AC4 05 AC ADD R4, SP, #0x48+var_34.text:C1D52AC6 21 21 MOVS R1, #0x21 ; '!'.text:C1D52AC8 20 00 MOVS R0, R4.text:C1D52ACA F2 F7 26 E9 BLX __aeabi_memclr4.text:C1D52ACE 30 00 MOVS R0, R6.text:C1D52AD0 29 00 MOVS R1, R5.text:C1D52AD2 22 00 MOVS R2, R4.text:C1D52AD4 12 F0 8E FB BL JMP_Sha1_256_sub_C6BB01F4 ; R0:原始值，R1：大小,R2:返回值.text:C1D52AD8 03 A8 ADD R0, SP, #0x48+var_3C.text:C1D52ADA 20 22 MOVS R2, #0x20 ; ' '.text:C1D52ADC 21 00 MOVS R1, R4.text:C1D52ADE 01 9C LDR R4, [SP,#0x48+var_44].text:C1D52AE0 FF F7 72 FF BL Hex2String_sub_C6B9D9C8 ; R1:返回值，R2：大小.text:C1D52AE4 03 98 LDR R0, [SP,#0x48+var_3C].text:C1D52AE6 02 99 LDR R1, [SP,#0x48+var_40].text:C1D52AE8 08 60 STR R0, [R1].text:C1D52AEA 0D 48 LDR R0, =(off_C1DD8C48 - 0xC1D52AF0).text:C1D52AEC 78 44 ADD R0, PC ; off_C1DD8C48.text:C1D52AEE 00 68 LDR R0, [R0] ; dword_C1DEAADC.text:C1D52AF0 01 00 MOVS R1, R0.text:C1D52AF2 0C 31 ADDS R1, #0xC.text:C1D52AF4 03 91 STR R1, [SP,#0x48+var_3C].text:C1D52AF6 04 A9 ADD R1, SP, #0x48+var_38.text:C1D52AF8 6B F0 26 FE BL free_sub_B2943748 加密后的值为： 12//该值为解密assets/ms_com.sankuai.meituan的密钥69fe5963f3b95d9718c8d3e4f924ad9379500e9b51d80686e65347890e1748fe 读取资源文件assets/ms_com.sankuai.meituan 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int __fastcall ReadFile_unzip_sub_C6BAE74C(int *a1, int a2, int a3){ int v5; // r0 int v6; // r5 int v7; // r0 int v8; // r6 int v9; // r5 int v10; // r0 __int64 v13; // [sp+24h] [bp-28h] BYREF unsigned int v14; // [sp+30h] [bp-1Ch] BYREF int v15; // [sp+34h] [bp-18h] BYREF int v16; // [sp+38h] [bp-14h] BYREF v5 = a2 - 10000; v6 = 0; if ( a2 &gt;= 10000 &amp;&amp; v5 &lt; a1[8] ) { if ( *(_DWORD *)(a1[9] + 8 * v5) ) { v6 = 0; if ( read_sub_C6BAE448(a1, a2, &amp;v16, &amp;v15, (int *)&amp;v14, &amp;v13, 0, 0) ) { v7 = mapfile_sub_C6BAE6C0(a1, a2); v8 = v7; if ( v7 ) { v9 = *(_DWORD *)(v7 + 24); if ( v14 &gt; 0x8000 ) sub_C1D62E3C(v7, 2); if ( v16 ) { v10 = unzip_sub_C6BAE820(a3, v9, v15, v14); v6 = 0; if ( !v10 ) {LABEL_15: free_sub_CA79DF8C(v8); return v6; } } else { getvalu_sub_C87B550A(a3, v9, v15); } if ( v14 &gt; 0x8000 ) sub_C1D62E3C(v8, 0); v6 = 1; goto LABEL_15; } } } } return v6;} 读取后内容(部分) 123456789BCF4A000 89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52 .PNG........IHDRBCF4A010 00 00 00 3C 00 00 00 3C 08 06 00 00 00 3A FC D9 ...&lt;...&lt;.....:..BCF4A020 72 00 00 13 56 49 44 41 54 78 DA ED 5A 79 70 55 r...VIDATx..ZypUBCF4A030 D7 79 BF 42 AC C6 80 09 5E 00 DB 98 5D E0 64 92 ...B.ƀ .^...]...BCF4A040 4E 92 76 6C 37 EE 4C 26 4D 5D A7 6E DA 74 49 26 N.vl7...M].n..I&amp;BCF4A050 53 B7 C9 8C FF 68 DC 75 9C DA 1D D7 F5 C4 4E 13 S.Ɍ .h..........BCF4A060 63 D7 98 C5 80 36 90 90 D0 CA 62 83 84 D9 F4 F4 cט ŀ 6....b.....BCF4A070 16 BD 4D CB D3 BE 20 24 10 9B 10 12 9B 04 48 08 ..M... $......H.BCF4A080 B4 DE 5F 7F E7 DC E5 9D FB 24 40 24 B6 EB E9 F4 .........$@$.... 解析解密图片得到PIC数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737int __fastcall ParsePng_sub_CB4C8858( int *a1, unsigned int *a2, unsigned int *a3, _DWORD *a4, unsigned int data, unsigned int a6){ int *v54; // r4 void *v55; // r0 int (__fastcall *v56)(void **, int *, unsigned __int8 *, unsigned int, _DWORD *); v7 = 0; *a1 = 0; *a3 = 0; *a2 = 0; result = CRC32_sub_CB4C7D08((int *)a2, (int *)a3, a4, (unsigned __int8 *)data, a6); a4[92] = result; if ( result ) return result; v110 = a4 + 92; v9 = a4[39]; v10 = a4[38]; v135 = a4 + 39; v104 = a4 + 38; v108 = a4; v131 = a4 + 35; v148 = (void *)*a3; v11 = *a2; v12 = 0; if ( v10 &lt;= 6 ) v12 = dword_C1DD1C40[v10]; v13 = v12 * v9; v14 = v108[27]; v15 = v108[28]; if ( v14 &lt;= 6 ) v7 = dword_C1DD1C40[v14]; if ( v13 &lt;= v7 * v15 ) { v18 = 0; v17 = *a3; if ( v14 &lt;= 6 ) v18 = dword_C1DD1C40[v14]; v143 = v15 * v18; } else { v16 = 0; v17 = *a3; if ( v10 &lt;= 6 ) v16 = dword_C1DD1C40[v10]; v143 = v9 * v16; } v19 = v11 * v17; v20 = 0; if ( v11 ) { v21 = to1028_sub_CA812FD0(v11 * v17, v11); v20 = 0; v17 = (unsigned int)v148; if ( (void *)v21 != v148 ) goto LABEL_125; if ( v19 ) { v22 = to1028_sub_CA812FD0(8 * v19, v19); v20 = 0; v17 = (unsigned int)v148; if ( v22 != 8 ) goto LABEL_125; } if ( v11 &gt;&gt; 3 ) { v23 = to1028_sub_CA812FD0((v11 &gt;&gt; 3) * v143, v11 &gt;&gt; 3); v17 = (unsigned int)v148; v20 = (v11 &gt;&gt; 3) * v143; if ( v23 != v143 ) goto LABEL_125; } } v24 = v20 + (((v11 &amp; 7) * v143 + 7) &gt;&gt; 3); if ( v24 &lt; v20 || v24 &gt; 0xFFFFFFFA || to1028_sub_CA812FD0(v17 * (v24 + 5), v24 + 5) != v17 ) {LABEL_125: result = 92; *v110 = 92; return result; } v25 = v108; v111 = v108 + 1; v26 = (unsigned __int8 *)(data + 33); pdata = 0; v129 = 0; v119 = 0; v116 = 1; while ( 1 ) { v27 = (unsigned int)&amp;v26[-data + 12]; if ( (unsigned int)v26 &lt; data || v27 &gt; a6 ) { if ( v25[7] ) goto LABEL_136; v44 = 30; goto LABEL_132; } v144 = v26; v28 = v26; v29 = _byteswap_ulong(*(_DWORD *)v26); v30 = v110; if ( v29 &lt; 0 ) { v25 = v108; if ( v108[7] ) goto LABEL_136; v44 = 63; goto LABEL_133; } if ( v29 + v27 &gt; a6 || (unsigned int)&amp;v26[v29 + 12] &lt; data ) break; v31 = v26 + 8; if ( !byte_C1DEAAB4 ) { DecString((const char *)byte_C1DE8374, aXpvn, 17, 4); v28 = v144; byte_C1DE8378 = 0; } byte_C1DEAAB4 = 1; if ( getIHDR_sub_CCBFBBC8(v28, byte_C1DE8374) ) { v32 = v29 + v129; if ( v29 + v129 &lt; v29 ) { v43 = 95; goto LABEL_134; } v122 = v29 + v129; if ( v119 &gt;= v32 ) { v34 = (int)pdata; } else { v33 = v29 + v129; if ( v32 &lt;= 2 * v119 ) v33 = (3 * v32) &gt;&gt; 1; v119 = v33; v34 = realloc(pdata); if ( !v34 ) { v43 = 83; goto LABEL_134; } } v35 = 0; v116 = 3; if ( v29 ) { v37 = v129; do { *(_BYTE *)(v34 + v37) = *v31++; --v29; ++v37; } while ( v29 ); } v129 = v122; pdata = (unsigned __int8 *)v34; goto LABEL_50; } if ( !byte_C1DEAAB5 ) { DecString((const char *)byte_C1DE8379, aPv, 18, 4); byte_C1DE837D = 0; } v35 = 1; byte_C1DEAAB5 = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE8379) ) goto LABEL_50; if ( !byte_C1DEAAA8 ) { DecString((const char *)byte_C1DE8338, aSjI, 3, 4); unk_C1DE833C = 0; } byte_C1DEAAA8 = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE8338) ) { v36 = dec_sub_CA801FF0(v104, v31, v29); *v110 = v36; v35 = 0; v116 = 2;LABEL_67: v25 = v108; v38 = (unsigned int *)v144; if ( v36 ) goto LABEL_136;LABEL_51: if ( !v25[5] ) { v39 = gencrc_sub_CA800C08(v38); v38 = (unsigned int *)v144; if ( v39 ) { v44 = 57;LABEL_132: v30 = v110;LABEL_133: *v30 = v44; goto LABEL_136; } } if ( v35 ) goto LABEL_136;LABEL_55: v40 = *v110; goto LABEL_56; } if ( !byte_C1DEAAA9 ) { DecString((const char *)byte_C1DE833D, aPud, 4, 4); byte_C1DE8341 = 0; } byte_C1DEAAA9 = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE833D) ) { v36 = sub_C1DB9080(v104, v31, v29);LABEL_66: *v110 = v36; v35 = 0; goto LABEL_67; } if ( !byte_C1DEAAAA ) { DecString((const char *)byte_C1DE8342, aGclj, 5, 4); byte_C1DE8346 = 0; } byte_C1DEAAAA = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE8342) ) { v36 = sub_C1DB9100(v131, v31, v29); goto LABEL_66; } if ( !byte_C1DEAAAB ) { DecString((const char *)byte_C1DE8347, aRlt, 6, 4); byte_C1DE834B = 0; } byte_C1DEAAAB = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE8347) ) { v35 = 0; if ( v108[9] ) { v36 = sub_C1DB917C((int)v131, v31, v29);LABEL_79: *v110 = v36; goto LABEL_67; } goto LABEL_50; } if ( !byte_C1DEAAAC ) { DecString((const char *)byte_C1DE834C, aUd, 7, 4); byte_C1DE8350 = 0; } byte_C1DEAAAC = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE834C) ) { v35 = 0; if ( v108[9] ) { v36 = sub_C1DB923C(v131, v111, v31, v29); goto LABEL_79; }LABEL_50: v25 = v108; v38 = (unsigned int *)v144; goto LABEL_51; } if ( !byte_C1DEAAAD ) { DecString((const char *)byte_C1DE8351, aAVe, 8, 4); byte_C1DE8355 = 0; } byte_C1DEAAAD = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE8351) ) { if ( v108[9] ) { v41 = sub_C1DB936C(v131, v111, v31, v29); *v110 = v41; v25 = v108; v38 = (unsigned int *)v144; v35 = 0; if ( v41 ) goto LABEL_136; } else { v25 = v108; v38 = (unsigned int *)v144; v35 = 0; } goto LABEL_51; } if ( !byte_C1DEAAAE ) { DecString((const char *)byte_C1DE8356, aEbw, 9, 4); unk_C1DE835A = 0; } byte_C1DEAAAE = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE8356) ) { if ( v29 != 7 ) { v43 = 73;LABEL_134: v30 = v110; goto LABEL_135; } v108[58] = 1; v38 = (unsigned int *)v144; v108[59] = (v144[8] &lt;&lt; 8) | v144[9]; v108[60] = v144[10]; v108[61] = v144[11]; v108[62] = v144[12]; v108[63] = v144[13]; v108[64] = v144[14];LABEL_92: v35 = 0; *v110 = 0; v25 = v108; goto LABEL_51; } if ( !byte_C1DEAAAF ) { DecString((const char *)byte_C1DE835B, aZei, 10, 4); unk_C1DE835F = 0; } byte_C1DEAAAF = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE835B) ) { v36 = sub_C1DB95FC(v131, (int)v31, v29); goto LABEL_66; } if ( !byte_C1DEAAB0 ) { DecString((const char *)byte_C1DE8360, aLoU, 11, 4); unk_C1DE8364 = 0; } byte_C1DEAAB0 = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE8360) ) { if ( v29 != 4 ) { v43 = 96; goto LABEL_134; } v108[69] = 1; v38 = (unsigned int *)v144; v108[70] = _byteswap_ulong(*((_DWORD *)v144 + 2)); goto LABEL_92; } if ( !byte_C1DEAAB1 ) { DecString((const char *)byte_C1DE8365, aOgX, 12, 4); unk_C1DE8369 = 0; } byte_C1DEAAB1 = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE8365) ) { v36 = sub_C1DB9640(v131, (unsigned int *)v31, v29); goto LABEL_66; } if ( !byte_C1DEAAB2 ) { DecString((const char *)byte_C1DE836A, aBtt, 13, 4); unk_C1DE836E = 0; } byte_C1DEAAB2 = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE836A) ) { if ( v29 != 1 ) { v43 = 98; goto LABEL_134; } v108[80] = 1; v108[81] = *v31; v35 = 0; *v110 = 0; goto LABEL_50; } if ( !byte_C1DEAAB3 ) { DecString((const char *)byte_C1DE836F, aGrwg, 14, 4); unk_C1DE8373 = 0; } byte_C1DEAAB3 = 1; if ( getIHDR_sub_CCBFBBC8(v144, byte_C1DE836F) ) { v36 = sub_C1DB9714(v131, v111, v31, v29); goto LABEL_66; } if ( !v108[6] &amp;&amp; (v144[4] &amp; 0x20) == 0 ) { v43 = 69; goto LABEL_134; } if ( !v108[10] ) { v25 = v108; v38 = (unsigned int *)v144; goto LABEL_55; } v25 = v108; v42 = sub_C1DB7CCE(&amp;v108[v116 + 85], &amp;v108[v116 + 88], (unsigned int *)v144); v38 = (unsigned int *)v144; *v110 = v42; v40 = 0; if ( v42 ) goto LABEL_136;LABEL_56: v26 = isPng_sub_CA800C80((unsigned __int8 *)v38); if ( v40 ) goto LABEL_136; } v43 = 64;LABEL_135: *v30 = v43; v25 = v108;LABEL_136: v154 = 0; v152 = 0; v153 = 0; v45 = v25[37]; v123 = v25 + 37; v46 = *a2; if ( v45 ) { v145 = *a3; v47 = (*a3 + 7) &gt;&gt; 3; v140 = sub_C1DBAC4C((v46 + 7) &gt;&gt; 3, v47, (unsigned int *)v104); v48 = v46 + 3; if ( v46 &gt;= 5 ) { v49 = sub_C1DBAC4C(v48 &gt;&gt; 3, v47, (unsigned int *)v104) + v140; v48 = v46 + 3; v140 = v49; } v50 = sub_C1DBAC4C(v48 &gt;&gt; 2, (v145 + 3) &gt;&gt; 3, (unsigned int *)v104) + v140; v51 = v46 + 1; if ( v46 &gt;= 3 ) { v50 += sub_C1DBAC4C(v51 &gt;&gt; 2, (v145 + 3) &gt;&gt; 2, (unsigned int *)v104); v51 = v46 + 1; } v52 = sub_C1DBAC4C(v51 &gt;&gt; 1, (v145 + 1) &gt;&gt; 2, (unsigned int *)v104) + v50; if ( v46 &gt;= 2 ) v52 += sub_C1DBAC4C(v46 &gt;&gt; 1, (v145 + 1) &gt;&gt; 1, (unsigned int *)v104); v53 = sub_C1DBAC4C(v46, v145 &gt;&gt; 1, (unsigned int *)v104) + v52; } else { v53 = sub_C1DBAC4C(*a2, *a3, (unsigned int *)v104); } v54 = v110; if ( !*v110 ) { if ( !v53 ) goto LABEL_149; v55 = (void *)realloc(0); if ( !v55 ) { v57 = 83; goto LABEL_157; } v152 = v55; v154 = v53; if ( !*v110 ) {LABEL_149: v56 = (int (__fastcall *)(void **, int *, unsigned __int8 *, unsigned int, _DWORD *))v108[2]; if ( v56 ) v57 = v56(&amp;v152, &amp;v153, pdata, v129, v111); else v57 = sub_C1DB7A98(&amp;v152, &amp;v153, pdata, v129, v111); v58 = v57; v54 = v110; if ( v153 != v53 ) v58 = 91; if ( !v57 ) v57 = v58;LABEL_157: *v54 = v57; } } free(pdata); if ( !*v54 ) { v59 = *v135; v107 = *a2; v132 = *a3; v146 = *v104; v60 = sub_C1DB7DA4(*a2, *a3, *v104, *v135); v61 = malloc(v60); *a1 = v61; v62 = 83; if ( v61 ) { if ( v60 ) { for ( i = 0; i != v60; ++i ) { *(_BYTE *)(v61 + i) = 0; v61 = *a1; } v64 = v108[38]; v59 = *v135; v132 = *a3; v107 = *a2; } else { v64 = v146; } v147 = (char *)v152; v65 = 0; if ( v64 &lt;= 6 ) v65 = dword_C1DD1C40[v64]; v66 = v59 * v65; v62 = 31; if ( v66 ) { if ( *v123 ) { v139 = v61; sub_C1DBAF5C(v159, v158, v157, v156, v155, v107, v132, v66); v67 = 0; do { v68 = *(_DWORD *)&amp;v158[v67]; v141 = v67; v136 = &amp;v147[*(_DWORD *)&amp;v156[v67]]; v69 = *(_DWORD *)&amp;v159[v67]; v62 = sub_C1DBAC80(v136); if ( v62 ) { v80 = 0; v54 = v110; goto LABEL_206; } if ( v66 &lt;= 7 ) sub_C1DBAECC(&amp;v147[*(_DWORD *)&amp;v155[v141]], v136, v69 * v66, (v69 * v66 + 7) &amp; 0xFFFFFFF8, v68); v67 = v141 + 4; } while ( v141 != 24 ); sub_C1DBAF5C(v164, v163, v162, v161, v160, v107, v132, v66); if ( v66 &lt;= 7 ) { v81 = 0; v118 = v66; do { v96 = v81; v82 = v81; v106 = v163[v82]; if ( v106 ) { v134 = v164[v82]; v103 = &amp;dword_C1DD1BAC[v82]; v101 = (_DWORD *)((char *)&amp;unk_C1DD1BC8 + v82 * 4); v99 = &amp;dword_C1DD1BE4[v82]; v98 = &amp;dword_C1DD1C00[v82]; v97 = &amp;v160[v82 * 4]; for ( j = 0; j != v106; ++j ) { if ( v134 ) { pdatab = (void *)((*v99 * j + *v98) * v107 + *v101); v125 = *v103; v121 = 8 * *(_DWORD *)v97; v83 = 0; do { v84 = (v83 + v134 * j) * v66 + v121; v138 = v83; v85 = ((_DWORD)pdatab + v125 * v83) * v66; v86 = v66; do { v87 = ((unsigned __int8)v147[v84 &gt;&gt; 3] &gt;&gt; (~(_BYTE)v84 &amp; 7)) &amp; 1; ++v84; if ( v87 ) *(_BYTE *)(v139 + (v85 &gt;&gt; 3)) |= (_BYTE)v87 &lt;&lt; (~(_BYTE)v85 &amp; 7); --v86; ++v85; } while ( v86 ); v83 = v138 + 1; v66 = v118; } while ( v138 + 1 != v134 ); } } } v81 = v96 + 1; } while ( v96 != 6 ); } else { v70 = v66 &gt;&gt; 3; v71 = 0; v149 = v66 &gt;&gt; 3; do { v100 = v71; v72 = v71; pdataa = (void *)v163[v71]; if ( pdataa ) { v120 = &amp;dword_C1DD1BAC[v72]; v117 = (_DWORD *)((char *)&amp;unk_C1DD1BC8 + v72 * 4); v112 = &amp;dword_C1DD1BE4[v72]; v105 = &amp;dword_C1DD1C00[v72]; v102 = &amp;v160[v72 * 4]; v142 = v164[v71]; v124 = v142 * v70; v133 = 0; v130 = v147; do { if ( v142 ) { v73 = &amp;v130[*(_DWORD *)v102]; v137 = *v120 * v70; v74 = (_BYTE *)(v139 + (*v117 + (*v105 + *v112 * (_DWORD)v133) * v107) * v70); for ( k = 0; k != v142; ++k ) { if ( v70 ) { v76 = v73; v77 = (char *)v149; v78 = v74; do { *v78 = *v76++; --v77; ++v78; } while ( v77 ); } v70 = v149; v73 += v149; v74 += v137; } } v130 += v124; v133 = (char *)v133 + 1; } while ( v133 != pdataa ); } v71 = v100 + 1; } while ( v100 != 6 ); } v62 = 0; v54 = v110; v80 = 1;LABEL_206: if ( v80 )LABEL_207: v62 = 0; } else if ( v66 &gt; 7 || (v79 = v107 * v66, v107 * v66 == ((v107 * v66 + 7) &amp; 0xFFFFFFF8)) ) { v62 = sub_C1DBAC80(v61); if ( !v62 ) goto LABEL_207; } else { v151 = (void *)((v107 * v66 + 7) &amp; 0xFFFFFFF8); v95 = v61; v62 = sub_C1DBAC80(v152); if ( !v62 ) { sub_C1DBAECC(v95, v147, v79, v151, v132); goto LABEL_207; } } } } *v54 = v62; } v88 = 0; v153 = 0; v154 = 0; free(v152); result = *v54; if ( !*v54 ) { v89 = v108 + 27; if ( v108[8] ) { if ( !sub_C1DB8460(v108 + 27, v104) ) { if ( (*v89 | 4) != 6 ) { result = 56; if ( v108[28] != 8 ) return result; } v150 = (void *)*a1; v90 = *a3; v91 = *a2; v92 = sub_C1DB7DA4(*a2, *a3, *v89, v108[28]); v93 = malloc(v92); *a1 = v93; v94 = 83; if ( v93 ) v94 = sub_C1DB8064(v93, v150, v89, v104, v91, v90); *v110 = v94; free(v150); return *v110; } } else { result = sub_C1DB7D34(v108 + 27, v104); *v110 = result; if ( result ) return result; } return v88; } return result;} 得到PIC数据(部分)(这个数据是伴随APP整个生命周期,主要用途是加解密密钥) 12345678910BDC74300 2E 50 49 43 90 01 00 00 10 02 00 00 B0 02 00 00 .PIC............BDC74310 82 1B 33 E3 4F 0C 49 C7 00 00 00 00 2D AA F5 F4 ..3...I.....-...BDC74320 52 22 D7 92 FB 3E EB AA 4A A2 74 C9 12 2D F9 92 R&quot;ג .&gt;....t..-..BDC74330 F4 E7 CD 2C D8 33 1A B5 D4 8F F1 1E 11 6A 63 4D ........ԏ ....cMBDC74340 73 AC 1E 88 BB E5 A5 D2 19 F4 46 8A 7D 13 57 F8 s.............W.BDC74350 0C 14 F1 4C C7 E2 89 01 1A BD C8 72 66 3F F0 A9 ............f?..BDC74360 C2 BA 6B 75 6D E3 03 FC 8F 61 20 96 6F 2C 44 2D º kum....a .o,D-BDC74370 D6 19 DE F4 74 8E 6F 01 6B 9D 5F BB 6D C4 6C CD ....t.o.k._.m...BDC74380 49 00 8F 36 F9 18 8E 50 2D 35 F3 6C F0 6C 75 84 I..6...P-5....u.BDC74390 2C 78 A0 D7 8E 64 A1 E9 CC 5C 1A 59 C3 78 E3 7A ,x...d.....Y.... 4.4、采集系统环境信息加密4.4.1、循环获取信息 0x34次1234567891011121314151617181920212223.text:C1AF5224 02 98 LDR R0, [SP,#8].text:C1AF5226 06 59 LDR R6, [R0,R4].text:C1AF5228 D6 F7 46 F8 BL init_DecString_sub_C84582B8.text:C1AF522C 06 90 STR R0, [SP,#0x18].text:C1AF522E 0A AD ADD R5, SP, #0x28 ; '('.text:C1AF5230 28 00 MOVS R0, R5.text:C1AF5232 04 99 LDR R1, [SP,#0x10].text:C1AF5234 05 9A LDR R2, [SP,#0x14].text:C1AF5236 33 00 MOVS R3, R6.text:C1AF5238 FB F7 AC FE BL GetDeviceInfo_dispatch_loop_sub_C89F8F94 ; 获取设备信息1.text:C1AF523C 06 98 LDR R0, [SP,#0x18].text:C1AF523E 31 00 MOVS R1, R6.text:C1AF5240 2A 00 MOVS R2, R5.text:C1AF5242 03 9D LDR R5, [SP,#0xC].text:C1AF5244 F9 F7 BE F9 BL jmp_checkField_sub_C89F65C4 ; 判断采集的设备信息是否等于如下特殊字符[]，{}，mtg_block，mtg_unsupport.text:C1AF5248 0A 98 LDR R0, [SP,#0x28].text:C1AF524A 40 19 ADDS R0, R0, R5.text:C1AF524C 09 A9 ADD R1, SP, #0x24 ; '$'.text:C1AF524E 4C F0 7B FA BL free_sub_B2943748.text:C1AF5252 04 34 ADDS R4, #4.text:C1AF5254 34 2C CMP R4, #0x34 ; '4' ; 判断是否结束.text:C1AF5256 E5 D1 BNE loc_C1AF5224.text:C1AF5258 03 B5 PUSH {R0,R1,LR} ; 获取结束 在下面地方下是跳转到每一个采集信息方法入口的地方，下好断点: 12345.text:C207A134 80 00 LSLS R0, R0, #2 ; 跳到真实执行方法.text:C207A136 02 A1 ADR R1, loc_C207A140.text:C207A138 08 58 LDR R0, [R1,R0] ; 取方法表偏移.text:C207A13A 08 18 ADDS R0, R1, R0.text:C207A13C 87 46 MOV PC, R0 获取的系统环境信息 123456{ &quot;0&quot;: 2, &quot;1&quot;: [&quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;google&quot;, &quot;user&quot;, &quot;-&quot;, &quot;PQ2A.190305.002&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;sailfish&quot;, &quot;-&quot;, &quot;-&quot;, &quot;Pixel&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;adb&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;{\\&quot;1\\&quot;:\\&quot;-\\&quot;,\\&quot;2\\&quot;:\\&quot;-\\&quot;,\\&quot;3\\&quot;:\\&quot;-\\&quot;,\\&quot;4\\&quot;:\\&quot;\\&quot;,\\&quot;5\\&quot;:\\&quot;\\&quot;,\\&quot;6\\&quot;:\\&quot;-\\&quot;,\\&quot;7\\&quot;:\\&quot;-\\&quot;,\\&quot;8\\&quot;:\\&quot;\\&quot;,\\&quot;9\\&quot;:\\&quot;\\&quot;,\\&quot;10\\&quot;:\\&quot;-\\&quot;,\\&quot;11\\&quot;:\\&quot;-\\&quot;,\\&quot;12\\&quot;:\\&quot;32\\&quot;,\\&quot;13\\&quot;:\\&quot;\\&quot;,\\&quot;14\\&quot;:\\&quot;-\\&quot;,\\&quot;15\\&quot;:\\&quot;\\&quot;,\\&quot;33\\&quot;:{\\&quot;0\\&quot;:0,\\&quot;1\\&quot;:\\&quot;-\\&quot;,\\&quot;2\\&quot;:\\&quot;-\\&quot;,\\&quot;3\\&quot;:\\&quot;-\\&quot;,\\&quot;4\\&quot;:\\&quot;-\\&quot;,\\&quot;5\\&quot;:\\&quot;-\\&quot;,\\&quot;6\\&quot;:\\&quot;-\\&quot;,\\&quot;7\\&quot;:\\&quot;-\\&quot;,\\&quot;8\\&quot;:\\&quot;-\\&quot;,\\&quot;9\\&quot;:\\&quot;-\\&quot;,\\&quot;10\\&quot;:\\&quot;-\\&quot;,\\&quot;11\\&quot;:\\&quot;-\\&quot;,\\&quot;12\\&quot;:\\&quot;-\\&quot;,\\&quot;13\\&quot;:\\&quot;-\\&quot;,\\&quot;14\\&quot;:\\&quot;-\\&quot;,\\&quot;15\\&quot;:\\&quot;-\\&quot;}}&quot;, &quot;midi,adb&quot;, &quot;midi,adb&quot;, &quot;release-keys&quot;, &quot;-&quot;, &quot;1&quot;, &quot;1&quot;, &quot;-&quot;, &quot;9&quot;], &quot;2&quot;: [&quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;, &quot;-&quot;], &quot;3&quot;: &quot;{}&quot;} 4.4.2、加密设备信息压缩信息 12345678910111213141516171819202122result = deflateInit_(&amp;strm, -1, a128, 56); if ( !result ) { v6 = deflate(&amp;strm, 4); if ( v6 == 1 ) { *a4 = strm.total_out; return deflateEnd(&amp;strm); } deflateEnd(&amp;strm); if ( v6 != 2 ) { if ( v6 != -5 ) return v6; result = -3; if ( strm.avail_in ) return v6; return result; } return -3; } return result; 压缩后信息 12345678910C3904500 78 9C 9D 92 DB 0A C2 30 0C 86 DF 25 D7 CD E8 61 x...............C3904510 53 B7 3B DF 60 5E 5B 2F 26 AB 5A 9C 0C 56 04 65 S.;..^[/&amp;.Z..V.eC3904520 F4 DD ED 0E B0 20 4E A6 17 81 2F E1 4F D2 9F B4 ..... N.../.....C3904530 05 0E 99 64 20 20 DB 03 02 FB 1A E7 BA 3E 57 26 ...d ........W&amp;C3904540 C0 DD 99 66 AC E5 3B B9 8D 44 CA 15 4F 22 CE E5 ...f.....D..O&quot;..C3904550 5B 87 2B 6C 75 B2 EE 42 4A B9 7D 98 EA C3 F0 A2 [.+lu.....}.....C3904560 3C CE AC 6D 35 08 0D 99 06 D4 C0 34 48 C2 8A 70 &lt;ά m5......4H..pC3904570 DC 73 8F C9 84 2B A2 58 13 DE 4C 92 74 42 C1 89 ...Ʉ +.X....tB..C3904580 44 D0 AD 62 58 AB E4 90 29 D2 13 53 19 59 AD 3A DЭ bX......S.Y.:C3904590 51 78 7C 37 93 B3 5F 4C 20 71 81 0B 6C 20 F1 81 Qx|7.._L q..l .. 解密PIC数据获取加密key 上面计算得到的sha256值，(包名+固定字符+SANKUAI.RSA的MD5值)-&gt;转换成hex 69fe5963f3b95d9718c8d3e4f924ad9379500e9b51d80686e65347890e1748fe 169 FE 59 63 F3 B9 5D 97 18 C8 D3 E4 F9 24 AD 93 79 50 0E 9B 51 D8 06 86 E6 53 47 89 0E 17 48 FE 取前0x10字节 169 FE 59 63 F3 B9 5D 97 18 C8 D3 E4 F9 24 AD 93 生成AES KEY 1234567891011121314151617181920212223242526272829303132333435363738.text:C1AE9DA2 0A A8 ADD R0, SP, #0x28 ; '(' ; 生成AES key.text:C1AE9DA4 08 90 STR R0, [SP,#0x20].text:C1AE9DA6 84 5D LDRB R4, [R0,R6].text:C1AE9DA8 82 B0 SUB SP, SP, #8.text:C1AE9DAA 03 B5 PUSH {R0,R1,LR}.text:C1AE9DAC DF F7 72 E9 BLX jmp_sub_B288C094.text:C1AE9DB0 54 01 LSLS R4, R2, #5.text:C1AE9DB2 00 00 MOVS R0, R0.text:C1AE9DB4 01 BC POP {R0}.text:C1AE9DB6 20 18 ADDS R0, R4, R0.text:C1AE9DB8 29 00 MOVS R1, R5.text:C1AE9DBA 63 F0 49 F9 BL sub_C1B4D050.text:C1AE9DBE 07 91 STR R1, [SP,#0x1C].text:C1AE9DC0 82 B0 SUB SP, SP, #8.text:C1AE9DC2 03 B5 PUSH {R0,R1,LR}.text:C1AE9DC4 DF F7 66 E9 BLX jmp_sub_B288C094.text:C1AE9DC8 40 01 LSLS R0, R0, #5.text:C1AE9DCA 00 00 MOVS R0, R0.text:C1AE9DCC 01 BC POP {R0}.text:C1AE9DCE 20 18 ADDS R0, R4, R0.text:C1AE9DD0 04 99 LDR R1, [SP,#0x10].text:C1AE9DD2 63 F0 3D F9 BL sub_C1B4D050.text:C1AE9DD6 69 43 MULS R1, R5.text:C1AE9DD8 07 98 LDR R0, [SP,#0x1C].text:C1AE9DDA 08 18 ADDS R0, R1, R0 ; 初始化密钥.text:C1AE9DDC 03 21 MOVS R1, #3.text:C1AE9DDE 41 43 MULS R1, R0.text:C1AE9DE0 06 98 LDR R0, [SP,#0x18].text:C1AE9DE2 40 18 ADDS R0, R0, R1.text:C1AE9DE4 80 78 LDRB R0, [R0,#2].text:C1AE9DE6 20 40 ANDS R0, R4.text:C1AE9DE8 FE 21 MOVS R1, #0xFE.text:C1AE9DEA 01 40 ANDS R1, R0.text:C1AE9DEC 08 98 LDR R0, [SP,#0x20].text:C1AE9DEE 81 55 STRB R1, [R0,R6] ; 存储密钥.text:C1AE9DF0 01 36 ADDS R6, #1.text:C1AE9DF2 10 2E CMP R6, #0x10 ; 判断是否结束.text:C1AE9DF4 D5 D1 BNE loc_C1AE9DA2 ; 生成AES key 生成最终的AES KEY 168 98 08 02 F2 80 1C 94 08 C8 90 E4 A0 04 AC 82 AES 解密pic 123456789101112131415//IV 0102030405060708.text:C1AE7598 57 F0 7A F8 BL AES_set_decrypt_key_sub_CB601690 ; R0:key,R1:大小,R2:初始AES_KEY返回结构.text:C1AE759C 00 20 MOVS R0, #0.text:C1AE759E 69 46 MOV R1, SP.text:C1AE75A0 06 9A LDR R2, [SP,#0x128+var_110].text:C1AE75A2 0A 60 STR R2, [R1,#0x128+var_128].text:C1AE75A4 48 60 STR R0, [R1,#0x128+var_124].text:C1AE75A6 08 98 LDR R0, [SP,#0x128+var_108].text:C1AE75A8 04 9E LDR R6, [SP,#0x128+var_118].text:C1AE75AA 31 00 MOVS R1, R6.text:C1AE75AC 07 9C LDR R4, [SP,#0x128+var_10C].text:C1AE75AE 22 00 MOVS R2, R4.text:C1AE75B0 03 9B LDR R3, [SP,#0x128+var_11C].text:C1AE75B2 57 F0 35 FD BL AES_cbc_Dncrypt_sub_CB602020.text:C1AE75B6 30 00 MOVS R0, R6 解密解压后PIC数据 1{&quot;a1&quot;:0,&quot;a10&quot;:400,&quot;a2&quot;:&quot;com.sankuai.meituan&quot;,&quot;a11&quot;:&quot;c1ee9178c95d9ec75f0f076a374df94a032d54c8576298d4f75e653de3705449&quot;,&quot;a3&quot;:&quot;0a16ecd60eb56a6a3349f66cdcf7f7bf5190e5a42d6280d8dc0ee3be228398ec&quot;,&quot;a4&quot;:1100030200,&quot;k0&quot;:{&quot;k1&quot;:&quot;meituan1sankuai0&quot;,&quot;k2&quot;:&quot;meituan0sankuai1&quot;,&quot;k3&quot;:&quot;$MXMYBS@HelloPay&quot;,&quot;k4&quot;:&quot;Maoyan010iauknaS&quot;,&quot;k5&quot;:&quot;34281a9dw2i701d4&quot;,&quot;k6&quot;:&quot;X%rj@KiuU+|xY}?f&quot;},&quot;a5&quot;:&quot;11.3.200&quot;,&quot;a0&quot;:&quot;pw/LhTdeoTTyaxPHcHMy+/ssGNS1ihNkrJ+uBI74FIfd90KlTil1m0i7FF/n0bhY&quot;,&quot;a6&quot;:&quot;/HntC9XIfdUyII/UiVfx020EQPpHz2XZY3qzM2aiNmM0i0pB1yeSO689TY9SBB3s&quot;,&quot;a7&quot;:&quot;QsHnU6kFjTYR8Z6tHEvkGMO2Hrt+NRnVQhmxg6EtVBzuzQcBpma3AdhTWNMpesFT&quot;,&quot;c0&quot;:{&quot;c1&quot;:true,&quot;c2&quot;:false},&quot;a9&quot;:&quot;SDEzWXi5LHL/cuMCZ1zYyv+0hIViqWWf+ShbUYILWf4=&quot;,&quot;a8&quot;:1603800117167} 解析json获取key k6 1X%rj@KiuU+|xY}?f 计算压缩后信息的CRC值 1234567891011121314.text:C1B2C832 crc32_loc_CCBA9832 .text:C1B2C848↓j.text:C1B2C832 FF 25 MOVS R5, #0xFF.text:C1B2C834 05 40 ANDS R5, R0.text:C1B2C836 16 78 LDRB R6, [R2].text:C1B2C838 6E 40 EORS R6, R5.text:C1B2C83A B5 00 LSLS R5, R6, #2.text:C1B2C83C 65 59 LDR R5, [R4,R5].text:C1B2C83E 00 0A LSRS R0, R0, #8.text:C1B2C840 68 40 EORS R0, R5.text:C1B2C842 01 39 SUBS R1, #1.text:C1B2C844 01 32 ADDS R2, #1.text:C1B2C846 00 29 CMP R1, #0.text:C1B2C848 F3 D1 BNE crc32_loc_CCBA9832 计算后的CRC值为 744d7275 组合加密压缩后设备环境信息的key 1744d7275X%rj@Kiu //crc32+k6前8字节 AES加密压缩后数据 123456789101112131415.text:C1AE750E 32 00 MOVS R2, R6.text:C1AE7510 56 F0 30 FF BL AES_set_Encrypt_key_sub_CB601374 ; R0:key,R1:长度,R2:返回值.text:C1AE7514 06 9A LDR R2, [SP,#0x120+byte_count].text:C1AE7516 01 20 MOVS R0, #1.text:C1AE7518 69 46 MOV R1, SP.text:C1AE751A 04 9B LDR R3, [SP,#0x120+var_110].text:C1AE751C 0B 60 STR R3, [R1,#0x120+var_120].text:C1AE751E 48 60 STR R0, [R1,#0x120+var_11C].text:C1AE7520 05 98 LDR R0, [SP,#0x120+p].text:C1AE7522 02 9C LDR R4, [SP,#0x120+var_118].text:C1AE7524 21 00 MOVS R1, R4.text:C1AE7526 33 00 MOVS R3, R6.text:C1AE7528 57 F0 7A FD BL AES_cbc_Encrypt_sub_CB602020 ; R0：原始数据,R1:返回,R2:大小,R3:key.text:C1AE752C 06 98 LDR R0, [SP,#0x120+byte_count].text:C1AE752E 03 99 LDR R1, [SP,#0x120+var_114] 加密后数据(部分) 123456789C37514E0 2E 5D 33 AF C8 C3 6B 6A 7F C2 9F F6 39 16 52 57 .]3...kj.......WC37514F0 1D CB 01 FF A2 FA 48 0B 2D 2B 7E 39 73 EB 65 E7 ......H.-+~9s...C3751500 14 93 59 D9 15 F2 D7 CB C7 40 DC B5 9D 0D 34 16 ..Y......@....4.C3751510 9C BF 69 C6 54 97 81 C8 69 7A 26 03 BF FA F3 D9 ..i......z&amp;.....C3751520 A3 D2 BE 38 B0 99 48 4A 5E 56 F0 C6 88 54 79 BD .Ҿ 8..HJ^V....y.C3751530 56 86 96 A7 40 D4 61 32 6D A4 07 55 F1 46 46 EF V...@..2m..U....C3751540 4E A1 CA 86 F8 1E 69 09 0B CF 6D 05 3B D3 0F B4 N.ʆ ..i.....;...C3751550 63 78 65 6D AD F7 B2 C4 75 86 C5 35 B5 6F 42 BA cxem.........oB.C3751560 FA AF E7 4C 56 41 CF 36 46 86 3E E0 11 A3 35 9E .....A..F.&gt;...5. base64加密 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465.text:C1ACFE62 27 DB BLT loc_C1ACFEB4.text:C1ACFE64 00 25 MOVS R5, #0.text:C1ACFE66 3A 4A LDR R2, =(aAbcdefghijklmn - 0xC1ACFE6C) ; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm&quot;....text:C1ACFE68 7A 44 ADD R2, PC ; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm&quot;....text:C1ACFE6A 01 9E LDR R6, [SP,#0x28+var_24].text:C1ACFE6C.text:C1ACFE6C loc_C1ACFE6C ; CODE XREF: base64_sub_C795AE10+A0↓j.text:C1ACFE6C 43 5D LDRB R3, [R0,R5] ; 加密后数据.text:C1ACFE6E 9B 08 LSRS R3, R3, #2.text:C1ACFE70 D3 5C LDRB R3, [R2,R3] ; base64 key.text:C1ACFE72 33 70 STRB R3, [R6].text:C1ACFE74 43 5D LDRB R3, [R0,R5].text:C1ACFE76 1B 01 LSLS R3, R3, #4.text:C1ACFE78 30 24 MOVS R4, #0x30 ; '0'.text:C1ACFE7A 1C 40 ANDS R4, R3.text:C1ACFE7C 43 19 ADDS R3, R0, R5.text:C1ACFE7E 08 00 MOVS R0, R1.text:C1ACFE80 59 78 LDRB R1, [R3,#1].text:C1ACFE82 09 09 LSRS R1, R1, #4.text:C1ACFE84 21 43 ORRS R1, R4.text:C1ACFE86 51 5C LDRB R1, [R2,R1].text:C1ACFE88 71 70 STRB R1, [R6,#1].text:C1ACFE8A 59 78 LDRB R1, [R3,#1].text:C1ACFE8C 89 00 LSLS R1, R1, #2.text:C1ACFE8E 3C 24 MOVS R4, #0x3C ; '&lt;'.text:C1ACFE90 0C 40 ANDS R4, R1.text:C1ACFE92 99 78 LDRB R1, [R3,#2].text:C1ACFE94 89 09 LSRS R1, R1, #6.text:C1ACFE96 21 43 ORRS R1, R4.text:C1ACFE98 51 5C LDRB R1, [R2,R1].text:C1ACFE9A B1 70 STRB R1, [R6,#2].text:C1ACFE9C 99 78 LDRB R1, [R3,#2].text:C1ACFE9E 3F 23 MOVS R3, #0x3F ; '?'.text:C1ACFEA0 0B 40 ANDS R3, R1.text:C1ACFEA2 D1 5C LDRB R1, [R2,R3].text:C1ACFEA4 F1 70 STRB R1, [R6,#3].text:C1ACFEA6 01 00 MOVS R1, R0.text:C1ACFEA8 04 98 LDR R0, [SP,#0x28+var_18].text:C1ACFEAA 04 36 ADDS R6, #4.text:C1ACFEAC 03 35 ADDS R5, #3.text:C1ACFEAE 8D 42 CMP R5, R1.text:C1ACFEB0 DC DB BLT loc_C1ACFE6C ; 加密后数据.text:C1ACFEB2 02 9A LDR R2, [SP,#0x28+var_20].text:C1ACFEB4.text:C1ACFEB4 loc_C1ACFEB4 ; CODE XREF: base64_sub_C795AE10+52↑j.text:C1ACFEB4 95 42 CMP R5, R2.text:C1ACFEB6 1F DA BGE loc_C1ACFEF8.text:C1ACFEB8 41 5D LDRB R1, [R0,R5].text:C1ACFEBA 14 00 MOVS R4, R2.text:C1ACFEBC 8A 08 LSRS R2, R1, #2.text:C1ACFEBE 25 49 LDR R1, =(aAbcdefghijklmn - 0xC1ACFEC4) ; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm&quot;....text:C1ACFEC0 79 44 ADD R1, PC ; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm&quot;....text:C1ACFEC2 8A 5C LDRB R2, [R1,R2].text:C1ACFEC4 32 70 STRB R2, [R6].text:C1ACFEC6 42 5D LDRB R2, [R0,R5].text:C1ACFEC8 13 01 LSLS R3, R2, #4.text:C1ACFECA 30 22 MOVS R2, #0x30 ; '0'.text:C1ACFECC 1A 40 ANDS R2, R3.text:C1ACFECE 63 1E SUBS R3, R4, #1.text:C1ACFED0 9D 42 CMP R5, R3.text:C1ACFED2 14 D1 BNE loc_C1ACFEFE.text:C1ACFED4 89 5C LDRB R1, [R1,R2].text:C1ACFED6 71 70 STRB R1, [R6,#1].text:C1ACFED8 3D 21 MOVS R1, #0x3D ; '='.text:C1ACFEDA 1B E0 B loc_C1ACFF14 Base64加密后 1Ll0zr8jDa2p/wp/2ORZSVx3LAf+i+kgLLSt+OXPrZecUk1nZFfLXy8dA3LWdDTQWnL9pxlSXgchpeiYDv/rz2aPSvjiwmUhKXlbwxohUeb1WhpanQNRhMm2kB1XxRkbvTqHKhvgeaQkLz20FO9MPtGN4ZW2t97LEdYbFNbVvQrr6r+dMVkHPNkaGPuARozWeaQGSSMkoMMJ+ve9rA1L+aQTgGSootSpmPnT3TPLrCPN0Z6HzPKtpxopqfsjfcIV7YcP7M8Wc847wXfhMA2hYTRO24or97heGubGuxo8hQyw= 将CRC值与Base64加密后值组合,(签名时使用到) 1744d7275Ll0zr8jDa2p/wp/2ORZSVx3LAf+i+kgLLSt+OXPrZecUk1nZFfLXy8dA3LWdDTQWnL9pxlSXgchpeiYDv/rz2aPSvjiwmUhKXlbwxohUeb1WhpanQNRhMm2kB1XxRkbvTqHKhvgeaQkLz20FO9MPtGN4ZW2t97LEdYbFNbVvQrr6r+dMVkHPNkaGPuARozWeaQGSSMkoMMJ+ve9rA1L+aQTgGSootSpmPnT3TPLrCPN0Z6HzPKtpxopqfsjfcIV7YcP7M8Wc847wXfhMA2hYTRO24or97heGubGuxo8hQyw= 4.5、第二次加密设备信息设备信息数据 1{&quot;voltage&quot;:&quot;1&quot;,&quot;type&quot;:&quot;user&quot;,&quot;brand&quot;:&quot;google&quot;,&quot;psuc&quot;:&quot;adb&quot;,&quot;temp&quot;:&quot;1&quot;,&quot;suc&quot;:&quot;midi,adb&quot;,&quot;id&quot;:&quot;PQ2A.190305.002&quot;,&quot;sus&quot;:&quot;midi,adb&quot;,&quot;tags&quot;:&quot;release-keys&quot;,&quot;timestamp&quot;:&quot;1631688160837&quot;,&quot;hardware&quot;:&quot;sailfish&quot;,&quot;version&quot;:&quot;9&quot;,&quot;model&quot;:&quot;Pixel&quot;} 压缩数据 12345678C42FEF80 78 9C 55 8E 41 12 82 30 0C 45 EF D2 35 32 2D 8C x.U.A..0.E...2-.C42FEF90 08 EE BC 81 1E 21 D8 08 19 5B CA 34 80 32 8E 77 . .!...[...2.wC42FEFA0 37 15 37 AE 92 FF F2 93 FC 97 5A 82 9B A0 43 75 7.7.......Z...CuC42FEFB0 54 46 65 6A 5A C7 D4 CE 8C 51 54 1B 61 B0 22 BB TFejZ..Ό QT.a.&quot;.C42FEFC0 10 3A 87 02 46 9E AF A2 C1 B6 C9 8B 7E FC AD 6D .:..F.....ɋ ~..mC42FEFD0 D8 93 A5 6C 9B 51 5A 3B 5F 8A 53 6E 1A 5D EA 7D ...l.QZ;_.Sn.]..C42FEFE0 AE 75 F1 F5 F1 BF 4F 5E 27 12 D1 21 30 EE EE B8 .u....O^'...0...C42FEFF0 72 A2 E4 91 27 D8 CE 57 A5 A9 EA DA 54 BA 2E 0F r......W........ 解密PIC数据获取key(k1),流程和上面一样 1解密后得到key meituan1sankuai0 AES 加密压缩后数据 12345678910111213.text:C1AE7510 56 F0 30 FF BL AES_set_Encrypt_key_sub_CB601374 ; R0:key,R1:长度,R2:返回值.text:C1AE7514 06 9A LDR R2, [SP,#0x120+byte_count].text:C1AE7516 01 20 MOVS R0, #1.text:C1AE7518 69 46 MOV R1, SP.text:C1AE751A 04 9B LDR R3, [SP,#0x120+var_110].text:C1AE751C 0B 60 STR R3, [R1,#0x120+var_120].text:C1AE751E 48 60 STR R0, [R1,#0x120+var_11C].text:C1AE7520 05 98 LDR R0, [SP,#0x120+p].text:C1AE7522 02 9C LDR R4, [SP,#0x120+var_118].text:C1AE7524 21 00 MOVS R1, R4.text:C1AE7526 33 00 MOVS R3, R6.text:C1AE7528 57 F0 7A FD BL AES_cbc_Encrypt_sub_CB602020 ; R0：原始数据,R1:返回,R2:大小,R3:key.text:C1AE752C 06 98 LDR R0, [SP,#0x120+byte_count] 加密后数据(部分) 12345678910DEED6F00 2E 0F E3 72 62 1C 2B FB 35 B0 A9 CA E5 29 9F 79 ......+.5....).yDEED6F10 C6 37 F0 02 CB 17 12 AE 6E 3D 5E AC EB A6 B5 DD ........n=^.릵 .DEED6F20 33 B9 24 A9 F4 E0 6D 6C 64 D6 76 E4 65 88 6C 6F 3.$.....d.....loDEED6F30 F3 53 20 FA B3 F8 02 6C 6D BC 75 C9 87 66 92 CE .......lm.uɇ f..DEED6F40 51 7A BC 09 BF 69 5D C0 C3 0A 71 77 46 5B E0 81 Qz...i]...qwF[..DEED6F50 E2 15 67 05 5B 87 48 2D 0D D4 FA 99 EF 1C AC BD ....[.H-........DEED6F60 53 26 56 13 16 91 68 A8 EC 5B 1F D8 5F F4 61 BB S&amp;V...h.........DEED6F70 FA 2A 2F 03 B5 3F 6E 02 6E 57 ED 46 8B A1 1A 0A .*/..?n.nW......DEED6F80 F5 C5 E7 38 9F E5 8E 70 B1 8C D6 CF E8 D5 16 6F ...............oDEED6F90 F6 36 3B A5 D8 2B 3D D9 83 BD 17 C5 3F AA 3D 96 ......=ك .....=. Base64加密后 1Lg/jcmIcK/s1sKnK5SmfecY38ALLFxKubj1erOumtd0zuSSp9OBtbGTWduRliGxv81Mg+rP4AmxtvHXJh2aSzlF6vAm/aV3Awwpxd0Zb4IHiFWcFW4dILQ3U+pnvHKy9UyZWExaRaKjsWx/YX/Rhu/oqLwO1P24CblftRouhGgr1xec4n+WOcLGM1s/o1RZv9jY7pdgrPdmDvRfFP6o9liGe0rCXBoG85J1mm/6GmqQ= 4.6、代码混淆代码逻辑跳转动态计算： 123456789101112131415161718192021222324252627282930313233模板1.text:B845707C 01 10 CE E3 BIC R1, LR, #1.text:B8457080 00 11 91 E7 LDR R1, [R1,R0,LSL#2].text:B8457084 0E 10 81 E0 ADD R1, R1, LR.text:B8457088 08 E0 9D E5 LDR LR, [SP,#arg_8].text:B845708C 08 10 8D E5 STR R1, [SP,#arg_8].text:B8457090 03 80 BD E8 POP {R0,R1,PC} 模板2.text:C18BDAC0 7F B5 PUSH {R0-R6,LR}.text:C18BDAC2 7F B5 PUSH {R0-R6,LR}.text:C18BDAC4 0D 26 MOVS R6, #0xD.text:C18BDAC6 63 21 MOVS R1, #0x63 ; 'c'.text:C18BDAC8 68 46 MOV R0, SP.text:C18BDACA 10 30 ADDS R0, #0x10.text:C18BDACC 02 26 MOVS R6, #2.text:C18BDACE 08 30 ADDS R0, #8.text:C18BDAD0 01 1D ADDS R1, R0, #4.text:C18BDAD2 8D 46 MOV SP, R1.text:C18BDAD4 04 A6 05 36 ADRL R6, byte_C18BDAED.text:C18BDAD8 02 21 MOVS R1, #2.text:C18BDADA 0A 36 ADDS R6, #0xA.text:C18BDADC 76 18 ADDS R6, R6, R1.text:C18BDADE 46 62 STR R6, [R0,#0x24].text:C18BDAE0 40 BC POP {R6}.text:C18BDAE2 01 E0 B loc_C18BDAE8.text:C18BDAE4 ;.text:C18BDAE4 84 44 ADD R12, R0.text:C18BDAE6 12 34 ADDS R4, #0x12.text:C18BDAE8.text:C18BDAE8 loc_C18BDAE8 .text:C18BDAE8 00 46 MOV R0, R0.text:C18BDAEA 7F BD POP {R0-R6,PC} 字符串解密: 12345678910111213141516171819.text:C1D46060 DecString.text:C1D46060 ; __unwind { // 91B9000.text:C1D46060 10 B5 PUSH {R4,LR}.text:C1D46062 01 2B CMP R3, #1.text:C1D46064 08 DB BLT locret_C1D46078.text:C1D46066.text:C1D46066 loc_C1D46066.text:C1D46066 0C 78 LDRB R4, [R1].text:C1D46068 54 40 EORS R4, R2.text:C1D4606A 04 70 STRB R4, [R0].text:C1D4606C 01 3B SUBS R3, #1.text:C1D4606E 01 30 ADDS R0, #1.text:C1D46070 01 31 ADDS R1, #1.text:C1D46072 03 32 ADDS R2, #3.text:C1D46074 00 2B CMP R3, #0.text:C1D46076 F6 D1 BNE loc_C1D46066.text:C1D46078.text:C1D46078 locret_C1D46078.text:C1D46078 10 BD POP {R4,PC} 流程混淆: 12345678910111213.text:C1AF41F0 00 2C CMP R4, #0.text:C1AF41F2 01 DA BGE loc_C1AF41F8.text:C1AF41F4 FC F7 C8 FF BL loc_C1AF1188.text:C1AF41F8.text:C1AF41F8 loc_C1AF41F8 ; CODE XREF: .text:C1AF41F2↑j.text:C1AF41F8 03 B5 PUSH {R0,R1,LR}.text:C1AF41FA 01 48 LDR R0, =0x4A.text:C1AF41FC FC F7 F0 FE BL ret_sub_CA67BFE0 .text:C1AF0FE0 ret_sub_CA67BFE0.text:C1AF0FE0.text:C1AF0FE0 D8 F7 4C E8 BLX jmp_sub_B288C07C.text:C1AF0FE4 F0 1D ADDS R0, R6, #7 五、反爬虫mtgsig签名5.1、基本流程APP每一个业务网络请求的请求头中都有mtgsig参数，该参数是请求体与其它参数计算的签名值。java层代码如下： 123456789101112131415161718public static String makeHeader(byte[] arg13, MODE arg14) { Object[] v8 = new Object[]{arg13, arg14}; ChangeQuickRedirect v11 = WTSign.changeQuickRedirect; if(PatchProxy.isSupport(v8, null, v11, true, &quot;4371e5fcb0c4ae2bd761bbf35c1a43bf&quot;, 0x6000000000000000L)) { return (String)PatchProxy.accessDispatch(v8, null, v11, true, &quot;4371e5fcb0c4ae2bd761bbf35c1a43bf&quot;); } if(arg13 == null) { return &quot;-2003&quot;; } Object[] v13 = NBridge.main3(2, new Object[]{MTGuard.sAppKey, arg13, ((int)arg14.mode)}); if(v13 == null) { return &quot;-1001&quot;; } return (v13[0] instanceof Integer) ? v13[0] : ((String)v13[0]); } 最终会走到Native层进行签名计算 5.2、加密系统环境信息12345678910// 是否root、ADB调试状态、USB调试模式等{ &quot;b1&quot;: &quot;{\\&quot;1\\&quot;:\\&quot;\\&quot;,\\&quot;2\\&quot;:\\&quot;1|2|3\\&quot;,\\&quot;3\\&quot;:\\&quot;\\&quot;,\\&quot;4\\&quot;:\\&quot;\\&quot;,\\&quot;5\\&quot;:\\&quot;\\&quot;,\\&quot;6\\&quot;:\\&quot;\\&quot;,\\&quot;7\\&quot;:\\&quot;2\\&quot;,\\&quot;8\\&quot;:\\&quot;\\&quot;,\\&quot;9\\&quot;:\\&quot;\\&quot;,\\&quot;10\\&quot;:\\&quot;\\&quot;,\\&quot;11\\&quot;:\\&quot;\\&quot;,\\&quot;12\\&quot;:\\&quot;32\\&quot;,\\&quot;13\\&quot;:\\&quot;\\&quot;,\\&quot;14\\&quot;:\\&quot;\\&quot;,\\&quot;15\\&quot;:\\&quot;\\&quot;,\\&quot;33\\&quot;:{\\&quot;0\\&quot;:2,\\&quot;1\\&quot;:\\&quot;\\&quot;,\\&quot;2\\&quot;:\\&quot;\\&quot;,\\&quot;3\\&quot;:\\&quot;\\&quot;,\\&quot;4\\&quot;:\\&quot;2|22\\&quot;,\\&quot;5\\&quot;:\\&quot;\\&quot;,\\&quot;6\\&quot;:\\&quot;\\&quot;,\\&quot;7\\&quot;:\\&quot;\\&quot;,\\&quot;8\\&quot;:\\&quot;\\&quot;,\\&quot;9\\&quot;:\\&quot;\\&quot;,\\&quot;10\\&quot;:\\&quot;\\&quot;,\\&quot;11\\&quot;:\\&quot;\\&quot;,\\&quot;12\\&quot;:\\&quot;\\&quot;,\\&quot;13\\&quot;:\\&quot;\\&quot;,\\&quot;14\\&quot;:\\&quot;2\\&quot;,\\&quot;15\\&quot;:\\&quot;\\&quot;}}&quot;, &quot;b2&quot;: 35, &quot;b3&quot;: 0, &quot;b4&quot;: &quot;com.sankuai.meituan&quot;, &quot;b5&quot;: &quot;11.12.204&quot;, &quot;b6&quot;: &quot;1100120204&quot;, &quot;b7&quot;: 1631754559} 压缩信息 12345678910E53E7D80 78 9C 9D 91 C1 0E C2 20 10 44 FF 65 CF 0D 61 76 x........D.e..avE53E7D90 81 2A DF C2 A5 35 1E 1A D3 7A D0 9E DA FE BB 40 .*...5....О ...@E53E7DA0 4D C0 A4 C6 C4 D3 3E 66 17 66 36 2C D4 83 3C 2D M......f.f6,ԃ &lt;-E53E7DB0 81 10 C8 07 0A D4 04 E2 8C 58 79 95 7C 96 D2 32 ..........y.|...E53E7DC0 05 6D 41 57 B0 CD C8 99 4F 45 3E 17 84 AE B8 72 .mAW....OE&gt;....rE53E7DD0 C5 6E 2B FB 5D 54 A6 A8 5C 51 D9 4A 9A 89 D1 D3 ..+.]T..\\Q......E53E7DE0 83 DC 1C AC 70 9C 9E 57 E6 9F 1B FC BF C0 B7 F8 ....p..W........E53E7DF0 FC 99 7F DB A8 A1 9E C9 8B 8D 55 C8 EB 58 4C FC .......ɋ .U..XL.E53E7E00 8B CB 7D 54 8F 6E BA CD DD A0 C6 EB F0 9C BB 29 ...T.n..........E53E7E10 4D DA D8 02 14 58 B1 36 49 70 59 D0 1A AC DF 4A M....X.6IpY..... 组合密钥 11631754963 9b69f861-e054-4bc4-9daf-d36ae205ed3e //当前时间加APPkey RC4加密压缩后数据 12345678910.text:C881966C 11 99 LDR R1, [SP,#0x44].text:C881966E 0E 9E LDR R6, [SP,#0x38].text:C8819670 8A 59 LDR R2, [R1,R6].text:C8819672 16 A8 ADD R0, SP, #0x58 ; 'X'.text:C8819674 1A F0 B0 FF BL initkey_sub_C79725D8 ; R1:key 15525971099b69f861-e054-4bc4-9daf-d36ae205ed3e R2:长度0x2E.text:C8819678 10 9B LDR R3, [SP,#0x40].text:C881967A 29 00 MOVS R1, R5.text:C881967C 2A 00 MOVS R2, R5.text:C881967E 1A F0 B2 FF BL RC4_sub_C79725E6 ; R0:初始化的KEY，R1：压缩后数据,R3:压缩后大小.text:C8819682 11 98 LDR R0, [SP,#0x44] 加密后 12345678910E53E7D80 62 16 1F 8D D5 8D AF 42 8B D2 2C 32 77 29 5A 5F b...Ս .B...2w)Z_E53E7D90 1B ED 38 9E F7 85 82 50 E0 FA D1 0A CD C4 6F 29 ..............o)E53E7DA0 69 0C FA 10 AE 63 57 E1 11 EA A4 DF 12 36 B2 4D i....cW......6.ME53E7DB0 A0 A2 78 3B 5A 60 E6 AB E9 4C A1 13 CD DB EB F0 ..x;Z`...L......E53E7DC0 1B FC 49 D2 6C CE 5A 96 C6 6B 71 45 80 8B 5D B7 ..I.......qE..].E53E7DD0 97 54 D5 58 0F F8 5E 68 25 CE 31 58 2D 04 C0 F2 .T....^h%..X-...E53E7DE0 70 E7 D4 2E E7 C9 2C DD 07 F2 7A F4 CA 06 F3 CB p...............E53E7DF0 C3 CC 14 76 0A 44 2C 48 A2 35 6B 7D 0D 8C 51 60 ...v.D,H.5k}..Q`E53E7E00 3F A9 F8 C6 D1 02 04 2B A3 BF 86 3F 54 83 D4 43 ?......+...?T...E53E7E10 39 9C AB 66 0D DD 21 90 2B 73 B9 1F C3 C2 B8 86 9..f....+s...... Base64加密 1An2sai6nXEuFYeKbDUk/qEo/7am8Jtn3O2Has5efofCux7iubGRCS8TKpjUgotJ6MGdQrBsvwh/peZwuikT+5rCr4RzN8SXXCeDOtZQ6sbo/snVdESSJweNqd6i/WbIwDOgv5eaWRQoISjdgNfW3hk7tf0QhsZFbOELcPxz5pRzo6d6EsBLFu5Mq8DbVNgsYF+6aqZ7302/G+Rr7MlUT2M9y3EjgjH01L39q/eRJ 5.3、获取dfpid (设备指纹)判断本地是否有存储，如果有优先读取本地，如果无反谢java层从服务器端获取，这部分详细分析见后面设备指纹部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291.text:C8A93C78 F0 B5 PUSH {R4-R7,LR}.text:C8A93C7A 03 AF ADD R7, SP, #0xC.text:C8A93C7C 91 B0 SUB SP, SP, #0x44.text:C8A93C7E 09 92 STR R2, [SP,#0x50+var_2C].text:C8A93C80 0A 91 STR R1, [SP,#0x50+var_28].text:C8A93C82 01 B4 PUSH {R0}.text:C8A93C84 10 BC POP {R4}.text:C8A93C86 8E 48 LDR R0, =(__stack_chk_guard_ptr - 0xC8A93C8C).text:C8A93C88 78 44 ADD R0, PC ; __stack_chk_guard_ptr.text:C8A93C8A 05 68 LDR R5, [R0] ; __stack_chk_guard.text:C8A93C8C 28 68 LDR R0, [R5].text:C8A93C8E 10 90 STR R0, [SP,#0x50+var_10].text:C8A93C90 20 00 MOVS R0, R4.text:C8A93C92 00 F0 3F F9 BL getClassLoader_sub_C6FD9F14.text:C8A93C96 00 26 MOVS R6, #0.text:C8A93C98 00 28 CMP R0, #0.text:C8A93C9A 00 D1 BNE loc_C8A93C9E.text:C8A93C9C 06 E1 B loc_C8A93EAC.text:C8A93C9E ; ---------------------------------------------------------------------------.text:C8A93C9E.text:C8A93C9E loc_C8A93C9E ; CODE XREF: main2_sub_B6891C78+22↑j.text:C8A93C9E 0B 90 STR R0, [SP,#0x50+var_24].text:C8A93CA0 F6 F7 EE FC BL malloc_sub_C8BC6680.text:C8A93CA4 9C 21 MOVS R1, #0x9C.text:C8A93CA6 41 58 LDR R1, [R0,R1] ; char *.text:C8A93CA8 0E AE ADD R6, SP, #0x50+var_18.text:C8A93CAA 0D AA ADD R2, SP, #0x50+var_1C.text:C8A93CAC 30 00 MOVS R0, R6 ; int.text:C8A93CAE 6F F0 F7 FF BL basic_string_sub_B2943CA0.text:C8A93CB2 20 00 MOVS R0, R4.text:C8A93CB4 31 00 MOVS R1, R6.text:C8A93CB6 03 F0 35 FF BL NewStringUTF_sub_C6B9DB24.text:C8A93CBA 26 00 MOVS R6, R4.text:C8A93CBC 04 00 MOVS R4, R0.text:C8A93CBE 0E 98 LDR R0, [SP,#0x50+var_18].text:C8A93CC0 0C 38 SUBS R0, #0xC.text:C8A93CC2 0F A9 ADD R1, SP, #0x50+var_14.text:C8A93CC4 6F F0 40 FD BL free_sub_B2943748.text:C8A93CC8 0C 96 STR R6, [SP,#0x50+var_20].text:C8A93CCA 30 00 MOVS R0, R6.text:C8A93CCC 07 F0 FC FD BL ExceptionCheck_sub_C6BA18C8.text:C8A93CD0 00 26 MOVS R6, #0.text:C8A93CD2 00 28 CMP R0, #0.text:C8A93CD4 07 D0 BEQ loc_C8A93CE6.text:C8A93CD6 00 2C CMP R4, #0.text:C8A93CD8 00 D1 BNE loc_C8A93CDC.text:C8A93CDA E2 E0 B loc_C8A93EA2.text:C8A93CDC ; ---------------------------------------------------------------------------.text:C8A93CDC.text:C8A93CDC loc_C8A93CDC ; CODE XREF: main2_sub_B6891C78+60↑j.text:C8A93CDC 08 94 STR R4, [SP,#0x50+var_30].text:C8A93CDE 07 95 STR R5, [SP,#0x50+var_34].text:C8A93CE0 00 26 MOVS R6, #0.text:C8A93CE2 0C 9C LDR R4, [SP,#0x50+var_20].text:C8A93CE4 D7 E0 B loc_C8A93E96.text:C8A93CE6 ; ---------------------------------------------------------------------------.text:C8A93CE6.text:C8A93CE6 loc_C8A93CE6 ; CODE XREF: main2_sub_B6891C78+5C↑j.text:C8A93CE6 00 2C CMP R4, #0.text:C8A93CE8 00 D1 BNE loc_C8A93CEC.text:C8A93CEA DA E0 B loc_C8A93EA2.text:C8A93CEC ; ---------------------------------------------------------------------------.text:C8A93CEC.text:C8A93CEC loc_C8A93CEC ; CODE XREF: main2_sub_B6891C78+70↑j.text:C8A93CEC 08 94 STR R4, [SP,#0x50+var_30].text:C8A93CEE 07 95 STR R5, [SP,#0x50+var_34].text:C8A93CF0 74 4E LDR R6, =(byte_C8B2D4E0 - 0xC8A93CF6).text:C8A93CF2 7E 44 ADD R6, PC ; byte_C8B2D4E0.text:C8A93CF4 30 78 LDRB R0, [R6].text:C8A93CF6 00 28 CMP R0, #0.text:C8A93CF8 0A D1 BNE loc_C8A93D10.text:C8A93CFA 73 4C LDR R4, =(aJavaLangClassl - 0xC8A93D00) ; &quot;java/lang/ClassLoader&quot;.text:C8A93CFC 7C 44 ADD R4, PC ; &quot;java/lang/ClassLoader&quot;.text:C8A93CFE 73 49 LDR R1, =(unk_C8B1E8A0 - 0xC8A93D04).text:C8A93D00 79 44 ADD R1, PC ; unk_C8B1E8A0.text:C8A93D02 00 25 MOVS R5, #0.text:C8A93D04 15 23 MOVS R3, #0x15.text:C8A93D06 20 00 MOVS R0, R4.text:C8A93D08 2A 00 MOVS R2, R5.text:C8A93D0A F7 F7 A9 F9 BL DecString.text:C8A93D0E 65 75 STRB R5, [R4,#(aJavaLangClassl+0x15 - 0xC8B1E489)] ; &quot;&quot;.text:C8A93D10.text:C8A93D10 loc_C8A93D10 ; CODE XREF: main2_sub_B6891C78+80↑j.text:C8A93D10 01 20 MOVS R0, #1.text:C8A93D12 06 90 STR R0, [SP,#0x50+var_38].text:C8A93D14 30 70 STRB R0, [R6].text:C8A93D16 0C 9C LDR R4, [SP,#0x50+var_20].text:C8A93D18 20 68 LDR R0, [R4].text:C8A93D1A 82 69 LDR R2, [R0,#0x18].text:C8A93D1C 6C 49 LDR R1, =(aJavaLangClassl - 0xC8A93D22) ; &quot;java/lang/ClassLoader&quot;.text:C8A93D1E 79 44 ADD R1, PC ; &quot;java/lang/ClassLoader&quot;.text:C8A93D20 20 00 MOVS R0, R4.text:C8A93D22 90 47 BLX R2.text:C8A93D24 05 00 MOVS R5, R0.text:C8A93D26 20 00 MOVS R0, R4.text:C8A93D28 07 F0 CE FD BL ExceptionCheck_sub_C6BA18C8.text:C8A93D2C 00 26 MOVS R6, #0.text:C8A93D2E 00 28 CMP R0, #0.text:C8A93D30 05 D0 BEQ loc_C8A93D3E.text:C8A93D32 00 2D CMP R5, #0.text:C8A93D34 20 B4 PUSH {R5}.text:C8A93D36 02 BC POP {R1}.text:C8A93D38 00 D0 BEQ loc_C8A93D3C.text:C8A93D3A A8 E0 B loc_C8A93E8E.text:C8A93D3C ; ---------------------------------------------------------------------------.text:C8A93D3C.text:C8A93D3C loc_C8A93D3C ; CODE XREF: main2_sub_B6891C78+C0↑j.text:C8A93D3C AB E0 B loc_C8A93E96.text:C8A93D3E ; ---------------------------------------------------------------------------.text:C8A93D3E.text:C8A93D3E loc_C8A93D3E ; CODE XREF: main2_sub_B6891C78+B8↑j.text:C8A93D3E 00 2D CMP R5, #0.text:C8A93D40 00 D1 BNE loc_C8A93D44.text:C8A93D42 A8 E0 B loc_C8A93E96.text:C8A93D44 ; ---------------------------------------------------------------------------.text:C8A93D44.text:C8A93D44 loc_C8A93D44 ; CODE XREF: main2_sub_B6891C78+C8↑j.text:C8A93D44 05 95 STR R5, [SP,#0x50+var_3C].text:C8A93D46 63 4E LDR R6, =(byte_C8B2D4E1 - 0xC8A93D4C).text:C8A93D48 7E 44 ADD R6, PC ; byte_C8B2D4E1.text:C8A93D4A 30 78 LDRB R0, [R6].text:C8A93D4C 00 28 CMP R0, #0.text:C8A93D4E 0A D1 BNE loc_C8A93D66.text:C8A93D50 61 4D LDR R5, =(aLoadclass - 0xC8A93D56) ; &quot;loadClass&quot;.text:C8A93D52 7D 44 ADD R5, PC ; &quot;loadClass&quot;.text:C8A93D54 61 49 LDR R1, =(aMkfnnRej - 0xC8A93D5A) ; &quot;mkfnN|rej&quot;.text:C8A93D56 79 44 ADD R1, PC ; &quot;mkfnN|rej&quot;.text:C8A93D58 01 22 MOVS R2, #1.text:C8A93D5A 09 23 MOVS R3, #9.text:C8A93D5C 28 00 MOVS R0, R5.text:C8A93D5E F7 F7 7F F9 BL DecString.text:C8A93D62 00 20 MOVS R0, #0.text:C8A93D64 68 72 STRB R0, [R5,#(aLoadclass+9 - 0xC8B1E49F)] ; &quot;&quot;.text:C8A93D66.text:C8A93D66 loc_C8A93D66 ; CODE XREF: main2_sub_B6891C78+D6↑j.text:C8A93D66 06 9D LDR R5, [SP,#0x50+var_38].text:C8A93D68 35 70 STRB R5, [R6].text:C8A93D6A 5D 4E LDR R6, =(byte_C8B2D4E2 - 0xC8A93D70).text:C8A93D6C 7E 44 ADD R6, PC ; byte_C8B2D4E2.text:C8A93D6E 30 78 LDRB R0, [R6].text:C8A93D70 00 28 CMP R0, #0.text:C8A93D72 0E D1 BNE loc_C8A93D92.text:C8A93D74 5B 48 LDR R0, =(aLjavaLangStrin - 0xC8A93D7A) ; &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;.text:C8A93D76 78 44 ADD R0, PC ; &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;.text:C8A93D78 03 90 STR R0, [SP,#0x50+var_44].text:C8A93D7A 5B 49 LDR R1, =(unk_C8B1E8C0 - 0xC8A93D80).text:C8A93D7C 79 44 ADD R1, PC ; unk_C8B1E8C0.text:C8A93D7E 02 22 MOVS R2, #2.text:C8A93D80 25 23 MOVS R3, #0x25 ; '%'.text:C8A93D82 04 93 STR R3, [SP,#0x50+var_40].text:C8A93D84 04 9B LDR R3, [SP,#0x50+var_40].text:C8A93D86 F7 F7 6B F9 BL DecString.text:C8A93D8A 00 20 MOVS R0, #0.text:C8A93D8C 04 99 LDR R1, [SP,#0x50+var_40].text:C8A93D8E 03 9A LDR R2, [SP,#0x50+var_44].text:C8A93D90 50 54 STRB R0, [R2,R1].text:C8A93D92.text:C8A93D92 loc_C8A93D92 ; CODE XREF: main2_sub_B6891C78+FA↑j.text:C8A93D92 35 70 STRB R5, [R6].text:C8A93D94 20 68 LDR R0, [R4].text:C8A93D96 84 21 MOVS R1, #0x84.text:C8A93D98 46 58 LDR R6, [R0,R1].text:C8A93D9A 54 4A LDR R2, =(aLoadclass - 0xC8A93DA0) ; &quot;loadClass&quot;.text:C8A93D9C 7A 44 ADD R2, PC ; &quot;loadClass&quot;.text:C8A93D9E 54 4B LDR R3, =(aLjavaLangStrin - 0xC8A93DA4) ; &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;.text:C8A93DA0 7B 44 ADD R3, PC ; &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;.text:C8A93DA2 20 00 MOVS R0, R4.text:C8A93DA4 05 99 LDR R1, [SP,#0x50+var_3C].text:C8A93DA6 B0 47 BLX R6.text:C8A93DA8 05 00 MOVS R5, R0.text:C8A93DAA 20 00 MOVS R0, R4.text:C8A93DAC 07 F0 8C FD BL ExceptionCheck_sub_C6BA18C8.text:C8A93DB0 00 26 MOVS R6, #0.text:C8A93DB2 00 28 CMP R0, #0.text:C8A93DB4 6A D1 BNE loc_C8A93E8C.text:C8A93DB6 00 2D CMP R5, #0.text:C8A93DB8 68 D0 BEQ loc_C8A93E8C.text:C8A93DBA 20 00 MOVS R0, R4.text:C8A93DBC 0B 99 LDR R1, [SP,#0x50+var_24].text:C8A93DBE 2A 00 MOVS R2, R5.text:C8A93DC0 08 9B LDR R3, [SP,#0x50+var_30].text:C8A93DC2 00 F0 13 F9 BL CallObjectMethodV_sub_C6B99FEC.text:C8A93DC6 05 00 MOVS R5, R0.text:C8A93DC8 20 00 MOVS R0, R4.text:C8A93DCA 07 F0 7D FD BL ExceptionCheck_sub_C6BA18C8.text:C8A93DCE 00 28 CMP R0, #0.text:C8A93DD0 04 D0 BEQ loc_C8A93DDC.text:C8A93DD2 00 26 MOVS R6, #0.text:C8A93DD4 00 2D CMP R5, #0.text:C8A93DD6 05 99 LDR R1, [SP,#0x50+var_3C].text:C8A93DD8 53 D1 BNE loc_C8A93E82.text:C8A93DDA 58 E0 B loc_C8A93E8E.text:C8A93DDC ; ---------------------------------------------------------------------------.text:C8A93DDC.text:C8A93DDC loc_C8A93DDC ; CODE XREF: main2_sub_B6891C78+158↑j.text:C8A93DDC 00 2D CMP R5, #0.text:C8A93DDE 05 99 LDR R1, [SP,#0x50+var_3C].text:C8A93DE0 55 D0 BEQ loc_C8A93E8E.text:C8A93DE2 04 95 STR R5, [SP,#0x50+var_40].text:C8A93DE4 43 4E LDR R6, =(byte_C8B2D4E3 - 0xC8A93DEA).text:C8A93DE6 7E 44 ADD R6, PC ; byte_C8B2D4E3.text:C8A93DE8 30 78 LDRB R0, [R6].text:C8A93DEA 00 28 CMP R0, #0.text:C8A93DEC 0A D1 BNE loc_C8A93E04.text:C8A93DEE 42 4D LDR R5, =(aMain2 - 0xC8A93DF4) ; &quot;main2&quot;.text:C8A93DF0 7D 44 ADD R5, PC ; &quot;main2&quot;.text:C8A93DF2 42 49 LDR R1, =(aNgB - 0xC8A93DF8) ; &quot;ng`b=&quot;.text:C8A93DF4 79 44 ADD R1, PC ; &quot;ng`b=&quot;.text:C8A93DF6 03 22 MOVS R2, #3.text:C8A93DF8 05 23 MOVS R3, #5.text:C8A93DFA 28 00 MOVS R0, R5.text:C8A93DFC F7 F7 30 F9 BL DecString.text:C8A93E00 00 20 MOVS R0, #0.text:C8A93E02 68 71 STRB R0, [R5,#(aMain2+5 - 0xC8B1E4CF)] ; &quot;&quot;.text:C8A93E04.text:C8A93E04 loc_C8A93E04 ; CODE XREF: main2_sub_B6891C78+174↑j.text:C8A93E04 06 9D LDR R5, [SP,#0x50+var_38].text:C8A93E06 35 70 STRB R5, [R6].text:C8A93E08 3D 4E LDR R6, =(byte_C8B2D4E4 - 0xC8A93E0E).text:C8A93E0A 7E 44 ADD R6, PC ; byte_C8B2D4E4.text:C8A93E0C 30 78 LDRB R0, [R6].text:C8A93E0E 00 28 CMP R0, #0.text:C8A93E10 0E D1 BNE loc_C8A93E30.text:C8A93E12 3C 48 LDR R0, =(aILjavaLangObje_0 - 0xC8A93E18) ; &quot;(I[Ljava/lang/Object;)Ljava/lang/Object&quot;....text:C8A93E14 78 44 ADD R0, PC ; &quot;(I[Ljava/lang/Object;)Ljava/lang/Object&quot;....text:C8A93E16 02 90 STR R0, [SP,#0x50+var_48].text:C8A93E18 3B 49 LDR R1, =(unk_C8B1E8F0 - 0xC8A93E1E).text:C8A93E1A 79 44 ADD R1, PC ; unk_C8B1E8F0.text:C8A93E1C 04 22 MOVS R2, #4.text:C8A93E1E 28 23 MOVS R3, #0x28 ; '('.text:C8A93E20 03 93 STR R3, [SP,#0x50+var_44].text:C8A93E22 03 9B LDR R3, [SP,#0x50+var_44].text:C8A93E24 F7 F7 1C F9 BL DecString.text:C8A93E28 00 20 MOVS R0, #0.text:C8A93E2A 03 99 LDR R1, [SP,#0x50+var_44].text:C8A93E2C 02 9A LDR R2, [SP,#0x50+var_48].text:C8A93E2E 50 54 STRB R0, [R2,R1].text:C8A93E30.text:C8A93E30 loc_C8A93E30 ; CODE XREF: main2_sub_B6891C78+198↑j.text:C8A93E30 35 70 STRB R5, [R6].text:C8A93E32 71 20 80 00 MOVS R0, #0x1C4.text:C8A93E36 21 68 LDR R1, [R4].text:C8A93E38 0D 58 LDR R5, [R1,R0].text:C8A93E3A 34 4A LDR R2, =(aMain2 - 0xC8A93E40) ; &quot;main2&quot;.text:C8A93E3C 7A 44 ADD R2, PC ; &quot;main2&quot;.text:C8A93E3E 34 4B LDR R3, =(aILjavaLangObje_0 - 0xC8A93E44) ; &quot;(I[Ljava/lang/Object;)Ljava/lang/Object&quot;....text:C8A93E40 7B 44 ADD R3, PC ; &quot;(I[Ljava/lang/Object;)Ljava/lang/Object&quot;....text:C8A93E42 20 00 MOVS R0, R4.text:C8A93E44 04 99 LDR R1, [SP,#0x50+var_40].text:C8A93E46 A8 47 BLX R5.text:C8A93E48 05 00 MOVS R5, R0.text:C8A93E4A 20 00 MOVS R0, R4.text:C8A93E4C 07 F0 3C FD BL ExceptionCheck_sub_C6BA18C8.text:C8A93E50 00 26 MOVS R6, #0.text:C8A93E52 00 28 CMP R0, #0.text:C8A93E54 14 D1 BNE loc_C8A93E80.text:C8A93E56 2A 00 MOVS R2, R5.text:C8A93E58 00 2D CMP R5, #0.text:C8A93E5A 04 9D LDR R5, [SP,#0x50+var_40].text:C8A93E5C 11 D0 BEQ loc_C8A93E82.text:C8A93E5E 68 46 MOV R0, SP.text:C8A93E60 09 99 LDR R1, [SP,#0x50+var_2C].text:C8A93E62 01 60 STR R1, [R0,#0x50+var_50].text:C8A93E64 20 00 MOVS R0, R4.text:C8A93E66 29 00 MOVS R1, R5.text:C8A93E68 0A 9B LDR R3, [SP,#0x50+var_28].text:C8A93E6A 00 F0 DD F8 BL CallStaticObjectMethodV_sub_B6892028.text:C8A93E6E 0A 90 STR R0, [SP,#0x50+var_28].text:C8A93E70 20 00 MOVS R0, R4.text:C8A93E72 07 F0 29 FD BL ExceptionCheck_sub_C6BA18C8.text:C8A93E76 00 26 MOVS R6, #0.text:C8A93E78 00 28 CMP R0, #0.text:C8A93E7A 02 D1 BNE loc_C8A93E82.text:C8A93E7C 0A 9E LDR R6, [SP,#0x50+var_28].text:C8A93E7E 00 E0 B loc_C8A93E82.text:C8A93E80 ; ---------------------------------------------------------------------------.text:C8A93E80.text:C8A93E80 loc_C8A93E80 ; CODE XREF: main2_sub_B6891C78+1DC↑j.text:C8A93E80 04 9D LDR R5, [SP,#0x50+var_40].text:C8A93E82.text:C8A93E82 loc_C8A93E82 ; CODE XREF: main2_sub_B6891C78+160↑j.text:C8A93E82 ; main2_sub_B6891C78+1E4↑j ....text:C8A93E82 20 68 LDR R0, [R4].text:C8A93E84 C2 6D LDR R2, [R0,#0x5C].text:C8A93E86 20 00 MOVS R0, R4.text:C8A93E88 29 00 MOVS R1, R5.text:C8A93E8A 90 47 BLX R2.text:C8A93E8C.text:C8A93E8C loc_C8A93E8C ; CODE XREF: main2_sub_B6891C78+13C↑j.text:C8A93E8C ; main2_sub_B6891C78+140↑j.text:C8A93E8C 05 99 LDR R1, [SP,#0x50+var_3C] 获取到的dfpid如下: 1DAD796C46B5A6525F4B89DF661A97C7A218A219FC24B93F689DEBD92 5.4、获取xid (设备指纹)判断本地是否有存储，如果有优先读取本地，如果无反谢java层从服务器端获取，APP第一次运行进就用UUID与时间加密生成一个，这部分详细分析见后面设备指纹部分。 1234567891011121314151617181920212223242526272829303132.text:C8AEE3A4 F0 B5 PUSH {R4-R7,LR}.text:C8AEE3A6 03 AF ADD R7, SP, #0xC.text:C8AEE3A8 81 B0 SUB SP, SP, #4.text:C8AEE3AA 0C 00 MOVS R4, R1.text:C8AEE3AC 06 00 MOVS R6, R0.text:C8AEE3AE 00 23 MOVS R3, #0.text:C8AEE3B0 20 00 MOVS R0, R4.text:C8AEE3B2 11 00 MOVS R1, R2.text:C8AEE3B4 1A 00 MOVS R2, R3.text:C8AEE3B6 A5 F7 5F FC BL main2_sub_B6891C78 ; 反射调用java层.text:C8AEE3BA 05 00 MOVS R5, R0.text:C8AEE3BC 20 00 MOVS R0, R4.text:C8AEE3BE AD F7 83 FA BL ExceptionCheck_sub_C6BA18C8.text:C8AEE3C2 00 28 CMP R0, #0.text:C8AEE3C4 09 D0 BEQ loc_C8AEE3DA.text:C8AEE3C6 9C F7 5B F9 BL malloc_sub_C8BC6680.text:C8AEE3CA 01 00 MOVS R1, R0.text:C8AEE3CC 7C 31 ADDS R1, #0x7C ; '|'.text:C8AEE3CE 30 00 MOVS R0, R6.text:C8AEE3D0 15 F0 30 FA BL empty_sub_C6C09834.text:C8AEE3D4 00 2D CMP R5, #0.text:C8AEE3D6 07 D1 BNE loc_C8AEE3E8.text:C8AEE3D8 13 E0 B loc_C8AEE402.text:C8AEE3DA ; ---------------------------------------------------------------------------.text:C8AEE3DA.text:C8AEE3DA loc_C8AEE3DA ; CODE XREF: main2_sub_B292E3A4+20↑j.text:C8AEE3DA 00 2D CMP R5, #0.text:C8AEE3DC 0A D0 BEQ loc_C8AEE3F4.text:C8AEE3DE 30 00 MOVS R0, R6.text:C8AEE3E0 21 00 MOVS R1, R4.text:C8AEE3E2 2A 00 MOVS R2, R5.text:C8AEE3E4 A9 F7 CE FC BL String_sub_B28D7D84 ; 出现字符串 获取到的xid如下: 1Rs8NOy0BFS5JQxfdOoIxpMnKV3iqYWcblAjp0vpnWZyNzyF9rfsi3ekpm4ScaIZgeImizX/5AbS3e838Or4el4+PPPI2kD8XW+8vbvjDBSM= 组合json 12345678910111213{ &quot;a0&quot;: &quot;2.0&quot;, &quot;a1&quot;: &quot;9b69f861-e054-4bc4-9daf-d36ae205ed3e&quot;, &quot;a3&quot;: 2, &quot;a4&quot;: 1631754963, &quot;a5&quot;: &quot;An2sai6nXEuFYeKbDUk/qEo/7am8Jtn3O2Has5efofCux7iubGRCS8TKpjUgotJ6MGdQrBsvwh/peZwuikT+5rCr4RzN8SXXCeDOtZQ6sbo/snVdESSJweNqd6i/WbIwDOgv5eaWRQoISjdgNfW3hk7tf0QhsZFbOELcPxz5pRzo6d6EsBLFu5Mq8DbVNgsYF+6aqZ7302/G+Rr7MlUT2M9y3EjgjH01L39q/eRJ&quot;, &quot;a6&quot;: 1025, &quot;a7&quot;: &quot;Rs8NOy0BFS5JQxfdOoIxpMnKV3iqYWcblAjp0vpnWZyNzyF9rfsi3ekpm4ScaIZgeImizX/5AbS3e838Or4el4+PPPI2kD8XW+8vbvjDBSM=&quot;, &quot;a8&quot;: &quot;DAD796C46B5A6525F4B89DF661A97C7A218A219FC24B93F689DEBD92&quot;, &quot;a9&quot;: &quot;f4ec12efNkQBqdtVlV78x1/Mln2Us/xw171NuJjdEXrGWsFDdMV5Te45wqjL0nPO8OFFKjvKthvva+lS9xqhMhSt1WZRjDYpsWc/eh3z4F2JTv3MOh8NEDmk7Frthx5/bczdDIKvRP0QneTfNKSm116fUjdLhOEYlNbym/xI+5jZAEJGfGjltFLEOmtOwgxasgHQh2woMl/vAyr7ePuoVC6wEcbv2+w6n/+Pl1U1KO2YcTw4peiZDqC7iHpTVQH4fWri9R5+Ev1zx/xObVqoxqe3TEW/t2EIRqQ4QoRZRix0xC6C280faz8U5vOqafUnm+qev7tjs7SOV4SNxBv+LEJTxr5IJU302FJEk/CqhKoz5eWRYtT5Z52kEanlfu4AGHcJLC343kpI3GxYw7uPeewA/Ye0qDgZUyfj0MPpaYMPj0UmtvnbXEU4+FaRaCb/LsQtWdOtEiEKveUQU9bTW4NfHch2+6gcHP2/E+UQSlREX67PPa9XN8tgL4H6qzghiE1NL3gYw0rrjzEXiO6jsjvIdzwDjeab9woJyr8W3xSACz3sezUS+AJAKohnJvlQkFM9cdG3lPYS7gByAK++K2/vI714kxJHqCZQQMbVNsoWj5w64YL+sE1A4byzOPgK71oPb9w6Cb+KwVlDtqH8F5vlVkO23Iq8E28BI2vQuq5TLRzMunjo45Ks2Py9ZZuHkGb+QIVpUz6ViB+JlUONKinIJF1p6g==&quot;, &quot;a10&quot;: &quot;{}&quot;, &quot;x0&quot;: 1} 每一个字段的解释： 10:版本，a1:appkey, a3:版本,a4:时间,a5:加密的设备环境,a6:固定数字,a7:xid,a8:dfpid,a9:初始化时加密的设备环境信息(前8字符中CRC:f4ec12ef) 5.5、计算请求体签名值获取请求体数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748.text:C8A8FA4C 29 68 LDR R1, [R5].text:C8A8FA4E 0A 58 LDR R2, [R1,R0].text:C8A8FA50 28 00 MOVS R0, R5.text:C8A8FA52 31 00 MOVS R1, R6.text:C8A8FA54 90 47 BLX R2 ; 获取body长度.text:C8A8FA56 0A 90 STR R0, [SP,#0x28].text:C8A8FA58 28 00 MOVS R0, R5.text:C8A8FA5A 0B F0 35 FF BL ExceptionCheck_sub_C6BA18C8.text:C8A8FA5E 00 28 CMP R0, #0 .text:C8A8FAF0 00 00 MOVS R0, R0.text:C8A8FAF2 00 00 MOVS R0, R0.text:C8A8FAF4 D8 74 STRB R0, [R3,#0x13].text:C8A8FAF6 86 1B SUBS R6, R0, R6.text:C8A8FAF8 10 99 LDR R1, [SP,#0xC+arg_34] ; 获取body.text:C8A8FAFA 0B 20 MOVS R0, #0xB.text:C8A8FAFC C2 43 MVNS R2, R0.text:C8A8FAFE 03 91 STR R1, [SP,#0xC+arg_0].text:C8A8FB00 08 68 LDR R0, [R1].text:C8A8FB02 02 92 STR R2, [SP,#0xC+var_4].text:C8A8FB04 80 58 LDR R0, [R0,R2].text:C8A8FB06 0A 9C LDR R4, [SP,#0xC+arg_1C].text:C8A8FB08 00 19 ADDS R0, R0, R4.text:C8A8FB0A 04 90 STR R0, [SP,#0xC+arg_4].text:C8A8FB0C 46 1C ADDS R6, R0, #1.text:C8A8FB0E 30 00 MOVS R0, R6.text:C8A8FB10 FA F7 EA E8 BLX malloc ; 分配body存储空间.text:C8A8FB14 00 21 MOVS R1, #0.text:C8A8FB16 06 91 STR R1, [SP,#0xC+arg_C].text:C8A8FB18 32 00 MOVS R2, R6.text:C8A8FB1A 06 00 MOVS R6, R0.text:C8A8FB1C 20 F0 D0 FC BL memset_sub_C6BB64C0.text:C8A8FB20 19 20 40 01 MOVS R0, #0x320.text:C8A8FB24 29 68 LDR R1, [R5].text:C8A8FB26 08 58 LDR R0, [R1,R0].text:C8A8FB28 05 90 STR R0, [SP,#0xC+arg_8].text:C8A8FB2A 68 46 MOV R0, SP.text:C8A8FB2C 06 60 STR R6, [R0,#0xC+var_C].text:C8A8FB2E 28 00 MOVS R0, R5.text:C8A8FB30 07 99 LDR R1, [SP,#0xC+arg_10].text:C8A8FB32 06 9A LDR R2, [SP,#0xC+arg_C].text:C8A8FB34 23 00 MOVS R3, R4.text:C8A8FB36 05 9C LDR R4, [SP,#0xC+arg_8].text:C8A8FB38 A0 47 BLX R4 ; GetByteArrayRegion.text:C8A8FB38 ; 获取要计算签名的body值.text:C8A8FB3A 28 00 MOVS R0, R5.text:C8A8FB3C 0B F0 C4 FE BL ExceptionCheck_sub_C6BA18C8.text:C8A8FB40 00 28 CMP R0, #0 获取的数据(部分) 123456789CB092000 50 4F 53 54 20 2F 76 35 2F 73 69 67 6E 20 7B 22 POST /v5/sign {&quot;CB092010 64 61 74 61 22 3A 22 62 4A 62 50 67 72 4B 49 42 data&quot;:&quot;bJbPgrKIBCB092020 6A 6D 4E 4E 2B 6B 63 30 39 66 66 6F 54 70 67 48 jmNN+kc09ffoTpgHCB092030 57 39 57 46 7A 43 6B 67 75 4D 4E 71 50 52 57 68 W9WFzCkguMNqPRWhCB092040 6A 70 41 67 2B 4E 62 45 70 76 47 62 44 42 54 47 jpAg+NbEpvGbDBTGCB092050 6E 79 31 38 6C 6C 39 38 75 43 37 44 68 67 2B 33 ny18ll98uC7Dhg+3CB092060 56 44 39 31 62 38 50 67 67 47 2F 47 56 61 52 59 VD91b8PggG/GVaRYCB092070 71 4D 4C 37 33 36 30 6E 63 71 41 59 57 37 68 4A qML7360ncqAYW7hJCB092080 4A 52 69 34 44 59 73 50 31 66 73 59 35 38 4F 79 JRi4DYsP1fsY58Oy 解密PIC数据获取key (a7),解密流程与初始化时一样。解密后的值 1{&quot;a1&quot;:0,&quot;a10&quot;:400,&quot;a2&quot;:&quot;com.sankuai.meituan&quot;,&quot;a11&quot;:&quot;c1ee9178c95d9ec75f0f076a374df94a032d54c8576298d4f75e653de3705449&quot;,&quot;a3&quot;:&quot;0a16ecd60eb56a6a3349f66cdcf7f7bf5190e5a42d6280d8dc0ee3be228398ec&quot;,&quot;a4&quot;:1100030200,&quot;k0&quot;:{&quot;k1&quot;:&quot;meituan1sankuai0&quot;,&quot;k2&quot;:&quot;meituan0sankuai1&quot;,&quot;k3&quot;:&quot;$MXMYBS@HelloPay&quot;,&quot;k4&quot;:&quot;Maoyan010iauknaS&quot;,&quot;k5&quot;:&quot;34281a9dw2i701d4&quot;,&quot;k6&quot;:&quot;X%rj@KiuU+|xY}?f&quot;},&quot;a5&quot;:&quot;11.3.200&quot;,&quot;a0&quot;:&quot;pw/LhTdeoTTyaxPHcHMy+/ssGNS1ihNkrJ+uBI74FIfd90KlTil1m0i7FF/n0bhY&quot;,&quot;a6&quot;:&quot;/HntC9XIfdUyII/UiVfx020EQPpHz2XZY3qzM2aiNmM0i0pB1yeSO689TY9SBB3s&quot;,&quot;a7&quot;:&quot;QsHnU6kFjTYR8Z6tHEvkGMO2Hrt+NRnVQhmxg6EtVBzuzQcBpma3AdhTWNMpesFT&quot;,&quot;c0&quot;:{&quot;c1&quot;:true,&quot;c2&quot;:false},&quot;a9&quot;:&quot;SDEzWXi5LHL/cuMCZ1zYyv+0hIViqWWf+ShbUYILWf4=&quot;,&quot;a8&quot;:1603800117167} 解析json获取a7 1QsHnU6kFjTYR8Z6tHEvkGMO2Hrt+NRnVQhmxg6EtVBzuzQcBpma3AdhTWNMpesFT appkey与pic中的a7异或 123456789101112131415.text:C8A90424 20 00 MOVS R0, R4.text:C8A90426 02 99 LDR R1, [SP,#8].text:C8A90428 7E F0 12 FE BL sub_C8B0F050.text:C8A9042C 03 98 LDR R0, [SP,#0xC].text:C8A9042E 00 5D LDRB R0, [R0,R4] ; 取a7 QsHnU6kFjTYR8Z6tHEvkGMO2Hrt+NRnVQhmxg6EtVBzuzQcBpma3AdhTWNMpesFT.text:C8A90430 72 5C LDRB R2, [R6,R1] ; appkey 9b69f861-e054-4bc4-9daf-d36ae205ed3e.text:C8A90432 42 40 EORS R2, R0.text:C8A90434 6A 54 STRB R2, [R5,R1].text:C8A90436 01 34 ADDS R4, #1.text:C8A90438 04 98 LDR R0, [SP,#0x10].text:C8A9043A A0 42 CMP R0, R4 ; 判断是否结束.text:C8A9043C F2 D1 BNE loc_C8A90424.text:C8A9043E 03 B5 PUSH {R0,R1,LR}.text:C8A90440 01 48 LDR R0, =0.text:C8A90442 FF F7 DB FF BL loc_C8A903FC 异或后的值 123BC79D120 5E 54 73 4D 30 7A 4C 44 57 34 53 77 44 40 55 51 ^TsM0zLDW4SwD@UQBC79D130 22 50 45 6D 33 2F 2B 5D 01 40 70 35 2B 60 5E 63 &quot;PEm3/+].@p5+`^cBC79D140 34 0C 5E 1D 再次异或 1234567891011121314.text:C8A91C00 loc_C8A91C00 ; CODE XREF: hmac_sha256_sub_BB754BAC+6C↓j.text:C8A91C00 43 A9 ADD R1, SP, #0x160+var_54.text:C8A91C02 09 5C LDRB R1, [R1,R0] ; 取APPkey与a7加密后数据.text:C8A91C04 5C 22 MOVS R2, #0x5C ; '\\'.text:C8A91C06 4A 40 EORS R2, R1.text:C8A91C08 32 AB ADD R3, SP, #0x160+var_98.text:C8A91C0A 1A 54 STRB R2, [R3,R0] ; 存值.text:C8A91C0C 36 22 MOVS R2, #0x36 ; '6'.text:C8A91C0E 4A 40 EORS R2, R1.text:C8A91C10 21 A9 ADD R1, SP, #0x160+var_DC.text:C8A91C12 0A 54 STRB R2, [R1,R0] ; 存值.text:C8A91C14 01 30 ADDS R0, #1.text:C8A91C16 40 28 CMP R0, #0x40 ; '@' ; 判断是否结束.text:C8A91C18 F2 D1 BNE loc_C8A91C00 异或后的值 1234CB0D3000 68 62 45 7B 06 4C 7A 72 61 02 65 41 72 76 63 67 hbE{.Lzra.eArvcgCB0D3010 14 66 73 5B 05 19 1D 6B 37 76 46 03 1D 56 68 55 .fs[...k7vF..VhUCB0D3020 02 3A 68 2B 36 36 36 36 36 36 36 36 36 36 36 36 .:h+666666666666CB0D3030 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 6666666666666666 将异或后的值与请求体组合 123456789101112CB0D3000 68 62 45 7B 06 4C 7A 72 61 02 65 41 72 76 63 67 hbE{.Lzra.eArvcgCB0D3010 14 66 73 5B 05 19 1D 6B 37 76 46 03 1D 56 68 55 .fs[...k7vF..VhUCB0D3020 02 3A 68 2B 36 36 36 36 36 36 36 36 36 36 36 36 .:h+666666666666CB0D3030 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 36 6666666666666666CB0D3040 50 4F 53 54 20 2F 76 35 2F 73 69 67 6E 20 7B 22 POST /v5/sign {&quot;CB0D3050 64 61 74 61 22 3A 22 62 4A 62 50 67 72 4B 49 42 data&quot;:&quot;bJbPgrKIBCB0D3060 6A 6D 4E 4E 2B 6B 63 30 39 66 66 6F 54 70 67 48 jmNN+kc09ffoTpgHCB0D3070 57 39 57 46 7A 43 6B 67 75 4D 4E 71 50 52 57 68 W9WFzCkguMNqPRWhCB0D3080 6A 70 41 67 2B 4E 62 45 70 76 47 62 44 42 54 47 jpAg+NbEpvGbDBTGCB0D3090 6E 79 31 38 6C 6C 39 38 75 43 37 44 68 67 2B 33 ny18ll98uC7Dhg+3CB0D30A0 56 44 39 31 62 38 50 67 67 47 2F 47 56 61 52 59 VD91b8PggG/GVaRYCB0D30B0 71 4D 4C 37 33 36 30 6E 63 71 41 59 57 37 68 4A qML7360ncqAYW7hJ 计算组合值的MD5 123456789101112131415161718192021.text:C8A91C60 2A 00 MOVS R2, R5.text:C8A91C62 00 F0 79 F9 BL md5_sub_BB7CFF58 ; R0:原始数后,R1:大小,R2:返回.text:C8A91C66 05 AE ADD R6, SP, #0x160+var_14C.text:C8A91C68 55 21 MOVS R1, #0x55 ; 'U'.text:C8A91C6A 30 00 MOVS R0, R6.text:C8A91C6C F8 F7 54 E8 BLX __aeabi_memclr4.text:C8A91C70 32 A9 ADD R1, SP, #0x160+var_98.text:C8A91C72 30 00 MOVS R0, R6.text:C8A91C74 02 9A LDR R2, [SP,#0x160+var_158].text:C8A91C76 1E F0 48 FC BL getvalu_sub_C87B550A.text:C8A91C7A 30 00 MOVS R0, R6.text:C8A91C7C 40 30 ADDS R0, #0x40 ; '@'.text:C8A91C7E 14 22 MOVS R2, #0x14.text:C8A91C80 29 00 MOVS R1, R5.text:C8A91C82 1E F0 42 FC BL getvalu_sub_C87B550A.text:C8A91C86 54 21 MOVS R1, #0x54 ; 'T'.text:C8A91C88 30 00 MOVS R0, R6.text:C8A91C8A 01 9A LDR R2, [SP,#0x160+var_15C].text:C8A91C8C 00 F0 64 F9 BL md5_sub_BB7CFF58 ; R0:原始数后,R1:大小,R2:返回.text:C8A91C90 20 00 MOVS R0, R4 ; p.text:C8A91C92 F8 F7 30 E8 BLX free 计算后得到的值 1F0 EF 16 F8 BD C6 7B CC 8C B4 8F AC 4C EC 7A DB A8 A8 D1 05 解密PIC数据获取KEY(a9)解析json获取a3:0a16ecd60eb56a6a3349f66cdcf7f7bf5190e5a42d6280d8dc0ee3be228398eca3为AES KEY解密a9解密后数据，该值作为加密body md5值的key 13ey2scPxek170m6K AES加密Body计算得到的MD5值 12345678910111213141516171819202122232425262728293031323334353637IV 0102030405060708key:3ey2scPxek170m6K .text:C8AA94F0 E0 F7 FA EB BLX malloc.text:C8AA94F4 00 26 MOVS R6, #0.text:C8AA94F6 00 28 CMP R0, #0.text:C8AA94F8 1C D0 BEQ loc_C8AA9534.text:C8AA94FA 4A 99 LDR R1, [SP,#0x120+arg_0].text:C8AA94FC 03 91 STR R1, [SP,#0x120+var_114].text:C8AA94FE 07 AE ADD R6, SP, #0x120+var_104.text:C8AA9500 F4 21 MOVS R1, #0xF4.text:C8AA9502 02 90 STR R0, [SP,#0x120+var_118].text:C8AA9504 30 00 MOVS R0, R6.text:C8AA9506 E0 F7 08 EC BLX __aeabi_memclr4.text:C8AA950A 80 21 MOVS R1, #0x80.text:C8AA950C 20 00 MOVS R0, R4.text:C8AA950E 32 00 MOVS R2, R6.text:C8AA9510 56 F0 30 FF BL AES_set_Encrypt_key_sub_CB601374 ; R0:key,R1:长度,R2:返回值.text:C8AA9514 06 9A LDR R2, [SP,#0x120+byte_count].text:C8AA9516 01 20 MOVS R0, #1.text:C8AA9518 69 46 MOV R1, SP.text:C8AA951A 04 9B LDR R3, [SP,#0x120+var_110].text:C8AA951C 0B 60 STR R3, [R1,#0x120+var_120].text:C8AA951E 48 60 STR R0, [R1,#0x120+var_11C].text:C8AA9520 05 98 LDR R0, [SP,#0x120+p].text:C8AA9522 02 9C LDR R4, [SP,#0x120+var_118].text:C8AA9524 21 00 MOVS R1, R4.text:C8AA9526 33 00 MOVS R3, R6.text:C8AA9528 57 F0 7A FD BL AES_cbc_Encrypt_sub_CB602020 ; R0：原始数据,R1:返回,R2:大小,R3:key.text:C8AA952C 06 98 LDR R0, [SP,#0x120+byte_count].text:C8AA952E 03 99 LDR R1, [SP,#0x120+var_114].text:C8AA9530 08 60 STR R0, [R1].text:C8AA9532 26 00 MOVS R6, R4.text:C8AA9534.text:C8AA9534 loc_C8AA9534 ; CODE XREF: Aes_sub_CB5AA4B8+40↑j.text:C8AA9534 05 98 LDR R0, [SP,#0x120+p] ; p.text:C8AA9536 E0 F7 DE EB BLX free 加密后数据 12C7B9C460 06 34 4B B7 17 3B 29 9D FE B9 85 8D 24 6C 52 AEC7B9C470 BB AF 22 3F 8E 43 FB C5 66 2B 54 E2 C6 6A 54 EA 转换成字符串 106344bb7173b299dfeb9858d246c52aebbaf223f8e43fbc5662b54e2c66a54ea 组合json,生成签名 1234567891011121314{ &quot;a0&quot;: &quot;2.0&quot;, &quot;a1&quot;: &quot;9b69f861-e054-4bc4-9daf-d36ae205ed3e&quot;, &quot;a3&quot;: 2, &quot;a4&quot;: 1631754963, &quot;a5&quot;: &quot;An2sai6nXEuFYeKbDUk/qEo/7am8Jtn3O2Has5efofCux7iubGRCS8TKpjUgotJ6MGdQrBsvwh/peZwuikT+5rCr4RzN8SXXCeDOtZQ6sbo/snVdESSJweNqd6i/WbIwDOgv5eaWRQoISjdgNfW3hk7tf0QhsZFbOELcPxz5pRzo6d6EsBLFu5Mq8DbVNgsYF+6aqZ7302/G+Rr7MlUT2M9y3EjgjH01L39q/eRJ&quot;, &quot;a6&quot;: 1025, &quot;a7&quot;: &quot;Rs8NOy0BFS5JQxfdOoIxpMnKV3iqYWcblAjp0vpnWZyNzyF9rfsi3ekpm4ScaIZgeImizX/5AbS3e838Or4el4+PPPI2kD8XW+8vbvjDBSM=&quot;, &quot;a8&quot;: &quot;DAD796C46B5A6525F4B89DF661A97C7A218A219FC24B93F689DEBD92&quot;, &quot;a9&quot;: &quot;f4ec12efNkQBqdtVlV78x1/Mln2Us/xw171NuJjdEXrGWsFDdMV5Te45wqjL0nPO8OFFKjvKthvva+lS9xqhMhSt1WZRjDYpsWc/eh3z4F2JTv3MOh8NEDmk7Frthx5/bczdDIKvRP0QneTfNKSm116fUjdLhOEYlNbym/xI+5jZAEJGfGjltFLEOmtOwgxasgHQh2woMl/vAyr7ePuoVC6wEcbv2+w6n/+Pl1U1KO2YcTw4peiZDqC7iHpTVQH4fWri9R5+Ev1zx/xObVqoxqe3TEW/t2EIRqQ4QoRZRix0xC6C280faz8U5vOqafUnm+qev7tjs7SOV4SNxBv+LEJTxr5IJU302FJEk/CqhKoz5eWRYtT5Z52kEanlfu4AGHcJLC343kpI3GxYw7uPeewA/Ye0qDgZUyfj0MPpaYMPj0UmtvnbXEU4+FaRaCb/LsQtWdOtEiEKveUQU9bTW4NfHch2+6gcHP2/E+UQSlREX67PPa9XN8tgL4H6qzghiE1NL3gYw0rrjzEXiO6jsjvIdzwDjeab9woJyr8W3xSACz3sezUS+AJAKohnJvlQkFM9cdG3lPYS7gByAK++K2/vI714kxJHqCZQQMbVNsoWj5w64YL+sE1A4byzOPgK71oPb9w6Cb+KwVlDtqH8F5vlVkO23Iq8E28BI2vQuq5TLRzMunjo45Ks2Py9ZZuHkGb+QIVpUz6ViB+JlUONKinIJF1p6g==&quot;, &quot;a10&quot;: &quot;{}&quot;, &quot;x0&quot;: 1, &quot;a2&quot;: &quot;06344bb7173b299dfeb9858d246c52aebbaf223f8e43fbc5662b54e2c66a54ea&quot;} a2:就是请求体签名值，其它字段上面已经解释过，然后将签名值返回到java层，整个签名流程就完成了。 六、设备指纹分析6.1、dfpid基本流程java层调用fetchDfpId()获取dfpid 12345678910111213141516171819202122232425262728293031323334353637383940public boolean fetchDfpId(boolean arg13) { Object[] v8 = new Object[]{((byte)(((byte)arg13)))}; ChangeQuickRedirect v10 = DFPManager.changeQuickRedirect; if(PatchProxy.isSupport(v8, this, v10, false, &quot;19489f6702cf81011acff69ff203e6a7&quot;, 0x4000000000000000L)) { return ((Boolean)PatchProxy.accessDispatch(v8, this, v10, false, &quot;19489f6702cf81011acff69ff203e6a7&quot;)).booleanValue(); } try { if(this.isOutDate()) { label_49: if(!this.postDFPID(this.encDfpDataForId())) { // 服务器获取 this.ensureLocalID(); // 读取本地ID } } else { if(arg13) { goto label_49; } String v4 = this.idStore.getLocalDFPId(); if(!TextUtils.isEmpty(v4)) { goto label_38; } if(!this.postDFPID(this.encDfpDataForId())) { this.ensureLocalID(); return 1; label_38: this.idCallback.onSuccess(v4, ((long)DFPManager.ONE_HOUR) * ((long)this.idStore.getInterval()) + ((long)this.idStore.getLastUpdateTime()), &quot;get dfp from local store&quot;); long v7 = System.currentTimeMillis(); this.doPersistence(v4, this.idStore.getInterval().longValue(), v7); return 1; } } } catch(Throwable unused_ex) { } return 1; } 调用encDfpDataForId()方法走到Native层获取请求体 12345678910public String encDfpDataForId() { Object[] v8 = new Object[0]; ChangeQuickRedirect v9 = DFPManager.changeQuickRedirect; if(PatchProxy.isSupport(v8, this, v9, false, &quot;c899af894ac6d9a1a9df952ed8770d17&quot;, 0x4000000000000000L)) { return (String)PatchProxy.accessDispatch(v8, this, v9, false, &quot;c899af894ac6d9a1a9df952ed8770d17&quot;); } FamaCollector.hasCollected = true; return NBridge.main1(41, new Object[0]); // 请求体 } 调用postDFPID(String arg12)发送网络请求获取dfpid 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143url: https://appsec-mobile.meituan.com/v5/sign public boolean postDFPID(String arg12) { Object[] v0 = new Object[]{null}; v0[0] = arg12; ChangeQuickRedirect v9 = IDFPManager.changeQuickRedirect; if(PatchProxy.isSupport(v0, this, v9, false, &quot;f625ba5594fc8256be5f644877e817ae&quot;, 0x4000000000000000L)) { return ((Boolean)PatchProxy.accessDispatch(v0, this, v9, false, &quot;f625ba5594fc8256be5f644877e817ae&quot;)).booleanValue(); } Interceptor v0_1 = this.getInterceptor(); String v1 = this.getMtgVersion(); DFPReporter v0_2 = new Builder().addInterceptor(v0_1).addResponseParser(new IResponseParser() { public static ChangeQuickRedirect changeQuickRedirect; @Override // com.meituan.android.common.dfingerprint.network.IResponseParser public boolean onError(Call arg11, IOException arg12) { Object[] v0 = new Object[]{arg11, arg12}; ChangeQuickRedirect v12 = com.meituan.android.common.dfingerprint.interfaces.IDFPManager.1.changeQuickRedirect; if(PatchProxy.isSupport(v0, this, v12, false, &quot;0231e3e90aba1d77b6009d4f4e808ce1&quot;, 0x4000000000000000L)) { return ((Boolean)PatchProxy.accessDispatch(v0, this, v12, false, &quot;0231e3e90aba1d77b6009d4f4e808ce1&quot;)).booleanValue(); } Logger.logD(&quot;/v5/sign onError&quot;); IDFPManager.this.ensureLocalID(); return 1; } @Override // com.meituan.android.common.dfingerprint.network.IResponseParser public boolean onResponse(Response arg23, long arg24, int arg26) { String v2_1; long interval; String dfpid; ResponseBody body; Object[] v11 = new Object[]{arg23, new Long(arg24), ((int)arg26)}; ChangeQuickRedirect v14 = com.meituan.android.common.dfingerprint.interfaces.IDFPManager.1.changeQuickRedirect; if(PatchProxy.isSupport(v11, this, v14, false, &quot;cfa6814ee923204fe513080ced241785&quot;, 0x4000000000000000L)) { return ((Boolean)PatchProxy.accessDispatch(v11, this, v14, false, &quot;cfa6814ee923204fe513080ced241785&quot;)).booleanValue(); } Logger.logD(&quot;/v5/sign onResponse $response&quot;); if(arg23 == null) { return 0; } if(arg23.code() != 200) { MTGlibInterface.raptorAPI(&quot;v5_/v5/sign&quot;, arg23.code(), arg26, 0, System.currentTimeMillis() - arg24); return 0; } try { body = arg23.body(); if(body == null) { IDFPManager.this.idCallback.onFailed(-3, &quot;request body is invalid&quot;); return 0; } String v3 = new String(body.bytes()); MTGlibInterface.raptorAPI(&quot;v5_/v5/sign&quot;, arg23.code(), arg26, v3.length(), System.currentTimeMillis() - arg24); Logger.logD(&quot;RaptorMonitorService &gt;&gt; ${RaptorUtil.API_reportdfpidsync}&quot;); Logger.logD(&quot;RaptorMonitorService result&gt;&gt; ${result}&quot;); if(v3.isEmpty()) { IDFPManager.this.idCallback.onFailed(-3, &quot;request body is invalid&quot;); MTGlibInterface.raptorAPI(&quot;v5_/v5/sign&quot;, 9401, arg26, 0, System.currentTimeMillis() - arg24); return 0; } Logger.logD(&quot;/v5/sign response.body() &gt;&gt; $result&quot;); DFPResponse body_json = (DFPResponse)new Gson().fromJson(v3, DFPResponse.class); if(body_json == null) { goto label_145; } if(body_json.code == 0xFFFFFF80) { goto label_145; } int v3_1 = body_json.code; if(v3_1 != 0) { IDFPManager.this.idCallback.onFailed(v3_1, body_json.message); MTGlibInterface.raptorAPI(&quot;v5_/v5/sign&quot;, 9402, arg26, 0, System.currentTimeMillis() - arg24); return 0; } dfpid = body_json.data.dataDfp; interval = body_json.data.dataInterval; v2_1 = body_json.message; } catch(Exception unused_ex) { IDFPManager.this.ensureLocalID(); MTGlibInterface.raptorAPI(&quot;v5_/v5/sign&quot;, 9405, arg26, 0, System.currentTimeMillis() - arg24); return 0; } try { Logger.logD(&quot;/v5/sign response, dataDecrypt &gt; $dataDecrypt&quot;); } catch(Exception unused_ex) { } try { // 如果等空读取本地的 if(dfpid == &quot;&quot;) { // 如果等空读取本地的 IDFPManager.this.ensureLocalID(); } else { Logger.logD(&quot;/v5/sign 返回新的 local_dfp_id，需要保存它&quot;); long currtime = System.currentTimeMillis(); if(DFPConfigs.isDfpidFirst) { MTGlibInterface.raptorFakeAPI(&quot;v5_dfpid_duration&quot;, 200, System.currentTimeMillis() - MTGuard.sFirstLaunchTime); DFPConfigs.isDfpidFirst = false; } IDFPManager.this.doPersistence(dfpid, interval, currtime); // 保存dfpid IDFPManager.this.idCallback.onSuccess(dfpid, interval * ((long)IDFPManager.ONE_HOUR) + currtime, v2_1); } body.close(); return 1; label_145: IDFPManager.this.idCallback.onFailed(-4, &quot;body parse failed&quot;); } catch(Exception unused_ex) { IDFPManager.this.ensureLocalID(); MTGlibInterface.raptorAPI(&quot;v5_/v5/sign&quot;, 9405, arg26, 0, System.currentTimeMillis() - arg24); } return 0; } }).build(); try { ReqeustBody v2 = new ReqeustBody(arg12, v1, null); Gson v12 = new GsonBuilder().disableHtmlEscaping().create(); if(v12 != null) { String v12_1 = v12.toJson(v2); Logger.logD(&quot;postDFPID body &gt; $body&quot;); return v0_2.reportDFPIDSync(v12_1, ContentType.application_json); // 网络请求 } } catch(Exception unused_ex) { } return false; } 6.2、dfpid请求体分析请求体调用Native层方法NBridge.main(41, new Object[0])在Native层计算得到循环获取设备信息 123456789101112131415161718192021222324.text:C8A8C684 09 98 LDR R0, [SP,#0x24].text:C8A8C686 61 F0 CD FF BL getmContext_sub_CC9EF624 ; 获取上下文件.text:C8A8C68A 07 90 STR R0, [SP,#0x1C].text:C8A8C68C 00 F0 14 FE BL init_DecString_sub_C84582B8.text:C8A8C690 06 90 STR R0, [SP,#0x18].text:C8A8C692 2B A8 ADD R0, SP, #0xAC.text:C8A8C694 05 90 STR R0, [SP,#0x14].text:C8A8C696 09 99 LDR R1, [SP,#0x24].text:C8A8C698 07 9A LDR R2, [SP,#0x1C].text:C8A8C69A 2B 00 MOVS R3, R5.text:C8A8C69C 26 F0 7A FC BL GetDeviceInfo_dispatch_loop_sub_C89F8F94 ; 获取设备信息1.text:C8A8C6A0 06 98 LDR R0, [SP,#0x18].text:C8A8C6A2 29 00 MOVS R1, R5.text:C8A8C6A4 05 9A LDR R2, [SP,#0x14].text:C8A8C6A6 23 F0 8D FF BL jmp_checkField_sub_C89F65C4 ; 判断获取的内容是否为特殊字符mtg_unsupport,mtg_block,setup_empty.text:C8A8C6AA 2B 98 LDR R0, [SP,#0xAC].text:C8A8C6AC 04 99 LDR R1, [SP,#0x10].text:C8A8C6AE 40 18 ADDS R0, R0, R1.text:C8A8C6B0 27 A9 ADD R1, SP, #0x9C.text:C8A8C6B2 77 F0 49 F8 BL free_sub_B2943748.text:C8A8C6B6 07 99 LDR R1, [SP,#0x1C].text:C8A8C6B8 00 29 CMP R1, #0.text:C8A8C6BA 00 D1 BNE loc_C8A8C6BE.text:C8A8C6BC 4C E7 B loc_C8A8C558 在下面地方下好断点跳到获取设备信息的地方，可以绕过代码流程混淆，快速定位到想要获取设备信息的方法： 12345.text:C8AB5134 80 00 LSLS R0, R0, #2 ; 跳到真实执行方法.text:C8AB5136 02 A1 ADR R1, loc_C8AB5140.text:C8AB5138 08 58 LDR R0, [R1,R0] ; 取方法表偏移.text:C8AB513A 08 18 ADDS R0, R1, R0.text:C8AB513C 87 46 MOV PC, R0 获取完设备信息后组合成json，主要获取硬件类ID、imei、mac,系统属性、CPU、内存、陀螺仪传感器等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158{ &quot;m20&quot;: &quot;3&quot;, &quot;m22&quot;: &quot;0&quot;, &quot;m24&quot;: &quot;-1&quot;, &quot;m25&quot;: &quot;0&quot;, &quot;m26&quot;: &quot;0&quot;, &quot;m27&quot;: &quot;DAD703FB1B789AFCFA0CAD4778CF9C8D0146219F941D41B66617A73F&quot;, &quot;m28&quot;: &quot;0&quot;, &quot;m29&quot;: &quot;28.5&quot;, &quot;m30&quot;: &quot;1&quot;, &quot;m31&quot;: &quot;0&quot;, &quot;m32&quot;: &quot;0&quot;, &quot;m33&quot;: &quot;1&quot;, &quot;m34&quot;: &quot;&quot;, &quot;m35&quot;: &quot;0&quot;, &quot;m36&quot;: &quot;0&quot;, &quot;m37&quot;: &quot;0&quot;, &quot;m38&quot;: &quot;1&quot;, &quot;m39&quot;: &quot;Google&quot;, &quot;m40&quot;: &quot;&quot;, &quot;m41&quot;: &quot;&quot;, &quot;m42&quot;: &quot;1&quot;, &quot;m43&quot;: &quot;23132356608&quot;, &quot;m44&quot;: &quot;1230796800000&quot;, &quot;m45&quot;: &quot;1&quot;, &quot;m46&quot;: &quot;&quot;, &quot;m47&quot;: &quot;android&quot;, &quot;m48&quot;: &quot;0&quot;, &quot;m49&quot;: &quot;nonetwork&quot;, &quot;m50&quot;: &quot;user&quot;, &quot;m51&quot;: &quot;1&quot;, &quot;m52&quot;: &quot;google&quot;, &quot;m53&quot;: &quot;unknown&quot;, &quot;m54&quot;: &quot;adb&quot;, &quot;m55&quot;: &quot;{\\&quot;data\\&quot;:[36.107063],\\&quot;name\\&quot;:\\&quot;TMD4903LightSensor\\&quot;,\\&quot;vendor\\&quot;:\\&quot;AMS\\&quot;}&quot;, &quot;m56&quot;: &quot;google/sailfish/sailfish:9/PQ2A.190305.002/5240760:user/release-keys&quot;, &quot;m57&quot;: &quot;[{\\&quot;ssid\\&quot;:\\&quot;2F16C2\\&quot;,\\&quot;bssid\\&quot;:\\&quot;cc:ee:07:2f:16:c2\\&quot;},{\\&quot;ssid\\&quot;:\\&quot;2F16C2\\&quot;,\\&quot;bssid\\&quot;:\\&quot;cc:ee:07:2f:16:c2\\&quot;},{\\&quot;ssid\\&quot;:\\&quot;JinRong\\&quot;,\\&quot;bssid\\&quot;:\\&quot;cc:e9:e4:84:cc:76\\&quot;}]&quot;, &quot;m58&quot;: &quot;unknown&quot;, &quot;m59&quot;: &quot;0&quot;, &quot;m60&quot;: &quot;2283765760&quot;, &quot;m61&quot;: &quot;[1,BMI160accelerometer,1,Bosch,156,2500,0,0,4,BMI160gyroscope,1,Bosch,17,2500,0,0,2,AK09915magnetometer,1,AKM,1300,20000,0,0,6,BMP285pressure,1,Bosch,1100,100000,0,0,65536,BMP285temperature,1,Bosch,85,40000,0,0,8,TMD4903ProximitySensor,1,AMS,5,200000,0,1,5,TMD4903LightSensor,1,AMS,43000,200000,0,10,3,Orientation,1,Google,360,5000,0,1,18,BMI160Stepdetector,1,Bosch,1,0,0,1,17,Significantmotion,1,Google,1,-1,0,1,9,Gravity,1,Google,1000,5000,0,1,10,LinearAcceleration,1,Google,1000,5000,0,1,11,RotationVector,1,Google,1000,5000,0,1,20,GeomagneticRotationVector,1,Google,1000,5000,0,1,15,GameRotationVector,1,Google,1000,5000,0,1,25,PickupGesture,1,Google,1,-1,0,1,22,TiltDetector,1,Google,1,0,0,1,19,BMI160Stepcounter,1,Bosch,1,0,0,1,14,AK09915magnetometer(uncalibrated),1,AKM,1300,20000,0,0,16,BMI160gyroscope(uncalibrated),1,Bosch,17,2500,0,0,65537,SensorsSync,1,Google,1,0,0,1,65538,DoubleTwist,1,Google,1,0,0,1,65539,DoubleTap,1,Google,1,0,0,1,27,DeviceOrientation,1,Google,3,0,0,1,65540,DoubleTouch,1,Google,1,-1,0,1,35,BMI160accelerometer(uncalibrated),1,Bosch,156,2500,0,0,32,DynamicSensorManager,1,Google,1,1000,0,1]&quot;, &quot;m62&quot;: &quot;1&quot;, &quot;m63&quot;: &quot;0&quot;, &quot;m64&quot;: &quot;1&quot;, &quot;m65&quot;: &quot;1&quot;, &quot;m66&quot;: &quot;Bosch&quot;, &quot;m67&quot;: &quot;unknown&quot;, &quot;m68&quot;: &quot;&quot;, &quot;m69&quot;: &quot;352531086839980&quot;, &quot;m70&quot;: &quot;sailfish&quot;, &quot;m71&quot;: &quot;Gravity&quot;, &quot;m72&quot;: &quot;1&quot;, &quot;m73&quot;: &quot;com.qihoo.appstore-bin.mt.plus-cn.tongdun.sdkdemo-com.arcsoft.arcfacedemo-com.baidu.idl.face.demo-com.bjgas.shop-com.duapps.gif.emoji.gifmaker-com.mv.livebodyexample-com.sankuai.meituan-com.songheng.wubiime&quot;, &quot;m74&quot;: &quot;FA7740302912&quot;, &quot;m75&quot;: &quot;unknown&quot;, &quot;m76&quot;: &quot;QualcommRIL1.0&quot;, &quot;m77&quot;: &quot;BMI160accelerometer&quot;, &quot;m78&quot;: &quot;com.android.chrome-com.android.settings-com.android.vending-com.google.android.GoogleCamera-com.google.android.apps.docs-com.google.android.apps.maps-com.google.android.apps.messaging-com.google.android.apps.photos-com.google.android.calendar-com.google.android.contacts&quot;, &quot;m79&quot;: &quot;midi,adb&quot;, &quot;m80&quot;: &quot;&quot;, &quot;m81&quot;: &quot;8996-130181-1811270246&quot;, &quot;m82&quot;: &quot;32&quot;, &quot;m83&quot;: &quot;PQ2A.190305.002&quot;, &quot;m84&quot;: &quot;midi,adb&quot;, &quot;m85&quot;: &quot;&quot;, &quot;m86&quot;: &quot;PQ2A.190305.002&quot;, &quot;m87&quot;: &quot;lac:40980,cid:3909155,rssi:22|lac:-1,cid:-1,rssi:20&quot;, &quot;m88&quot;: &quot;cn&quot;, &quot;m89&quot;: &quot;release-keys&quot;, &quot;m90&quot;: &quot;1&quot;, &quot;m91&quot;: &quot;unknown&quot;, &quot;m92&quot;: &quot;&quot;, &quot;m93&quot;: &quot;{\\&quot;hashInfo\\&quot;:[],\\&quot;number\\&quot;:0}&quot;, &quot;m94&quot;: &quot;sailfish&quot;, &quot;m95&quot;: &quot;1&quot;, &quot;m96&quot;: &quot;8996-012001-1812132253&quot;, &quot;m97&quot;: &quot;&quot;, &quot;m98&quot;: &quot;Google&quot;, &quot;m99&quot;: &quot;&quot;, &quot;m100&quot;: &quot;0&quot;, &quot;m101&quot;: &quot;CN&quot;, &quot;m102&quot;: &quot;1&quot;, &quot;m103&quot;: &quot;26109874176&quot;, &quot;m104&quot;: &quot;1593600&quot;, &quot;m105&quot;: &quot;420&quot;, &quot;m106&quot;: &quot;0&quot;, &quot;m107&quot;: &quot;ac:37:43:df:02:7e&quot;, &quot;m108&quot;: &quot;android-build&quot;, &quot;m111&quot;: &quot;37cb81453cec878d&quot;, &quot;m112&quot;: &quot;unknown&quot;, &quot;m116&quot;: &quot;wlan0&quot;, &quot;m117&quot;: &quot;1631706064788&quot;, &quot;m122&quot;: &quot;AA==\\n&quot;, &quot;m123&quot;: &quot;&quot;, &quot;m125&quot;: &quot;&quot;, &quot;m126&quot;: &quot;Dalvik/2.1.0(Linux;U;Android9;PixelBuild/PQ2A.190305.002)&quot;, &quot;m127&quot;: &quot;0.0000000000|0.0000000000&quot;, &quot;m128&quot;: &quot;unknown&quot;, &quot;m129&quot;: &quot;&quot;, &quot;m130&quot;: &quot;&quot;, &quot;m131&quot;: &quot;23132299264&quot;, &quot;m132&quot;: &quot;26109874176&quot;, &quot;m133&quot;: &quot;&quot;, &quot;m134&quot;: &quot;bus&quot;, &quot;m135&quot;: &quot;0.000000&quot;, &quot;m136&quot;: &quot;&quot;, &quot;m137&quot;: &quot;3.18.122-g665c9a1&quot;, &quot;m138&quot;: &quot;[2,95]&quot;, &quot;m139&quot;: &quot;4&quot;, &quot;m140&quot;: &quot;arm64-v8a,armeabi-v7a,armeabi&quot;, &quot;m141&quot;: &quot;0&quot;, &quot;m142&quot;: &quot;0.16470589&quot;, &quot;m143&quot;: &quot;0&quot;, &quot;m144&quot;: &quot;11.12.204&quot;, &quot;m145&quot;: &quot;mtguard&quot;, &quot;m146&quot;: &quot;1&quot;, &quot;m147&quot;: &quot;sailfish&quot;, &quot;m148&quot;: &quot;1631706140783&quot;, &quot;m149&quot;: &quot;1631706064&quot;, &quot;m150&quot;: &quot;1631754658276&quot;, &quot;m151&quot;: &quot;unknown&quot;, &quot;m152&quot;: &quot;5.1.7&quot;, &quot;m153&quot;: &quot;&quot;, &quot;m154&quot;: &quot;com.sankuai.meituan&quot;, &quot;m155&quot;: &quot;1629207179980&quot;, &quot;m156&quot;: &quot;&quot;, &quot;m157&quot;: &quot;3948302336&quot;, &quot;m158&quot;: &quot;sailfish&quot;, &quot;m159&quot;: &quot;abfarm722&quot;, &quot;m160&quot;: &quot;9&quot;, &quot;m161&quot;: &quot;0&quot;, &quot;m162&quot;: &quot;unknown&quot;, &quot;m163&quot;: &quot;0&quot;, &quot;m164&quot;: &quot;zh&quot;, &quot;m165&quot;: &quot;[GMT+08:00,Asia/Shanghai]&quot;, &quot;m166&quot;: &quot;Pixel&quot;, &quot;m167&quot;: &quot;1080*1794&quot;, &quot;m253&quot;: &quot;&quot;, &quot;m254&quot;: &quot;&quot;, &quot;m255&quot;: &quot;0&quot;, &quot;m256&quot;: &quot;&quot;, &quot;m293&quot;: &quot;DAD7A2870A2DAAA2F67190B216A34A886A9E219F941D662641A653D9&quot;, &quot;m241&quot;: &quot;&quot;, &quot;m242&quot;: &quot;&quot;, &quot;m245&quot;: &quot;{\\&quot;libc.so:\\&quot;:\\&quot;E5592D3E966419A89DEF46F6BE029015\\&quot;,\\&quot;libandroid.so:\\&quot;:\\&quot;\\&quot;,\\&quot;libandroid_runtime.so:\\&quot;:\\&quot;2F4ADAB748DE1F97EACAC55B9584E504\\&quot;,\\&quot;libandroid_servers.so:\\&quot;:\\&quot;75AF8941A0B6C9A841C05442FE32CCFC\\&quot;,\\&quot;framework.jar:\\&quot;:\\&quot;\\&quot;,\\&quot;services.jar:\\&quot;:\\&quot;\\&quot;,\\&quot;core.jar:\\&quot;:\\&quot;\\&quot;}&quot;, &quot;m246&quot;: &quot;ae:37:43:df:02:7e&quot;, &quot;m247&quot;: &quot;35253108683998&quot;, &quot;m289&quot;: &quot;352531086839980&quot;, &quot;m290&quot;: &quot;352531086839980&quot;, &quot;m294&quot;: &quot;{\\&quot;1\\&quot;:\\&quot;\\&quot;,\\&quot;2\\&quot;:\\&quot;1|2|3\\&quot;,\\&quot;3\\&quot;:\\&quot;\\&quot;,\\&quot;4\\&quot;:\\&quot;\\&quot;,\\&quot;5\\&quot;:\\&quot;\\&quot;,\\&quot;6\\&quot;:\\&quot;\\&quot;,\\&quot;7\\&quot;:\\&quot;2\\&quot;,\\&quot;8\\&quot;:\\&quot;\\&quot;,\\&quot;9\\&quot;:\\&quot;\\&quot;,\\&quot;10\\&quot;:\\&quot;\\&quot;,\\&quot;11\\&quot;:\\&quot;\\&quot;,\\&quot;12\\&quot;:\\&quot;32\\&quot;,\\&quot;13\\&quot;:\\&quot;\\&quot;,\\&quot;14\\&quot;:\\&quot;\\&quot;,\\&quot;15\\&quot;:\\&quot;\\&quot;,\\&quot;33\\&quot;:{\\&quot;0\\&quot;:2,\\&quot;1\\&quot;:\\&quot;\\&quot;,\\&quot;2\\&quot;:\\&quot;\\&quot;,\\&quot;3\\&quot;:\\&quot;\\&quot;,\\&quot;4\\&quot;:\\&quot;2|22\\&quot;,\\&quot;5\\&quot;:\\&quot;\\&quot;,\\&quot;6\\&quot;:\\&quot;\\&quot;,\\&quot;7\\&quot;:\\&quot;\\&quot;,\\&quot;8\\&quot;:\\&quot;\\&quot;,\\&quot;9\\&quot;:\\&quot;\\&quot;,\\&quot;10\\&quot;:\\&quot;\\&quot;,\\&quot;11\\&quot;:\\&quot;\\&quot;,\\&quot;12\\&quot;:\\&quot;\\&quot;,\\&quot;13\\&quot;:\\&quot;\\&quot;,\\&quot;14\\&quot;:\\&quot;2\\&quot;,\\&quot;15\\&quot;:\\&quot;\\&quot;}}&quot;, &quot;m304&quot;: &quot;-1&quot;, &quot;m305&quot;: &quot;1080*1920&quot;, &quot;m217&quot;: &quot;1631706064788185&quot;, &quot;m243&quot;: &quot;-1&quot;, &quot;m244&quot;: &quot;{\\&quot;DCIM\\&quot;:\\&quot;00045F6737E705C00001C3B7F33CF3000005C810802CB9C0000083D1C295CA000005C810802CB9C0000083D1C295CA00\\&quot;,\\&quot;Android\\&quot;:\\&quot;00045F6737F648000002A40F89B18AC00005C5CB1C563D000000EE4ABA3499C00005C5CB1C563D000000EE4ABA3499C0\\&quot;,\\&quot;misc\\&quot;:\\&quot;0005BA6437AAF540000037EFB50958800005BDC662F5BF40000263501EE0BE000005BDC662F5BF40000263501EE0BE00\\&quot;,\\&quot;settings\\&quot;:\\&quot;00045F67360E000000005AF31103944000045F67360E000000005AF31103944000045F67360E000000005AF311039440\\&quot;,\\&quot;saver\\&quot;:\\&quot;0005BA6437AAF54000005F590941430000045F67377C360000014D7BCD19158000045F67377C360000014D7BCD191580\\&quot;,\\&quot;mtp\\&quot;:\\&quot;0005BA6437AAF5400000CC7CB757DE0000045F67360E00000001EB208F56774000045F67360E00000001EB208F567740\\&quot;,\\&quot;calendar\\&quot;:\\&quot;0005BA6437AAF54000008CD291CAAE4000045F6738AD630000019F5706658BC000045F6738AD630000019F5706658BC0\\&quot;,\\&quot;media\\&quot;:\\&quot;0005BA6437AAF5400000B7440023B8000000225E8BD0FF0000037B4E60CF5D000000225E8BD0FF0000037E567AF07C40\\&quot;,\\&quot;misc_ce\\&quot;:\\&quot;0005BA6437AAF540000062612371A48000045F6737D7C38000010AC9B10045C000057E646876D18000027F601A1B3540\\&quot;,\\&quot;rollback\\&quot;:\\&quot;\\&quot;,\\&quot;system\\&quot;:\\&quot;0005BA6437AAF54000005C50EF10E1800005CC17296EE1C0000373A4714044800005CC17296EE1C0000373A471404480\\&quot;,\\&quot;data\\&quot;:\\&quot;0005BA6437AAF5400000687157C325400005CC0732B344C000001BE686FAA0400005CC0732B344C000001BE686FAA040\\&quot;,\\&quot;install_sessions\\&quot;:\\&quot;0005BA6437AAF54000005F59094143000000225E8BD0FF00000329739E3E68C00000225E8BD0FF00000329739E3E68C0\\&quot;,\\&quot;webview\\&quot;:\\&quot;0005BA6437AAF54000008CD291CAAE4000045F6737C88140000104B976B8E40000045F6737C88140000107C190DA0340\\&quot;}&quot;, &quot;m248&quot;: &quot;&quot;, &quot;m307&quot;: &quot;{\\&quot;m34\\&quot;:5,\\&quot;m40\\&quot;:5,\\&quot;m41\\&quot;:5,\\&quot;m46\\&quot;:5,\\&quot;m58\\&quot;:2,\\&quot;m67\\&quot;:6,\\&quot;m68\\&quot;:5,\\&quot;m75\\&quot;:6,\\&quot;m80\\&quot;:5,\\&quot;m85\\&quot;:5,\\&quot;m91\\&quot;:2,\\&quot;m92\\&quot;:5,\\&quot;m97\\&quot;:5,\\&quot;m99\\&quot;:5,\\&quot;m112\\&quot;:3,\\&quot;m123\\&quot;:5,\\&quot;m125\\&quot;:5,\\&quot;m128\\&quot;:6,\\&quot;m129\\&quot;:5,\\&quot;m130\\&quot;:5,\\&quot;m133\\&quot;:5,\\&quot;m136\\&quot;:5,\\&quot;m151\\&quot;:2,\\&quot;m153\\&quot;:5,\\&quot;m156\\&quot;:5,\\&quot;m162\\&quot;:6,\\&quot;m253\\&quot;:5,\\&quot;m254\\&quot;:7,\\&quot;m256\\&quot;:7,\\&quot;m241\\&quot;:7,\\&quot;m242\\&quot;:5,\\&quot;m248\\&quot;:5}&quot;} 6.3、加密设备数据解密PIC数据获取AES KEY, 解密后数据 1{&quot;a1&quot;:0,&quot;a10&quot;:400,&quot;a2&quot;:&quot;com.sankuai.meituan&quot;,&quot;a11&quot;:&quot;c1ee9178c95d9ec75f0f076a374df94a032d54c8576298d4f75e653de3705449&quot;,&quot;a3&quot;:&quot;0a16ecd60eb56a6a3349f66cdcf7f7bf5190e5a42d6280d8dc0ee3be228398ec&quot;,&quot;a4&quot;:1100030200,&quot;k0&quot;:{&quot;k1&quot;:&quot;meituan1sankuai0&quot;,&quot;k2&quot;:&quot;meituan0sankuai1&quot;,&quot;k3&quot;:&quot;$MXMYBS@HelloPay&quot;,&quot;k4&quot;:&quot;Maoyan010iauknaS&quot;,&quot;k5&quot;:&quot;34281a9dw2i701d4&quot;,&quot;k6&quot;:&quot;X%rj@KiuU+|xY}?f&quot;},&quot;a5&quot;:&quot;11.3.200&quot;,&quot;a0&quot;:&quot;pw/LhTdeoTTyaxPHcHMy+/ssGNS1ihNkrJ+uBI74FIfd90KlTil1m0i7FF/n0bhY&quot;,&quot;a6&quot;:&quot;/HntC9XIfdUyII/UiVfx020EQPpHz2XZY3qzM2aiNmM0i0pB1yeSO689TY9SBB3s&quot;,&quot;a7&quot;:&quot;QsHnU6kFjTYR8Z6tHEvkGMO2Hrt+NRnVQhmxg6EtVBzuzQcBpma3AdhTWNMpesFT&quot;,&quot;c0&quot;:{&quot;c1&quot;:true,&quot;c2&quot;:false},&quot;a9&quot;:&quot;SDEzWXi5LHL/cuMCZ1zYyv+0hIViqWWf+ShbUYILWf4=&quot;,&quot;a8&quot;:1603800117167} 解析json得到 aes key:meituan1sankuai0AES加密设备json数据 123456789101112131415161718192021222324252627282930313233343536IV 0102030405060708.text:C8AA94EE 06 98 LDR R0, [SP,#0x120+byte_count] ; byte_count.text:C8AA94F0 E0 F7 FA EB BLX malloc ; 存放加密后数据.text:C8AA94F4 00 26 MOVS R6, #0.text:C8AA94F6 00 28 CMP R0, #0.text:C8AA94F8 1C D0 BEQ loc_C8AA9534.text:C8AA94FA 4A 99 LDR R1, [SP,#0x120+arg_0].text:C8AA94FC 03 91 STR R1, [SP,#0x120+var_114].text:C8AA94FE 07 AE ADD R6, SP, #0x120+var_104.text:C8AA9500 F4 21 MOVS R1, #0xF4.text:C8AA9502 02 90 STR R0, [SP,#0x120+var_118].text:C8AA9504 30 00 MOVS R0, R6.text:C8AA9506 E0 F7 08 EC BLX __aeabi_memclr4.text:C8AA950A 80 21 MOVS R1, #0x80.text:C8AA950C 20 00 MOVS R0, R4.text:C8AA950E 32 00 MOVS R2, R6.text:C8AA9510 56 F0 30 FF BL AES_set_Encrypt_key_sub_CB601374 ; R0:key,R1:长度,R2:返回值.text:C8AA9514 06 9A LDR R2, [SP,#0x120+byte_count].text:C8AA9516 01 20 MOVS R0, #1.text:C8AA9518 69 46 MOV R1, SP.text:C8AA951A 04 9B LDR R3, [SP,#0x120+var_110].text:C8AA951C 0B 60 STR R3, [R1,#0x120+var_120].text:C8AA951E 48 60 STR R0, [R1,#0x120+var_11C].text:C8AA9520 05 98 LDR R0, [SP,#0x120+p].text:C8AA9522 02 9C LDR R4, [SP,#0x120+var_118].text:C8AA9524 21 00 MOVS R1, R4.text:C8AA9526 33 00 MOVS R3, R6.text:C8AA9528 57 F0 7A FD BL AES_cbc_Encrypt_sub_CB602020 ; R0：原始数据,R1:返回,R2:大小,R3:key.text:C8AA952C 06 98 LDR R0, [SP,#0x120+byte_count].text:C8AA952E 03 99 LDR R1, [SP,#0x120+var_114].text:C8AA9530 08 60 STR R0, [R1].text:C8AA9532 26 00 MOVS R6, R4.text:C8AA9534.text:C8AA9534 loc_C8AA9534 ; CODE XREF: Aes_sub_CB5AA4B8+40↑j.text:C8AA9534 05 98 LDR R0, [SP,#0x120+p] ; p.text:C8AA9536 E0 F7 DE EB BLX free 加密后数据(部分) 123456789101112C6A47000 6C 96 CF 82 B2 88 06 39 8D 37 E9 1C D3 D7 DF A1 l.ς ...9.7......C6A47010 A1 D7 C5 C7 A2 1F 21 47 F4 8D F8 E3 59 55 68 87 ...Ǣ .!G....YUh.C6A47020 13 D2 C7 A5 AD 47 51 04 64 B2 86 3A 86 AA 47 36 .....GQ.d..:..G6C6A47030 8A 26 F7 03 A0 42 3F 4E B7 43 53 F5 E8 DE 9A 48 .&amp;....?N.CS....HC6A47040 FF 7D CC D3 30 91 1C 59 34 6C 3C D5 A4 45 AD 8A .}..0..Y4l&lt;դ E..C6A47050 69 06 49 EA 1B B5 95 7F 40 3F AF BE DB 18 CB CD i.I.....@?......C6A47060 85 A9 05 0E 02 43 1C 10 2C 50 53 9F A0 A1 6D 14 .....C..,PS...m.C6A47070 DF F9 23 99 64 3C E4 D8 7C 56 58 C0 35 E6 81 34 ..#.d&lt;...VX.....C6A47080 9B 9C 6D A3 92 5B 36 50 6E 85 79 6E 2A 6C EB BF ..m..[6Pn.yn*l..C6A47090 59 F5 77 F3 C3 F8 3D 47 04 D4 55 FB C1 D6 8D 3A Y.....=G.......:C6A470A0 0F 4D EF 9E A2 C0 DF 93 58 B5 E1 79 22 EE 6A 65 .M ...X.......C6A470B0 A4 A8 47 7F 68 BA C1 C7 19 96 8A 9E 29 90 48 07 ..G.h.......).H. base64加密(部分) 1bJbPgrKIBjmNN+kc09ffoaHXxceiHyFH9I3441lVaIcT0selrUdRBGSyhjqGqkc2iib3A6BCP063Q1P16N6aSP99zNMwkRxZNGw81aRFrYppBknqG7WVf0A/r77bGMvNhakFDgJDHBAsUFOfoKFtFN/5I5lkPOTYfFZYwDXmgTSbnG2jkls2UG6FeW4qbOu/WfV388P4PUcE1FX7wdaNOg9N756iwN+TWLXheSLuamWkqEd/aLrBxxmWip4pkEgHlLK14AbB68tlUvIauN50i/KZVCun9lA13FmhY9t4JiZYMuQUiluXGtFLoVLUb3ybe9Uy156k8NFn8sZkCzx5I1nUFKEx2Mgb6Q+SDXY1r4TCh6jYCYd/Dfr+n1ccN+Z7M8oceexb3KD+yapCYKvhj2sm5/WptX+ncnTTalrLG8U53YZAJtwQ2NTZ/yuVJWNpnEjRE3EI 返回java层组合请求体，计算请求头签名发送给服务器获取dfpid 请求体格式 1{&quot;data&quot;:&quot;Native加密的设备数据&quot;,&quot;dfpVersion&quot;:&quot;5.1.7&quot;,&quot;mtgVersion&quot;:&quot;5.1.7&quot;,&quot;os&quot;:&quot;Android&quot;,&quot;time&quot;:&quot;2021-09-01 11:35:35&quot;} 计算的请求头签名 1{&quot;a0&quot;:&quot;2.0&quot;,&quot;a1&quot;:&quot;9b69f861-e054-4bc4-9daf-d36ae205ed3e&quot;,&quot;a3&quot;:2,&quot;a4&quot;:1631778284,&quot;a5&quot;:&quot;A18ywLdCS48BnwSLKup0wrjB+dsq4S6V+9BZPtgOWyf76KKpdYv8xejvBBC8HE6C4uRAl79/X7icd48pdktGG8B0+yAbMGtUl5Ri2kQc4/RgxjDiN64MjMvus7Aok+9LqzRZW1W9Qj2yJoMyK7h57/+amTSLDqyUzbat6zAgCAdeZ/vbKk+34+NVNwoz7fMLqvRlGbTVLZddTFIQvzbs1rNC3eV7mH9ORw==&quot;,&quot;a6&quot;:0,&quot;a7&quot;:&quot;lpArUzLcl+lgZ9YXlGR9nPVqJMM2UvrBYyFRM2UsDIidftxLwpEOzzcZ7NPmHxahYSpXrJr/eHv4y2FmjsLwnykKopieCU4Prh4FskqVsRg=&quot;,&quot;a8&quot;:&quot;DAD796C46B5A6525F4B89DF661A97C7A218A219FC24B93F689DEBD92&quot;,&quot;a9&quot;:&quot;97a62b63j1IexpGhrGBYdWqnstTXCpGUZncRa5MAcc5LtAO65uXQ/gPQuhqUcACAU5Cstbgs/wxZr8oFrMNqpSDo+Lt3QT7CenBY9BUnVn6bSHYNAaPhQ3WxYc1fpRi3+Lfpqz6/6CtwzNM113yKUoIgwMQZ2TTkRJ5S7JI0PztFc8u2I5ngz2thHx3rIXDjNXhmxoo7xH9rULUa65Y1zdPRx2xVNGDUJDFX78jvL39wIkvvnqBMK54GyQ8F8Vd/+lyPg1Wi3GoVUyFKrfw5RRDTElNyby2CvgQVKFRwHYbJu8OS3TjT6sW4uqmNxZQl4Zg4DBg/C6vlXAZISTCiCzC5yQ/xfqrQ5hNmKmsfHiVMduB7XYh9INAqceiTRlPV/ccY/JeGPRTbo52FoIHEponCLaToMU08uJVYC+hvT21OB/Wae2dr1l0vF4zDP+109YHgf7HbHg40TJW+UfIJdkAR0XHDINEqZIPmgE7jgon2B9KMXSyrWTg3OvOVA2USc7lBX9/8s1AXyI6MYgb7JwddM/cajZJle9ipMzJTmSZbJPw8o3bHGlt2pTtXzJb7mLgOxS1cwoc2kUTQYkRz5irPM1bhY4dT33d0tOr6C8IjROMgQMuIsVxKYCt88qo8ESk/nZEpVcWvBlsM+HWSwjHKtOJ8iPl3EqwSQiWRjVN6bOQyQIsPNVTfkZHSBqKnJ4dXcjXMTqcxGgxEzfD5sLfzXDz71A==&quot;,&quot;a10&quot;:&quot;{}&quot;,&quot;x0&quot;:1,&quot;a2&quot;:&quot;0f4513356e64a6d70d962a764b1d68b8&quot;} 发送给服务器后成功返回dfpid 1{&quot;code&quot;:0,&quot;data&quot;:{&quot;serverTimestamp&quot;:0,&quot;clientIp&quot;:&quot;218.xx.xx.xx&quot;,&quot;interval&quot;:24,&quot;dfp&quot;:&quot;8ecde1544fbe09ba3ec851e72fdd28c0803df1f83c5c0862c8ad571c&quot;},&quot;message&quot;:&quot;ok&quot;} 以上就是完整的dfpid设备指纹生成过程，xid生成也是类似的，也是在Native层获取设备信息加密返回到java层组合请求体，计算请求头签名，发送给服务器计算ID返回ID的过程，我就不再重复分析了。 七、设备指纹攻击7.1、设备指纹原理设备指纹是用来标识手机设备的唯一ID，能够通过这个ID关联到手机相关的全部数据，因此设备指纹是风控中最核心的数据之一，所以它需要具备以下几个条件时ID不变：设备重置、设备更新、设备刷机。要同时具备这样的条件，必须从多个维度采集不同的信息来生成ID，这些信息可以大致分为：软件ID、软件静态特征、硬件静态特征和硬件动态特征。采集完信息后如何基于这些信息计算出一个稳定的设备指纹ID，还是有比较大挑战，再加上目前国家对公民隐私保护严格，用户敏感信息不能采集，很多唯一性比较好的数据就失效，要做一稳定性高的ID就难上加难了。 7.2、设备指纹变与不变既然设备指纹ID是根据手机设备的数据生成的，哪么我们的攻击思路就是修改设备信息，同一台手机不断变化设备信息让生成设备指纹的服务返回新的ID就算攻击成功了，因为它无法识别手机的唯一性。实战修改设备字段生成新的dfpid测试过程就是在内存中将采集的某设备字段改掉就可以生成新的设备ID(该字段是软件相关的ID，比较敏感就不说了，总共没有多少字段，想玩的朋友可以自己调试测试)修改前后对比图7-1与7-2所示，返回新的ID: 八、黑产工具特征检测8.1、解密黑产工具特征获取密钥，解密PIC数据获取key(a9) 12345678910111213141516.text:C8571594 20 00 MOVS R0, R4.text:C8571596 32 00 MOVS R2, R6.text:C8571598 57 F0 7A F8 BL AES_set_decrypt_key_sub_CB601690 ; R0:key,R1:大小,R2:初始AES_KEY返回结构.text:C857159C 00 20 MOVS R0, #0.text:C857159E 69 46 MOV R1, SP.text:C85715A0 06 9A LDR R2, [SP,#0x128+var_110].text:C85715A2 0A 60 STR R2, [R1,#0x128+var_128].text:C85715A4 48 60 STR R0, [R1,#0x128+var_124].text:C85715A6 08 98 LDR R0, [SP,#0x128+var_108].text:C85715A8 04 9E LDR R6, [SP,#0x128+var_118].text:C85715AA 31 00 MOVS R1, R6.text:C85715AC 07 9C LDR R4, [SP,#0x128+var_10C].text:C85715AE 22 00 MOVS R2, R4.text:C85715B0 03 9B LDR R3, [SP,#0x128+var_11C].text:C85715B2 57 F0 35 FD BL AES_cbc_Encrypt_sub_CB602020.text:C85715B6 30 00 MOVS R0, R6 解密后特征 123456789101112131415161718{ &quot;0&quot;: 2, &quot;1&quot;: &quot;&quot;, &quot;2&quot;: [&quot;/sys/devices/virtual/misc/qemu_pipe&quot;, &quot;/sys/module/vboxsf&quot;, &quot;/system/droid4x&quot;, &quot;/system/bin/droid4x-vbox-sf&quot;, &quot;/system/lib/egl/libEGL_tiDetectanVM.so&quot;, &quot;/system/bin/ttVM-vbox-sf&quot;, &quot;/system/lib/libnox.so&quot;, &quot;/system/bin/nox-vbox-sf&quot;, &quot;/system/bin/androVM-vbox-sf&quot;, &quot;/ueventd.vbox86.rc&quot;, &quot;/sys/class/misc/qemu_pipe&quot;, &quot;/sys/qemu_trace&quot;, &quot;/dev/com.bluestacks.superuser.daemon&quot;, &quot;/system/framework/libqemu_wl.txt&quot;, &quot;/system/lib/libc_malloc_debug_qemu.so-arm&quot;, &quot;/data/downloads/qemu_list.txt&quot;, &quot;/system/bin/yiwan-prop&quot;, &quot;/system/bin/yiwan-sf&quot;, &quot;/system/bin/qemu_props&quot;, &quot;/system/bin/androVM-prop&quot;, &quot;/system/bin/microvirt-prop&quot;, &quot;/system/lib/libdroid4x.so&quot;, &quot;/system/bin/windroyed&quot;, &quot;/system/bin/microvirtd&quot;, &quot;/system/bin/nox-prop&quot;, &quot;/system/bin/ttVM-prop&quot;, &quot;/dev/qemu_pipe&quot;, &quot;/vendor/bin/qemu-props&quot;, &quot;/system/bin/droid4x-prop&quot;, &quot;/data/.bluestacks.prop&quot;, &quot;/system/app/com.mumu.launcher&quot;, &quot;/system/lib/vboxguest.ko&quot;, &quot;/system/lib/vboxsf.ko&quot;, &quot;/sys/class/misc/vboxguest&quot;, &quot;/sys/class/misc/vboxuser&quot;], &quot;3&quot;: [&quot;de.robv.android.xposed.installer&quot;, &quot;com.saurik.substrate&quot;, &quot;com.soft.apk008v&quot;, &quot;com.soft.apk008Tool&quot;, &quot;com.mockgps.outside.ui&quot;, &quot;com.tim.apps.mockgps&quot;, &quot;com.huichongzi.locationmocke&quot;, &quot;com.lxzs&quot;], &quot;4&quot;: [&quot;XposedBridge.jar&quot;, &quot;frida&quot;, &quot;substrate&quot;, &quot;libriru_edxp.so&quot;, &quot;libsandhook.edxp.so&quot;, &quot;libwhale.edxp.so&quot;, &quot;libxposed_art.so&quot;, &quot;edxp.jar&quot;, &quot;fasthook&quot;, &quot;libfakeloc_initzygote.so&quot;, &quot;qssq666&quot;, &quot;com.lxzs&quot;, &quot;sandhook&quot;, &quot;libsubstrate.so&quot;, &quot;libiohook.so&quot;, &quot;libepic.so&quot;, &quot;libepic64.so&quot;, &quot;libexp824.so&quot;, &quot;libexp82464.so&quot;, &quot;libexposed.so&quot;, &quot;cydia&quot;, &quot;/data/local/tmp&quot;], &quot;5&quot;: &quot;&quot;, &quot;6&quot;: [&quot;de.robv.android.xposed.XposedBridge&quot;, &quot;de.robv.android.xposed.XposedHelpers&quot;], &quot;7&quot;: [&quot;/system/lib/lic&quot;, &quot;/system/lib/ccc&quot;, &quot;/system/lib/.aa&quot;], &quot;8&quot;: [&quot;de.robv.android.xposed.XposedBridge&quot;, &quot;xposed&quot;, &quot;com.lxzs&quot;], &quot;9&quot;: [&quot;dexguard_DGResourcesSuperClass.dex&quot;], &quot;10&quot;: [&quot;VirtualBox&quot;], &quot;11&quot;: [&quot;com.gsxz.location&quot;, &quot;net.anylocation&quot;, &quot;com.huichongzi.locationmocker&quot;, &quot;top.a1024bytes.mockloc.ca.pro&quot;, &quot;com.deniu.daniu&quot;], &quot;12&quot;: [&quot;fridaserver&quot;, &quot;magisk&quot;, &quot;xposed&quot;], &quot;13&quot;: &quot;&quot;, &quot;14&quot;: [&quot;charles&quot;, &quot;fiddler&quot;], &quot;15&quot;: [&quot;com.netease.nemu_vinput.nemu&quot;]} 8.2、解析json检测特征12345678910111213141516171819//直接调用SVC指令,检测特征是否存在系统中。.text:C8571444 faccessat_sub_C8BE5444.text:C8571444.text:C8571444 F0 B5 PUSH {R4-R7,LR}.text:C8571446 03 AF ADD R7, SP, #0xC.text:C8571448 0B 00 MOVS R3, R1.text:C857144A 04 00 MOVS R4, R0.text:C857144C 63 20 MOVS R0, #0x63 ; 'c'.text:C857144E C5 43 MVNS R5, R0.text:C8571450 A7 20 MOVS R0, #0xA7.text:C8571452 46 00 LSLS R6, R0, #1.text:C8571454 28 46 MOV R0, R5.text:C8571456 21 46 MOV R1, R4.text:C8571458 1A 46 MOV R2, R3.text:C857145A 37 46 MOV R7, R6.text:C857145C 00 DF SVC 0.text:C857145E 03 46 MOV R3, R0.text:C8571460 18 00 MOVS R0, R3.text:C8571462 F0 BD POP {R4-R7,PC} 九、总结9.1、安全点代码混淆，代码块间跳转动态计算获取，单步调试容易跑飞、流程混淆无法F5，字符串加密。采集设备信息都在Native层反射来获取， 9.1、不足点指纹稳定性比较差，在华为的机型上基本不行，防hook只是简单做了前几个字节判断，检测黑产工具的特征写死的。","link":"/20220112/%E6%9F%90%E5%A4%96%E4%B9%B0APP%E8%AE%BE%E5%A4%87%E6%8C%87%E7%BA%B9%E9%A3%8E%E6%8E%A7%E5%88%86%E6%9E%90/"},{"title":"Windows WX互斥体探秘","text":"一、原理首先程序利用OpenMutex打开一个互斥体句柄，看返回的句柄值是否为空，如果为空就利用CreateMutex创建一个互斥体，当程序第二次打开时，互斥体句柄存在，便可以判断程序已经在运行 12345678910111213141516171819#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(){ HANDLE hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, L&quot;flag&quot;); if (hMutex == NULL) { CreateMutex(NULL, NULL, L&quot;flag&quot;); } else { MessageBox(NULL, L&quot;程序已经在运行&quot;, 0, 0); return 0; } return 0;} 二、调试Ctrl+d 搜索创建互斥体关键字 CreateMutex 。 通过寄存器可以看到一个 _WeChat_App_Instance_Identity_Mutex_Name的字符串，此为互斥体，继续调试到返回，向上看会发现push 字符串常量的地方，下断点重新调试并修改对应值，就可以打开两个程序。 三、通过程序关闭Mutex123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279 // dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;pch.h&quot;#include &lt;Windows.h&gt;#include &lt;TlHelp32.h&gt;#include &lt;Shlwapi.h&gt;#pragma comment(lib, &quot;shlwapi&quot;)#include &quot;dllmain.h&quot;#include &lt;stdio.h&gt;#include &lt;shellapi.h&gt;#pragma comment(lib, &quot;Advapi32&quot;)#pragma comment(lib, &quot;Shell32&quot;)//进程提权BOOL ElevatePrivileges(){ HANDLE hToken; TOKEN_PRIVILEGES tkp; tkp.PrivilegeCount = 1; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken)) return FALSE; LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tkp.Privileges[0].Luid); tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) { return FALSE; } return TRUE;}HANDLE DuplicateHandleEx(DWORD pid, HANDLE h, DWORD flags){ HANDLE hHandle = NULL; HANDLE hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if (hProc) { if (!DuplicateHandle(hProc, (HANDLE)h, GetCurrentProcess(), &amp;hHandle, 0, FALSE, /*DUPLICATE_SAME_ACCESS*/flags)) { hHandle = NULL; } } CloseHandle(hProc); return hHandle;}int GetProcIds(DWORD* Pids){ PROCESSENTRY32 pe32 = { sizeof(pe32) }; int num = 0; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hSnap) { if (Process32First(hSnap, &amp;pe32)) { do { if (!wcsicmp(L&quot;WeChat.exe&quot;, pe32.szExeFile)) { if (Pids) { Pids[num++] = pe32.th32ProcessID; } } } while (Process32Next(hSnap, &amp;pe32)); } CloseHandle(hSnap); } return num;}BOOL IsTargetPid(DWORD Pid, DWORD* Pids, int num){ for (int i = 0; i &lt; num; i++) { if (Pid == Pids[i]) { return TRUE; } } return FALSE;}int PatchWeChat(){ DWORD dwSize = 0; POBJECT_NAME_INFORMATION pNameInfo; POBJECT_NAME_INFORMATION pNameType; PVOID pbuffer = NULL; NTSTATUS Status; int nIndex = 0; DWORD dwFlags = 0; char szType[128] = { 0 }; char szName[512] = { 0 }; ElevatePrivileges(); DWORD Pids[100] = { 0 }; DWORD Num = GetProcIds(Pids); if (Num == 0) { return 0; } if (!ZwQuerySystemInformation) { goto Exit0; } pbuffer = VirtualAlloc(NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE); if (!pbuffer) { goto Exit0; } Status = ZwQuerySystemInformation(SystemHandleInformation, pbuffer, 0x1000, &amp;dwSize); if (!NT_SUCCESS(Status)) { if (STATUS_INFO_LENGTH_MISMATCH != Status) { goto Exit0; } else { // 这里大家可以保证程序的正确性使用循环分配稍好 if (NULL != pbuffer) { VirtualFree(pbuffer, 0, MEM_RELEASE); } if (dwSize * 2 &gt; 0x4000000) // MAXSIZE { goto Exit0; } pbuffer = VirtualAlloc(NULL, dwSize * 2, MEM_COMMIT, PAGE_READWRITE); if (!pbuffer) { goto Exit0; } Status = ZwQuerySystemInformation(SystemHandleInformation, pbuffer, dwSize * 2, NULL); if (!NT_SUCCESS(Status)) { goto Exit0; } } } { PSYSTEM_HANDLE_INFORMATION1 pHandleInfo = (PSYSTEM_HANDLE_INFORMATION1)pbuffer; for (nIndex = 0; nIndex &lt; pHandleInfo-&gt;NumberOfHandles; nIndex++) { if (IsTargetPid(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, Pids, Num)) { // HANDLE hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, (HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue, DUPLICATE_SAME_ACCESS ); if (hHandle == NULL) continue; Status = NtQueryObject(hHandle, ObjectNameInformation, szName, 512, &amp;dwFlags); if (!NT_SUCCESS(Status)) { CloseHandle(hHandle); continue; } Status = NtQueryObject(hHandle, ObjectTypeInformation, szType, 128, &amp;dwFlags); if (!NT_SUCCESS(Status)) { CloseHandle(hHandle); continue; } pNameInfo = (POBJECT_NAME_INFORMATION)szName; pNameType = (POBJECT_NAME_INFORMATION)szType; WCHAR TypName[1024] = { 0 }; WCHAR Name[1024] = { 0 }; wcsncpy(TypName, (WCHAR*)pNameType-&gt;Name.Buffer, pNameType-&gt;Name.Length / 2); wcsncpy(Name, (WCHAR*)pNameInfo-&gt;Name.Buffer, pNameInfo-&gt;Name.Length / 2); // 匹配是否为需要关闭的句柄名称 if (0 == wcscmp(TypName, L&quot;Mutant&quot;)) { //WeChat_aj5r8jpxt_Instance_Identity_Mutex_Name //if (wcsstr(Name, L&quot;_WeChat_App_Instance_Identity_Mutex_Name&quot;)) if (wcsstr(Name, L&quot;_WeChat_&quot;) &amp;&amp; wcsstr(Name, L&quot;_Instance_Identity_Mutex_Name&quot;)) { CloseHandle(hHandle); hHandle = DuplicateHandleEx(pHandleInfo-&gt;Handles[nIndex].UniqueProcessId, (HANDLE)pHandleInfo-&gt;Handles[nIndex].HandleValue, DUPLICATE_CLOSE_SOURCE ); if (hHandle) { //printf(&quot;+ Patch wechat success!\\n&quot;); CloseHandle(hHandle); } else { //printf(&quot;- Patch error: %d\\n&quot;, GetLastError()); } goto Exit0; } } CloseHandle(hHandle); } } }Exit0: if (NULL != pbuffer) { VirtualFree(pbuffer, 0, MEM_RELEASE); } return 0;}void OpenWeChat(){ //HKEY_CURRENT_USER\\Software\\Tencent\\WeChat InstallPath = xx HKEY hKey = NULL; if (ERROR_SUCCESS != RegOpenKey(HKEY_CURRENT_USER, L&quot;Software\\\\Tencent\\\\WeChat&quot;, &amp;hKey)) { return; } DWORD Type = REG_SZ; WCHAR Path[MAX_PATH] = { 0 }; DWORD cbData = MAX_PATH * sizeof(WCHAR); if (ERROR_SUCCESS != RegQueryValueEx(hKey, L&quot;InstallPath&quot;, 0, &amp;Type, (LPBYTE)Path, &amp;cbData)) { goto __exit; } PathAppend(Path, L&quot;WeChat.exe&quot;); ShellExecute(NULL, L&quot;Open&quot;, Path, NULL, NULL, SW_SHOW);__exit: if (hKey) { RegCloseKey(hKey); }}//函数入口extern &quot;C&quot; _declspec(dllexport) int __stdcall WeChatMultiOpen(){ PatchWeChat(); OpenWeChat(); return 0;} *本案例仅做分析参考，如有侵权请联系删除","link":"/20220509/Windows-WX%E4%BA%92%E6%96%A5%E4%BD%93%E6%8E%A2%E7%A7%98/"},{"title":"Scrapy使用FilesPipeline下载并读取Excel&#x2F;Doc&#x2F;Dox&#x2F;Pdf内容","text":"一、需求背景抓取网页中的附件，并将附件中的文字存储下来，不要求格式及段落顺序。 二、Spider1、FilesPipeline使用scrapy默认的pipeline，统一下载后根据不同格式进行文件处理。 1234567891011121314151617181920212223242526272829303132333435363738class AddFilesPipeline(FilesPipeline): headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:101.0) Gecko/20100101 Firefox/101.0', } def get_media_requests(self, item, info): if item['file_urls']: index = 0 for url in item['file_urls']: file_name = hashlib.md5(url).hexdigest() + &quot;_{}&quot;.format(index) file_format = url.split('.')[-1] yield scrapy.Request(url=url,headers=self.headers,meta={&quot;item&quot;:item,&quot;file_format&quot;:file_format,&quot;file_name&quot;:file_name}) index+=1 def file_path(self, request, response=None, info=None): file_format = request.meta['file_format'] file_name = request.meta['file_name'] return '{file_name}.{file_format}'.format(file_name=file_name,file_format=file_format) def item_completed(self, results, item, info): if item['file_urls']: # 文件 file_paths = [x['path'] for ok, x in results if ok] ok, x = results[0] if not file_paths: raise DropItem(&quot;File下载失败&quot;) for result in results: ok, x = result path = x['path'] if path.endswith('xls'): content = parse_excel(FILES_STORE+path) elif path.endswith('doc') or path.endswith('docx') or path.endswith('wps'): content = parse_word(FILES_STORE+path) elif path.endswith('pdf'): content = parse_pdf(FILES_STORE+path) item['file_content'].append(content) return item 三、处理文件1、处理excel12345678910111213141516171819202122def parse_excel(path): &quot;&quot;&quot; 解析表格 :param path: :return: &quot;&quot;&quot; book = xlrd.open_workbook(path) sheet_names = book.sheet_names() # 工作区 content_list = [] for sheet_name in sheet_names: sheet = book.sheet_by_name(sheet_name) rows = sheet.nrows # 行 # cols = sheet.ncols # 列 # print rows,cols content = '' for i in range(0, rows): row = sheet.row_values(i) content += ' | '.join( [str(t) if isinstance(t, unicode) or isinstance(t, str) else str(int(t)) for t in row if t]) + '\\n' content_list.append(content) os.remove(path) return '\\n'.join(content_list) 2、处理pdf123456789101112131415161718192021def parse_pdf(path): result = [] fp = open(path, 'rb') parser = PDFParser(fp) doc = PDFDocument(parser, '') parser.set_document(doc) rsrcmgr = PDFResourceManager() # 创建一个PDF设备对象 laparams = LAParams() device = PDFPageAggregator(rsrcmgr, laparams=laparams) interpreter = PDFPageInterpreter(rsrcmgr, device) for page in PDFPage.create_pages(doc): interpreter.process_page(page) layout = device.get_result() for x in layout: if hasattr(x, &quot;get_text&quot;): string = x.get_text().replace('\\n', '').replace(' ', '').strip() if string: result.append(string) os.remove(path) return '\\n'.join(result) 3、处理doc/wps/docx注意由于linux环境用不了win32com，所以在linux上采用libreoffice将文件转换成docx。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def parse_word(path): &quot;&quot;&quot; 解析doc/wps/docx win和linux用到的东西不一样 :param path: :return: &quot;&quot;&quot; # 如果是.doc需要转换成docx temp_path = '' outdir = path if path.endswith('doc') or path.endswith('wps'): temp_path = path sys = platform.system() if sys == &quot;Windows&quot;: from win32com import client as wc word = wc.Dispatch('Word.Application') doc = word.Documents.Open(path) if path.endswith('doc'): path = path.replace(&quot;doc&quot;, &quot;docx&quot;) else: path = path.replace(&quot;wps&quot;, &quot;docx&quot;) doc.SaveAs(path, 12, False, &quot;&quot;, True, &quot;&quot;, False, False, False, False) # 转化后路径下的文件 doc.Close() word.Quit() else: outdir = os.path.abspath(os.path.join(path, &quot;..&quot;)) os.system(&quot;libreoffice --headless --convert-to docx {path} --outdir {outdir}&quot;.format(path=path,outdir=outdir)) if path.endswith('doc'): path = path.replace(&quot;doc&quot;, &quot;docx&quot;) else: path = path.replace(&quot;wps&quot;, &quot;docx&quot;) document = Document(path) result = [] for paragraph in document.paragraphs: p_text = paragraph.text.replace(&quot;\\n&quot;, &quot;&quot;).strip() if p_text and p_text not in result: result.append(p_text) tables = document.tables # 获取Word文件中的表格集 for table in tables: # 遍历每个表格 table_content = '' for row in table.rows: # 从表格第一行开始循环读取表格数据 row_content = get_cell_content(row.cells) table_content += '|'.join(row_content) + '\\n' result.append(table_content) os.remove(path) if temp_path:os.remove(temp_path) return '\\n'.join(result)def get_cell_content(cells): &quot;&quot;&quot; 获取每一行中每一列的内容 &quot;&quot;&quot; row_content = [] for cell in cells: # 遍历每一行的每一个单元格 # cell数量为表格最大列数+1，故对于较少列的行存在重复值，需去重 if cell.text and cell.text not in row_content: row_content.append(cell.text.replace(&quot;\\n&quot;, &quot;&quot;).strip()) return row_content libreoffice将文件转换成txt。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def parse_word(path): &quot;&quot;&quot; 解析doc/wps/docx win和linux用到的东西不一样 :param path: :return: &quot;&quot;&quot; # 如果是.doc需要转换成docx temp_path = '' outdir = path if path.endswith('doc') or path.endswith('wps'): temp_path = path sys = platform.system() if sys == &quot;Windows&quot;: from win32com import client as wc word = wc.Dispatch('Word.Application') doc = word.Documents.Open(path) if path.endswith('doc'): path = path.replace(&quot;doc&quot;, &quot;docx&quot;) else: path = path.replace(&quot;wps&quot;, &quot;docx&quot;) doc.SaveAs(path, 12, False, &quot;&quot;, True, &quot;&quot;, False, False, False, False) # 转化后路径下的文件 doc.Close() word.Quit() else: outdir = os.path.abspath(os.path.join(path, &quot;..&quot;)) os.system(&quot;libreoffice --headless --convert-to txt {path} --outdir {outdir}&quot;.format(path=path,outdir=outdir)) if path.endswith('doc'): path = path.replace(&quot;doc&quot;, &quot;txt&quot;) else: path = path.replace(&quot;wps&quot;, &quot;txt&quot;) content = open(path,'r').readlines() os.remove(path) if temp_path: os.remove(temp_path) return '\\n'.join([i.strip() for i in content if i]) document = Document(path) result = [] for paragraph in document.paragraphs: p_text = paragraph.text.replace(&quot;\\n&quot;, &quot;&quot;).strip() if p_text and p_text not in result: result.append(p_text) tables = document.tables # 获取Word文件中的表格集 for table in tables: # 遍历每个表格 table_content = '' for row in table.rows: # 从表格第一行开始循环读取表格数据 row_content = get_cell_content(row.cells) table_content += '|'.join(row_content) + '\\n' result.append(table_content) os.remove(path) if temp_path:os.remove(temp_path) return '\\n'.join(result)def get_cell_content(cells): &quot;&quot;&quot; 获取每一行中每一列的内容 &quot;&quot;&quot; row_content = [] for cell in cells: # 遍历每一行的每一个单元格 # cell数量为表格最大列数+1，故对于较少列的行存在重复值，需去重 if cell.text and cell.text not in row_content: row_content.append(cell.text.replace(&quot;\\n&quot;, &quot;&quot;).strip()) return row_content 4、安装libreoffice12345678# 下载libreofficeyum install -y libreoffice# 安装依赖yum install cairo cups-libs libSMyum install ibusyum install libreoffice-headless# 安装成功后查看版本libreoffice --version 转换命令,可以转换成各种各种如doc、docx、txt，当然上面的代码也可以改成转换成txt格式的直接读取。 1libreoffice --headless --convert-to {输出文件类型} {原文件路径} --outdir {输出路径}","link":"/20220618/Scrapy%E4%BD%BF%E7%94%A8FilesPipeline%E4%B8%8B%E8%BD%BD%E5%B9%B6%E8%AF%BB%E5%8F%96Excel-Doc-Dox-Pdf%E5%86%85%E5%AE%B9/"},{"title":"JS逆向 | instagram登入enc_password","text":"*本文章仅供学习交流,切勿用于非法通途,如有侵犯贵司请及时联系删除 一、流程分析分析发现密码加密，且发送POST请求时header必须携带x-csrftoken，否则是报403。 而x-csrftoken是在第一次访问主页的时候设置的。 二、逆向分析通过查看请求堆栈找到生成处，当然也可以直接采用搜索大法，白猫黑猫抓到耗子就是好猫。 通过逐步下断点分析函数作用及各种参数传入返回，慢慢溯源最终找到生成处。 其中 i(d[1]).encrypt(t, c, u, f) 是主要逻辑，放到Node中缺啥补啥跑起来就ok，当然也可以用其他语言重写。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849s = { encrypt: async function(s, c, h, l) { const u = o + h.length; if (64 !== c.length) throw new Error('public key is not a valid hex sting'); const w = n(c); if (!w) throw new Error('public key is not a valid hex string'); const y = new Uint8Array(u); let f = 0; y[f] = 1, y[f += 1] = s, f += 1; const p = { name: 'AES-GCM', iv: new Uint8Array(12), additionalData: l, tagLen: 16 } , A = window.crypto || window.msCrypto; return A.subtle.generateKey({ name: 'AES-GCM', length: 256 }, !0, ['encrypt', 'decrypt']).then(function(t) { const n = A.subtle.exportKey('raw', t) , o = A.subtle.encrypt(p, t, h.buffer); return Promise.all([n, o]) }).then(function(n) { const o = t(new Uint8Array(n[0]), w); if (y[f] = 255 &amp; o.length, y[f + 1] = o.length &gt;&gt; 8 &amp; 255, f += 2, y.set(o, f), f += 32, f += r(d[0]).overheadLength, o.length !== 32 + r(d[0]).overheadLength) throw new Error('encrypted key is the wrong length'); const s = new Uint8Array(n[1]) , c = s.slice(-16) , h = s.slice(0, -16); return y.set(c, f), f += 16, y.set(h, f), y }).catch(function(t) { throw t }) } }; 三、模拟请求首先访问主页，获取到csrftoken，然后把加密后的密码还有csrftoken组装起来，POST即可，因为账号密码是我瞎填的所以user和authenticated都是false，试了下提交正常账号也是完美没有问题滴。 123456789101112131415161718192021222324252627282930313233import requestsdef get_proxy(): return { &quot;http&quot;:&quot;http://&quot;+ip, &quot;https&quot;: &quot;https://&quot; + ip, }headers = { 'authority': 'www.instagram.com', 'origin': 'https://www.instagram.com', 'referer': 'https://www.instagram.com/', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36',}cookie = requests.get('https://www.instagram.com/',headers=headers, proxies=get_proxy()).cookiesheaders['x-csrftoken']= cookie.get('csrftoken')# node服务enc_password = requests.get('http://localhost:23346/instagram?password=1111111111111111111111').textprint(enc_password)data = { 'enc_password': enc_password, 'username': '15566678899', 'queryParams': '{}', 'optIntoOneTap': 'false', 'stopDeletionNonce': '', 'trustedDeviceRecords': '{}'}response = requests.post('https://www.instagram.com/accounts/login/ajax/', headers=headers, data=data, proxies=get_proxy())print(response.status_code)print(response.text)# 运行结果#PWD_INSTAGRAM_BROWSER:10:1658217374:AVtQAGM39dHHEHtO7U0tFDVnhUk+Wg2VMRNtL+jtmdLx5fpegdgNyMnTmBPfBWUP0lBNGBK9rrAyX4PZfdVMEf0ksXa5s98X/SlIVF78g92WU4w0JnQHArjoIlNzLNcb+wyuy1SBDRsN92Wy5dw+ghaBC7hSUNpVrmE=200{&quot;user&quot;:false,&quot;authenticated&quot;:false,&quot;status&quot;:&quot;ok&quot;} 代码就不贴出来了，偷偷放在知识星球&lt;虫术&gt;里面了,公众号有星球的优惠券，其实整个分析过程还是挺简单，有兴趣的同学可以自己试试.","link":"/20220719/JS%E9%80%86%E5%90%91%20%20instagram%E7%99%BB%E5%85%A5enc_password/"},{"title":"JS逆向 | 推特x-guest-token","text":"*本文章仅供学习交流,切勿用于非法通途,如有侵犯贵司请及时联系删除 一、整体分析首先就拿用户文章接口分析，复制出cURL转换成Python代码，分别删除cookie和其中比较特殊的参数然后尝试请求，多次尝试发现headers 中authorization和x-guest-token必须携带。 二、逆向分析1、authorization先用搜索法在所有可疑的地方打上断点，打完断点后注意这步很重要，清除cookie！清除cookie！清除cookie！ 清除完cookie后，重新发送请求，触发断点，发现RO是我们要找的值。 向上找发现 RO = Gr.d ，继续找Gr.d ，发现 Gr = n(“cnVF”)，进到这个函数发现，值是固定的，针不戳呀！ 2、x-guest-token老规矩先搜索法，打上断点，清除cookie清除cookie清除cookie然后重新发送请求，发现判断了下url是否是这个，是的话就赋值，直接去找这个请求发现，response就是我们需要的guest_token。 三、总结这里拿作者信息接口为例，首先访问activate接口申请一个guest_token，然后就可以访问嘞。 123456789101112131415161718import requestsheaders = { 'authority': 'api.twitter.com', 'authorization': 'Bearer AAAAAAAAAAAAAAAAAAAAANRILgAAAAAAnNwIzUejRCOuH5E6I8xnZz4puTs%3D1Zv7ttfk8LF81IUq16cHjhLTvJu4FA33AGWWjCpTnA', 'origin': 'https://twitter.com', 'referer': 'https://twitter.com/', 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36',}response = requests.post('https://api.twitter.com/1.1/guest/activate.json', headers=headers).json()headers['x-guest-token'] = response['guest_token']params = ( ('variables', '{&quot;screen_name&quot;:&quot;channelnewsasia&quot;,&quot;withSafetyModeUserFields&quot;:true,&quot;withSuperFollowsUserFields&quot;:true}'),)response = requests.get('https://twitter.com/i/api/graphql/mCbpQvZAw6zu_4PvuAUVVQ/UserByScreenName', headers=headers, params=params)print(response.text) 其实整个分析过程还是挺简单，有兴趣的同学可以自己试试，欢迎大家关注我的公众号qaq！","link":"/20220725/JS%E9%80%86%E5%90%91-%E6%8E%A8%E7%89%B9x-guest-token/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"安卓逆向","slug":"安卓逆向","link":"/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"Frida","slug":"Frida","link":"/tags/Frida/"},{"name":"主题配置","slug":"主题配置","link":"/tags/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Unidbg","slug":"Unidbg","link":"/tags/Unidbg/"},{"name":"Win逆向","slug":"Win逆向","link":"/tags/Win%E9%80%86%E5%90%91/"},{"name":"xpath","slug":"xpath","link":"/tags/xpath/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"安卓逆向","slug":"安卓逆向","link":"/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"爬虫","slug":"爬虫","link":"/categories/%E7%88%AC%E8%99%AB/"},{"name":"Frida","slug":"Frida","link":"/categories/Frida/"},{"name":"主题配置","slug":"主题配置","link":"/categories/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"Unidbg","slug":"Unidbg","link":"/categories/Unidbg/"},{"name":"Win逆向","slug":"Win逆向","link":"/categories/Win%E9%80%86%E5%90%91/"},{"name":"密码学","slug":"密码学","link":"/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/"}]}