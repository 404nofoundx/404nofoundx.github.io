{"pages":[],"posts":[{"title":"20211208|每日算法","text":"咬定青山不放松，立根原在破岩中。千磨万击还坚劲，任尔东西南北风。 0x001、两数之和地址：https://leetcode-cn.com/problems/two-sum/ 方法一、暴力循环 1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1,len(nums)): if nums[i]+nums[j]==target: return [i,j] return [] 方法二、哈希表 123456789class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: item = {} for i in range(len(nums)): if target-nums[i] in item: return [item[target-nums[i]],i] else: item[nums[i]] = i return [] 0x002、盛最多水的容器地址：https://leetcode-cn.com/problems/container-with-most-water/ 木桶能装多少水取决于最短的木板。 方法一、双指针 左右指针，每次移动比较矮的一侧。 123456789101112class Solution: def maxArea(self, height: List[int]) -&gt; int: left,right = 0,len(height)-1 max_area = 0 while left&lt;right: area = (right-left)*(min(height[right],height[left])) max_area = max(max_area,area) if height[left]&gt;=height[right]: right-=1 else: left+=1 return max_area 0x003、三数之和地址：https://leetcode-cn.com/problems/3sum/方法一、排序+双指针 长度小于3返回空列表 排序 取锚点元素，如果锚点元素大于0，代表后面没有三数和为零的元素，直接break，毕竟排过序 取锚点元素后一个为左指针left，最后一个为右指针right 循环 left&lt;right 三数和大于零，右边距向左移动一位 三数和小于零，左边距向右移动一位 三数和等于零，添加到result 判断左右边距是否重合，left是否等于left+1 left+=1 判断左右边距是否重合，right是否等于right-1 right-=1 收缩左右边距 12345678910111213141516171819202122232425262728class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: lenght = len(nums) result = list() if lenght&lt;3: return result nums.sort() for i in range(lenght): if nums[i]&gt;0: break if i&gt;0 and nums[i]==nums[i-1]: continue left,right = i+1,lenght-1 while left&lt;right: flag = nums[i] + nums[left] + nums[right] if flag&gt;0: right-=1 elif flag&lt;0: left+=1 else: result.append([nums[i],nums[left],nums[right]]) while left&lt;right and nums[left]==nums[left+1]: left+=1 while left&lt;right and nums[right]==nums[right-1]: right-=1 right-=1 left+=1 return result 12console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20211208/20211208%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"},{"title":"ARM指令集","text":"1 、LDR 和 STR加载/存储字和无符号字节指令，使用单一数据传送指令(STR 和 LDR)来装载和存储，单一字节或字的数据从/到内存LDR指令用于从内存中读取数据放入寄存器中，STR指令用于将寄存器中的数据保存到内存。 指令格式如下： 1234567LDR{cond}{T} Rd,&lt;地址&gt; ;加载指定地址上的数据(字),放入 Rd 中 STR{cond}{T} Rd,&lt;地址&gt; ;存储数据(字)到指定地址的存储单元,要存储的数据在 Rd 中 LDR{cond}B{T} Rd,&lt;地址&gt; ;加载字节数据,放入 Rd 中,即 Rd 最低字节有效,高 24 位清零 STR{cond}B{T} Rd,&lt;地址&gt; ;存储字节数据,要存储的数据在 Rd,最低字节有效 2、LDM 和 STM批量加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数，LDM 为加载多个寄存器，STM 为存储多个寄存器，允许一条指令传送 16 个寄存器任何子集或所有寄存器。LDM /STM 的主要用途是现场保护、数据复制、参数传送等。 指令格式如下: 1234567LDM{cond}&lt;模式&gt; Rn{!},reglist{^} STM{cond}&lt;模式&gt; Rn{!},reglist{^} LDMIA R0!,{R3-R9} ;加载 R0 指向的地址上的多字数据,保存到 R3～R9 中,R0 值更新 STMIA R1!,{R3-R9} ;将 R3～R9 的数据存储到 R1 指向的地址上,R1 值更新 STMFD SP!,{R0-R7,LR} ;现场保存,将 R0～R7、LR 入栈 LDMFD SP!,{R0-R7,PC}^;恢复现场,异常处理返回 3、 SWP寄存器和存储器交换指令，SWP 指令用于将一个内存单元(该单元地址放在寄存器Rn 中)的内容读取到一个寄存器 Rd 中,同时将另一个寄存器 Rm 的内容写入到该内存单元中。 指令格式如下: SWP{cond}{B} Rd,Rm,[Rn]、 其中，B 为可选后缀,若有B，则交换字节，否则交换 32 位字；Rd 为数据从存储器加载到的寄存器；Rm 的数据用于存储到存储器中，若 Rm 与 Rn 相同，则为寄存器与存储器内容进行交换；Rn 为要进行数据交换的存储器地址,Rn 不能与 Rd 和 Rm 相同. SWP 指令举例如下： 123SWP R1,R1,[R0] ;将 R1 的内容与 R0 指向的存储单元的内容进行交换 SWP R1,R2,,[R0] ;将R0指向的存储单元内容读取一字节数据到R1中(高24 位清零),并将R2的内容写入到该内存单元中(最低字节有效) ​ ​ 数据传送指令4、MOV数据传送指令，将 8 位图立即数或寄存器(operant2)传送到目标寄存器 Rd，可用于移位运算等操作。 指令格式如下： MOV{cond}{S} Rd,operand2 MOV 指令举例如下: 12345MOV R1#0x10 ;R1=0x10 MOV R0,R1 ;R0=R1 MOVS R3,R1,LSL #2 ;R3=R1＜＜2,并影响标志位 MOV PC,LR ;PC=LR ,子程序返回 5、MVN数据非传送指令，将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数。 指令格式如下: MVN{cond}{S} Rd,operand2 MVN 指令举例如下: 12MVN R1,#0xFF ;R1=0xFFFFFF00 MVN R1,R2 ;将 R2 取反,结果存到 R1 算术逻辑运算指令6、ADD加法运算指令，将 operand2 数据与 Rn 的值相加，结果保存到 Rd 寄存器。 指令格式如下： ADD{cond}{S} Rd,Rn,operand2 ADD 指令举例如下: 123ADDS R1,R1,#1 ;R1=R1+1 ADD R1,R1,R2 ;R1=R1+R2 ADDS R3,R1,R2,LSL #2 ;R3=R1+R2＜＜2 7、SUB减法运算指令，用寄存器 Rn 减去 operand2.结果保存到 Rd 中。 指令格式如下：SUB{cond}{S} Rd,Rn,operand2 SUB 指令举例如下： 1234SUBS R0,R0,#1 ;R0=R0-1 SUBS R2,R1,R2 ;R2=R1-R2 SUB R6,R7,#0x10 ;R6=R7-0x10 8、RSB逆向减法指令，用寄存器 operand2 减法 Rn，结果保存到 Rd 中。 指令格式如下：RSB{cond}{S} Rd,Rn,operand2 RSB 指令举例如下： 123RSB R3,R1,#0xFF00 ;R3=0xFF00-R1 RSBS R1,R2,R2,LSL #2 ;R1=R2＜＜2-R2=R2×3 RSB R0,R1,#0 ;R0=-R1 9、ADC带进位加法指令，将 operand2 的数据与 Rn 的值相加，再加上 CPSR 中的 C 条件标志位，结果保存到 Rd 寄存器。 指令格式如下; ADC{cond}{S} Rd,Rn,operand2 ADC 指令举例如下: 12ADDS R0,R0,R2 ADC R1,R1,R3 ;使用 ADC 实现 64 位加法,(R1、R0)=(R1、R0)+（R3、R2） 10、SBC带进位减法指令。用寄存器 Rn 减去 operand2，再减去 CPSR 中的 C 条件标志位的非（即若 C 标志清零，则结果减去 1），结果保存到 Rd 中。 指令格式如下： SCB{cond}{S} Rd,Rn,operand2 SBC 指令举例如下： 12SUBS R0，R0，R2 SBC R1，R1，R3 ;使用 SBC 实现 64 位减法,(R1,R0)-(R3,R2) 11、RSC带进位逆向减法指令。用寄存器 operand2 减去 Rn，再减去 CPSR 中的 C 条件标志位，结果保存到 Rd 中。 指令格式如下：RSC{cond}{S} Rd,Rn,operand2 RSC 指令举例如下： 12RSBS R2,R0,#0 RSC R3,R1,#0 ;使用 RSC 指令实现求 64 位数值的负数 12、AND逻辑与操作指令，将 operand2 值与寄存器 Rn 的值按位作逻辑与操作，结果保存到Rd 中。 指令格式如下： AND{cond}{S} Rd,Rn,operand2 AND 指令举例如下: 12ANDS R0,R0,#x01 ;R0=R0&amp;0x01,取出最低位数据 AND R2,R1,R3 ;R2=R1&amp;R3 13、ORR逻辑或操作指令，将operand2的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中。 指令格式如下：ORR{cond}{S} Rd,Rn,operand2 ORR 指令举例如下: 123ORR R0,R0,#x0F ;将 R0 的低 4 位置 1 MOV R1,R2,LSR #4 ORR R3,R1,R3,LSL #8 ;使用 ORR 指令将近 R2 的高 8 位数据移入到 R3 低 8 位 中 14、 EOR逻辑异或操作指令。将operand2的值与寄存器Rn的值按位作逻辑异或操作，结果保存到 Rd 中。 指令格式如下： EOR{cond}{S} Rd,Rn,operand2 EOR 指令举例如下 123EOR R1,R1,#0x0F ;将 R1 的低 4 位取反 EOR R2,R1,R0 ;R2=R1^R0 EORS R0,R5,#0x01 ;将 R5 和 0x01 进行逻辑异或,结果保存到 R0,并影响标志位","link":"/20211130/ARM%E6%8C%87%E4%BB%A4%E9%9B%86/"},{"title":"Crakeme01实战分析 IDA动态静态分析","text":"一、APK下载Crakeme01:Crakeme01.apk 二、jadx分析java代码根据AndroidManifest.xml找到程序入口第一眼看到的System.loadLibrary()，就知道有NDK开发SO了，首先判断输入是否是空，非空的话调用NI.greywolf(this, this.editText.getText().toString());，而greywolf是 三、IDA静态分析上来一看，发现没有java_开头，敲定是动态注册，直接看伪代码。 跟进去AD()看下，发现里面全是各种反调试，动态调试的时候直接nop掉就ok。 四、IDA动态调试在JNI_OnLoad开头下断点，nop掉反调试的部分。 JNI_OnLoad有三个函数，找最后一个的函数就是RegisterNatives，然后找RegisterNatives中的第三个参数，里面包含着对应关系。 跟进去按C，找到个bc函数。 在静态分析中找到bc，分析逻辑，dh主要做的是调试检测，如果没有被反调试，则return 1，否则kill 然后再return 0，ds这个函数猜测是加解密用的，flag没准就是v4的返回值，动态调试试一下。 ds函数打断点，对照静态调试的伪代码，找到指令，BLX后的返回值推测是flag，查看R0寄存器。 找到flag=hello5.1，还不算难.jpg。","link":"/20210918/Crakeme01%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90-IDA%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"},{"title":"NDK开发小结","text":"一、JNI作用：用于java代码和C++、c代码的交互（代码混编）。 分类使用：Jni静态注册、jni动态注册 二、静态注册1、定义被native修饰的方法1public native String Getstring(); 2、根据java代码生成.h头文件（javah -jni 类的包名路径）1javah -jni com.example.jnitest.MainActivity 3、编写C/C++代码，导入.h头文件，实现我们.h头文件中方法123456789#include &lt;JNItest.h&gt;JNIEXPORT jstring JNICALL Java_com_example_jnitest_MainActivity_Getstring (JNIEnv *env, jobject obj) { jstring str = (*env)-&gt;NewStringUTF(env, &quot;hello ndk&quot;); return str; } 4、编写（配置）两个mk文件：application.mk/android.mk1234567891011#application.mkAPP_ABI := armeabi#android.mkLOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := JNItest LOCAL_SRC_FILES := JNItest.c LOCAL_ARM_MODE := armLOCAL_LDLIBS += -llog include $(BUILD_SHARED_LIBRARY) 5、通过ndk-build生成so文件1ndk-build 6、java代码中加载so文件/libs文件下去头去尾（头：lib；尾：.so）123static{ System.loadLibrary(&quot;JNItest&quot;);} 7、build.gradle文件配置123456androi -ddefaultConfig --ndk { // 设置支持的SO库架构 abiFilters 'armeabi' ,'x86', 'armeabi-v7a', 'x86_64','arm64-v8a' } 8、main创建jniLibs文件夹将so文件复制123456main -jniLibs --armeabi ---libJNItest.so --armeabi-v7a ---libJNItest.so 三、动态注册1、.c文件编写JNI_OnLoadFindClass处填写对应类 1234567891011121314151617JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved){ JNIEnv* env; if((*vm)-&gt;GetEnv(vm, (void**)&amp;env, JNI_VERSION_1_4)!=JNI_OK){ return JNI_ERR; } jclass cls=(*env)-&gt;FindClass(env, &quot;com/example/myjnireistest/MainActivity&quot;); if((*env)-&gt;RegisterNatives(env, cls, jninativemethod,2)!=JNI_OK){ return JNI_ERR; } return JNI_VERSION_1_4;} 2、.c文件定义方法结构体123456789101112JNINativeMethod jninativemethod[]={ { &quot;getInt&quot;, &quot;()I&quot;, (void*)GetInt }, { &quot;getChar&quot;, &quot;()C&quot;, (void*)GetChar, }}; 3、.c文件对应C函数12345678jint GetInt (JNIEnv *env, jobject obj){ return 99;}jchar GetChar(JNIEnv* env, jobject obj){ return 'y';} 4、java代码逻辑12345static { System.loadLibrary(&quot;MyJniTest&quot;);}public native int getInt();public native char getChar(); 四、SO库获取java层字段值12345678//反射获取对应类jclass clazz=(*env)-&gt;FindClass(env, &quot;com/example/myjnilogin/MainActivity&quot;);//获取实例字段id (env, clazz, 字段名,字段类型)jfieldID fieldid = (*env)-&gt;GetFieldID(env, clazz, &quot;userId&quot;,&quot;Ljava/lang/String;&quot;);//根据实例id获取对应的值jstring jstr_user = (*env)-&gt;GetObjectField(env, obj, fieldid);//将string转化charconst char* user= (*env)-&gt;GetStringUTFChars(env, jstr_user, 0); 五、SO库调用JAVA函数1234//反射获取方法idjmethodID methodID = (*env)-&gt;GetMethodID(env,clazz, &quot;pwError&quot;, &quot;()V&quot;);//call调用方法(*env)-&gt;CallVoidMethod(env,obj, methodID);","link":"/20210831/NDK%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"},{"title":"ARM汇编小结","text":"一、ARM汇编规范1、书写规范 所有的符号都必须在一行书写，在后面不用添加高级语言所用的分号。 ARM汇编器对标识符的大小写敏感，书写符号以及指令时字母大小写一定要一致。 一条ARM指令，伪指令。寄存器名可以全部写为大写字母,也可以全部为小写字母, 但是不能大小写混合编写使用。 注释使用(分号)，注释内容由(分号)开始到执行结束。 例如：[符号] &lt;指令|条件|S&gt; &lt;操作数&gt;[;注释] 2、符号符号可以代表地址、变量、数字变量，当符号代表地址时又叫标号，符号就是变量的变量名、数字常量的名称、标号，符号的命名规则如下： 符号由大小写字母、数字以及下划线组成； 除局部标号以数字开头外，其它的符号不能以数字开头； 符号区分大小写，且所有字符都是有意义的； 符号在其作用域范围必须是唯一的； 符号不能与系统内部或系统预定义的符号同名； 符号不要与指令助记符、伪指令同名。 3、常量常量的分类：数字常数、字符常量、布尔常量 （1）数字常数有三种表示方式： 十进制数，如：12、5、876、0 十六进制数如：0x4387、0xFF0、0x1 n 进制数用n-XXX 表示，其中n 为2～9，XXX 为具体的数，如：2-010111、8-4363156 （2）字符常量 字符常量由一对单引号及中间字符串表示，标准C 语言中的转义符也可使用。如果需要包含双引号或$，必须使用”” “”和$$代替。 如：Hello SETS “Hello World！” Errorl SETS “The parameter ““VFH””error$$2” （3）布尔常量 布尔常量的逻辑真为{TRUE}，逻辑假为{FALSE}。 如： testno SETS {FALSE} 4、ARM指令的格式ARM是三地址指令格式，指令的基本格式为： 1234567&lt;opcode&gt; {&lt;cond&gt;} {s} &lt;Rd&gt;, &lt;Rn&gt; {,&lt;operand2&gt;} opcode: 指令助记符 cond: 执行条件 s: 是否影响CPSR寄存器的值 Rd: 目标寄存器 Rn: 第一个操作数的寄存器 operand2: 第二个操作数 其中&lt; &gt;号内为必须的，{ }里面的项是可选的 5、跳转指令B 无条件跳转 BEQ 相等后跳转 BNE 不相等后跳转 BL 带链接的无条件跳转 BX 带状态切换的无条件跳转 根据目标地址最低位切换状态（arm/thumb） BLX 带链接和状态切换的无条件跳转 B loc_地址 6.存储器与寄存器交互数据指令存储器（主存，内存）寄存器中放的数据：可以是字符串，可以是数，也可以是一个地址，它可以放各种类型的数据存储地址单元：地址（如0x00004000）与地址中存在的值 A、LDR指令 (Load from memory into register)LDR指令的格式： LDR{条件} 目的寄存器 &lt;存储器地址&gt; 作用：将存储器地址所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 ← LDR指令的寻址方式比较灵活,实例如下： 123456789101112131415161718192021LDR R0，[R1] ；将存储器地址为R1的字数据读入寄存器R0。LDR R0，[R1，R2] ；将存储器地址为R1+R2的字数据读入寄存器R0。LDR R0，[R1，#8] ；将存储器地址为R1+8的字数据读入寄存器R0。LDR R0，[R1],R2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1],#8 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+8的值存入R1。LDR R0，[R1，R2]! ；将存储器地址为R1+R2的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1，LSL #3] ；将存储器地址为R1*8的字数据读入寄存器R0。LDR R0，[R1，R2，LSL #2] ；将存储器地址为R1+R2*4的字数据读入寄存器R0。LDR R0，[R1,,R2，LSL #2]！ ；将存储器地址为R1+R2*4的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，[R1],R2，LSL #2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，Label ；Label为程序标号，Label必须是当前指令的-4~4KB范围内。 B、STR指令 (Store from a register into memory)STR指令的格式为： STR{条件} 源寄存器，&lt;存储器地址&gt; STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。→ 123456STR r1, [r0] ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中STR R0，[R1]，＃8 ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。STR R0，[R1，＃8] ；将R0中的字数据写入以R1＋8为地址的存储器中。 C、LDM指令 (Load from memory into register / Load much)LDM指令的格式为： LDM {cond} &lt;模式&gt; Rn{!},reglist{^} LDM是将内存中堆栈内的数据，批量的赋值给寄存器，即是出栈操作 → LDM R0,｛R1-R3｝将R0指向的存储单元的数据依次加载到R1,R2,R3寄存器 D、STM指令 (Store from a register into memory / Store much)STM指令的格式为： STM {cond} &lt;模式&gt; Rn{!},reglist{^} STM：将一个寄存器列表的数据存储到指定的存储器 ← STM R0,{R1-R3} ;把R1,R2,R3保存到堆栈R0中 E、PUSH和POPPUSH:将寄存器值推入堆栈 压栈--&gt; POP：将堆栈值推出到寄存器 出栈 &lt;-- F、SWPSWP将寄存器与存储器之间的数据进行交换 SWP指令的格式为： SWP Rd,Rm,[Rn] Rd 为数据从存储器加载到的寄存器；Rm的数据用于存储到存储器中，若Rm与Rn相同，则为寄存器与存储器内容进行交换；Rn为要进行数据交换的存储器地址，Rn不能与Rd和Rm相同。 123SWP R1, R1 [R0] ;将R1寄存器与R0指向的存储单元的内容进行交换SWP R1, R2, [R0] ;把R0所指向的内容读到R1，同时把R2的内容写到 [R0] 7、数据传送指令MOV：将立即数或寄存器的数据传送到目标寄存器 ← 1MOV R0, #8 ;R0=8 8、数据算术运算指令​ ←​ ADD,SUB,MUL,DIV (加、减、乘、除)​ 有符号，无符号运算；带进位运算 9、数据算术运算指令与：AND或：ORR异或：EOR 移位：实质是乘，除，类似于小数点移位，但相反。小数点左移，数变小；右移变大。但逻辑移位，左移变大，右移变小，且按2的倍数进行，因为是2进制。 LSL：逻辑左移←LSR：逻辑右移← LSL R0,R1，#2 ；R0=R1*4 LSR R0,R1，#2 ；R0=R1*2 10、比较指令CMP：比较 1CMP R0 #0 ;R0寄存器中的值与0比较","link":"/20210906/ARM%E6%B1%87%E7%BC%96%E5%B0%8F%E7%BB%93/"},{"title":"IDA安卓10动态调试","text":"一、调式环境1、IDA Pro 7.5 2、Pixel 2 XL 安卓10 二、环境准备找到 IDA目录下的文件夹dbgsrv中的android_server，然后推到手机 /data/local/tmp目录 12PS D:\\IDA\\dbgsrv&gt; adb push .\\android_server /data/local/tmp.\\android_server: 1 file pushed, 0 skipped. 32.6 MB/s (786868 bytes in 0.023s) 然后切换到对应目录，给予777权限并启动，android_server默认端口23946 1234567891011PS C:\\Users\\Admin&gt; adb shelltaimen:/ $ sutaimen:/ # cd /data/local/tmp/127|taimen:/data/local/tmp # chmod 777 android_server//重要：安卓10 IDA Pro 7.5 要用这种方式启动android_server taimen:/data/local/tmp # IDA_LIBC_PATH=/apex/com.android.runtime/lib/bionic/libc.so /data/local/tmp/android_serverIDA Android 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020Listening on 0.0.0.0:23946... 特别注意：安卓10 IDA Pro 7.5 要用这种方式启动android_serverIDA_LIBC_PATH=/apex/com.android.runtime/lib/bionic/libc.so /data/local/tmp/android_server转发端口 1PS C:\\Users\\Admin&gt; adb forward tcp:23946 tcp:23946 三、动态调试1、调试模式挂起app1adb shell am start -D -n com.example.javandk1/.MainActivity 2、Ida选择Linux/Android debugger 3、填入Host和Port 4、选择调试的APP 5 、加载完毕后，设置ida三钩、 6、DDMS查看挂机的端口 7、jdb放开调试1jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8600 接下来就可以动态调试了 IDA调试常用快捷键： F2快速下断点。 F7单步步入，F8单步步过。 F4运行到光标所在位置。 G跳到地址和函数名。 U解析成未定义数据。 C将数据解析成汇编指令。 光标放在函数头位置，按P键将汇编指令识别为函数。 CTRL+F搜索。 F5将汇编指令识别伪代码。 ALT+G查看当前指令是Thumb指令还是ARM指令。 CTRL+S看见系统所有的模块。 X交叉引用。","link":"/20210914/IDA%E5%AE%89%E5%8D%9310%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"},{"title":"Unidbg(一)环境安装及配置","text":"一、环境准备1、IntelliJ IDEA直接官网下载就可以 2、Maven环境官网：https://maven.apache.org/download.cgi 解压文件： 1tar -zxvf apache-maven-3.5.4-bin.tar.gz 配置环境变量： 12export MAVEN_HOME=/usr/local/apache-maven-3.8.4export PATH=$MAVEN_HOME/bin:$PATH 测试是否配置成功：mvn -version配置maven 二、导入代码1git clone https://github.com/zhkl0228/unidbg.git 等待加载完成后，运行下例子，运行成功就代表配置完成 12console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20211207/Unidbg-%E4%B8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"title":"Python自动化构建雷电模拟器","text":"1、launch 支持2种启动雷电模拟器的方式–name顾名思义，应该是模拟器的标题栏的名字，本人经过验证果然如此!–index mnq_idx，模拟器的索引，第一个是0，第二个是1，以此类推 启动默认模拟器的2种方法：lsconsole.exe launch –name 雷神模拟器lsconsole.exe launch –index 0 2、quit 退出模拟器也提供了3种退出方式，和launch对应，不再累述。 3、quitall 退出模拟器退出所有开着的模拟器。 4、属性设置部分精彩部分来了，同样，修改属性时也要指定需要修改的是哪个模拟器的属性（多开的情况），仍然采用的是以上的3种方式，雷神提供的属性字段有： modify &lt;–name mnq_name | –index mnq_idx&gt;[–resolution ] // 自定义分辨率[–cpu &lt;1 | 2 | 3 | 4&gt;] // cpu设置[–memory &lt;512 | 1024 | 2048 | 4096 | 8192&gt;] // 内存设置[–manufacturer asus] // 手机厂商[–model ASUS_Z00DUO] // 手机型号[–pnumber 13812345678] // 手机号码[–imei ] // imei设置，auto就自动随机生成[–imsi ][–simserial ][–androidid ][–mac ] //12位m16进制mac地址[–autorotate &lt;1 | 0&gt;][–lockwindow &lt;1 | 0&gt;] 写个例子，修改默认模拟器的分辨率为600*360,dpi 160,cpu为1核，内存1024，imei随机，这样写：lsconsole.exe modify –index 0 –resolution 600,360,160 –cpu 1 –memory 1024 –imei auto 注：调用modify需要在模拟器启动前，不然可能不生效 5、新增模拟器add [–name mnq_name] 6、复制模拟器copy [–name mnq_name] –from 注意：from参数既可以是名字也可以是索引，判断规则为如果全数字就认为是索引，否则是名字 7、删除模拟器remove &lt;–name mnq_name | –index mnq_idx&gt; 8、备份，还原命令backup &lt;–name mnq_name | –index mnq_idx&gt; –filerestore &lt;–name mnq_name | –index mnq_idx&gt; –file 9、list2F:\\BaiZhi\\lsplayer&gt;lsconsole.exe list20,雷神模拟器,2032678,1704928,1,7456,35001,雷神模拟器-1,852422,590830,1,3772,3180 list2一次性返回了多个信息，依次是：索引，标题，顶层窗口句柄，绑定窗口句柄，是否进入android，进程PID，VBox进程PID官方文档 Python自动化构建模拟器1234567891011import os#切换至命令目录os.chdir('D:\\LDPlayer3.0')# 删除模拟器os.system('ldconsole.exe remove --name test2')#创建新的模拟器os.system('ldconsole.exe add --name test2')#设置模拟器属性os.system('ldconsole.exe modify --name test2 --resolution 1080,1920,480 --cpu 4 --imei auto --imsi auto --mac auto --manufacturer HUAWEI --model LIO-AN00')#打开模拟器os.system('ldconsole.exe launch --name test2') Python导入mitmproxy证书两种方式导入mitmproxy证书1、通过adb 2、是通过雷电ldconsole命令 1234567891011121314151617#adb --name &quot;雷神模拟器&quot;os.system('adb devices')# #推送至手机目录#ldconsole.exe push --name test2 --remote /sdcard --local F:/python3/RebortLeiDian/c8750f0d.0os.system('adb push F:/python3/RebortLeiDian/c8750f0d.0 /sdcard')# #给予写入权限#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell mount -o rw,remount /system&quot;os.system('adb shell &quot;mount -o rw,remount /system&quot;')# #推送至系统目录#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell mv /sdcard/c8750f0d.0 /system/etc/security/cacerts&quot;os.system('adb shell &quot;mv /sdcard/c8750f0d.0 /system/etc/security/cacerts&quot;')# #给予证书权限#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell chmod 644 /system/etc/security/cacerts/c8750f0d.0&quot;os.system('adb shell &quot;chmod 644 /system/etc/security/cacerts/c8750f0d.0&quot;')# #设置代理#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell settings put global http_proxy ip:端口&quot;os.system('adb shell &quot;settings put global http_proxy ip:端口&quot;') 完整代码，可以关注公众号回复: LD console.log(&quot;公众号:虫术&quot;) console.log(&quot;wx:spiderskill&quot;) 欢迎大家前来交流","link":"/20210723/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E9%9B%B7%E7%94%B5%E6%A8%A1%E6%8B%9F%E5%99%A8/"},{"title":"Python根据关键词在360、百度、bing下载图片","text":"1. 简介输入一组关键词，指定所需图片个数，在常见搜索引擎中检索，记录图片url地址，并将图片保存在指定目录下。 百度图片：https://image.baidu.com/ 360搜图：https://image.so.com/ 微软：https://cn.bing.com/images/trending?FORM=ILPTRD） 2. 功能 支持的搜索引擎: 360, 必应, 百度 可配置线程数及代理 3. 安装3.1 安装相关python库1pip3 install -r requirements.txt 4. 如何使用4.1 命令行12345usage: image_downloader.py [-h] [--engine {baidu,bing,360}] [--max-number MAX_NUMBER] [--num-threads NUM_THREADS] [--timeout TIMEOUT] [--output OUTPUT] [--user-proxy USER_PROXY] keywords help 12345678910111213141516171819202122usage: image_downloader.py [-h] [--engine {baidu,bing,360}] [--max-number MAX_NUMBER] [--num-threads NUM_THREADS] [--timeout TIMEOUT] [--output OUTPUT] [--user-proxy USER_PROXY] keywordsImage Downloaderpositional arguments: keywords 搜索关键词optional arguments: -h, --help show this help message and exit --engine {baidu,bing,360}, -e {baidu,bing,360} 抓取网站. --max-number MAX_NUMBER, -n MAX_NUMBER 下载图片数量 --num-threads NUM_THREADS, -j NUM_THREADS 进程数 --timeout TIMEOUT, -t TIMEOUT 下载超时 --output OUTPUT, -o OUTPUT 输出文件夹 --user-proxy USER_PROXY, -p USER_PROXY 是否使用代理(默认不使用) 运行： 123456789101112131415161718python image_downloader.py &quot;中国地图&quot; -e &quot;360&quot; -n 10目标网站为:360关键词为: 中国地图抓取数量为:10条目标网站搜索结果为:1500目标抓取:10条 已抓取:10条##下载成功: 360_a674c5fccbd187575dbe3c46698d841a.jpeg##下载成功: 360_20760e3529df9287b80066168f35eae5.png##下载成功: 360_cb28e97178694f3f45788eec0894bf55.jpg##下载成功: 360_82dcd18912bbd65572d464e3e990eb8b.png##下载成功: 360_dbfb153accb1e125ea40fcd5585e3e5e.jpeg##下载成功: 360_7f95f7893557d445c668f448b159d9e0.jpg##下载成功: 360_968b76513aa6a56866bc5a68c873f5cd.png##下载成功: 360_aabb350a736c8418f8f581a660f9fb74.png##下载成功: 360_06ffc47d52f056cb2848315c2e6cb2ef.jpeg##下载成功: 360_a99a12dd76843c48264f215c50b099d0.jpegFinished. downloader.py:做图片下载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&quot;&quot;&quot; Download image according to given urls and automatically rename them in order. &quot;&quot;&quot;# -*- coding: utf-8 -*-# author: Yabin Zheng# Email: sczhengyabin@hotmail.comfrom __future__ import print_functionimport hashlibimport shutilimport imghdrimport osimport concurrent.futuresimport requestsheaders = { &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Proxy-Connection&quot;: &quot;keep-alive&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot; &quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, sdch&quot;,}def download_image(image_url, dst_dir, file_prefix, timeout=20, use_proxy=False): proxies = None # if proxy_type: # proxies = { # &quot;http&quot;: proxy_type + &quot;://&quot; + proxy, # &quot;https&quot;: proxy_type + &quot;://&quot; + proxy # } response = None try_times = 0 while True: try: try_times += 1 response = requests.get( image_url, headers=headers, timeout=timeout, proxies=proxies) image_name = get_img_name(response.content) file_name = file_prefix + &quot;_&quot; + image_name file_path = os.path.join(dst_dir, file_name) with open(file_path, 'wb') as f: f.write(response.content) response.close() file_type = imghdr.what(file_path) if file_type in [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;png&quot;, &quot;bmp&quot;]: new_file_name = &quot;{}.{}&quot;.format(file_name, file_type) else: new_file_name = &quot;{}.{}&quot;.format(file_name, 'jpg') new_file_path = os.path.join(dst_dir, new_file_name) shutil.move(file_path, new_file_path) print(&quot;##下载成功: {} &quot;.format(new_file_name)) break except Exception as e: if try_times &lt; 3: continue if response: response.close() print(&quot;##下载错误: {} {}&quot;.format(e.args,image_url)) breakdef download_images(image_urls, folder_dir='./download_images', file_prefix=&quot;img&quot;, max_workers=50, timeout=20, use_proxy=False): &quot;&quot;&quot; 图片下载 :param image_urls:图片列表 :param folder_dir:文件夹地址 :param file_prefix:文件来源 :param max_workers:最大并发 :param timeout:下载超时 :param use_proxy:是否使用代理 :return: &quot;&quot;&quot; with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor: future_list = list() count = 0 if not os.path.exists(folder_dir): os.makedirs(folder_dir) for image_url in image_urls: future_list.append(executor.submit( download_image, image_url, folder_dir, file_prefix, timeout, use_proxy)) count += 1 concurrent.futures.wait(future_list, timeout=180)def get_img_name(image_url): &quot;&quot;&quot; 图片name :param image_url: :return: &quot;&quot;&quot; md5 = hashlib.md5() md5.update(image_url) image_name = md5.hexdigest() return image_name image_downloader.py：做启动调度 123456789101112131415161718192021222324252627282930313233343536373839404142from __future__ import print_functionimport argparseimport crawlerimport downloaderimport sysdef main(argv): parser = argparse.ArgumentParser(description=&quot;Image Downloader&quot;) parser.add_argument(&quot;keywords&quot;, type=str, help='搜索关键词') parser.add_argument(&quot;--engine&quot;, &quot;-e&quot;, type=str, default=&quot;baidu&quot;, help=&quot;抓取网站.&quot;, choices=[&quot;baidu&quot;, &quot;bing&quot;, &quot;360&quot;]) parser.add_argument(&quot;--max-number&quot;, &quot;-n&quot;, type=int, default=100, help=&quot;下载图片数量&quot;) parser.add_argument(&quot;--num-threads&quot;, &quot;-j&quot;, type=int, default=50, help=&quot;进程数&quot;) parser.add_argument(&quot;--timeout&quot;, &quot;-t&quot;, type=int, default=20, help=&quot;下载超时&quot;) parser.add_argument(&quot;--output&quot;, &quot;-o&quot;, type=str, default=&quot;./download_images&quot;, help=&quot;输出文件夹&quot;) parser.add_argument(&quot;--user-proxy&quot;, &quot;-p&quot;, type=str, default=False, help=&quot;是否使用代理(默认不使用)&quot;) args = parser.parse_args(args=argv) # 默认不加代理 use_proxy = False crawled_urls = crawler.crawl_image_urls(args.keywords, engine=args.engine, max_number=args.max_number, use_proxy=use_proxy) downloader.download_images(image_urls=crawled_urls, folder_dir=args.output, max_workers=args.num_threads, timeout=args.timeout, use_proxy=use_proxy, file_prefix=args.engine) print(&quot;Finished.&quot;)if __name__ == '__main__': main(sys.argv[1:]) 项目地址:https://github.com/404SpiderMan/DownloadImage 1234console.log(&quot;公众号:虫术&quot;)console.log(&quot;wx:spiderskill&quot;)console.log(&quot;Blog:http://404nofoundx.top/&quot;)欢迎关注！探讨爬虫逆向及搬砖摸鱼技巧！","link":"/20211203/Python%E6%A0%B9%E6%8D%AE%E5%85%B3%E9%94%AE%E8%AF%8D%E5%9C%A8360%E3%80%81%E7%99%BE%E5%BA%A6%E3%80%81bing%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/"},{"title":"smali动态调式","text":"一、Android Studio 调试的原理使用 Android Studio 进行动态调试，通过 Android Studio 导入反编译出的完整的 smali 代码，设置好调试所需的条件，设置断点。将移动设备连接至 PC端，然后运行待调试的apk应用程序，当该应用程序执行流程，运行至smali代码的断点处时，就会触发断点。从而可以进行进一步的分析和调试，让程序的运行流程和中间参数更清晰。 二、流程1、待调试的apk设置debuggable=”true”使用AndroidKiller工具，反编译我们要调试的APK文件，反编译成功后，在“工程管理器”找到AndroidManiFest.xml文件，再找到该文件里的application标签，查看标签中是否存在android:debuggable=“true”属性，如果文件中不存在android:debuggable=“true”，则需要进行添加。 2、导入Project3、调试环境配置​ 配置远程调试的选项，选择Run–&gt;Edit Configurations选项， 点击“+”号，新建remote类型调试器，设置Name，修改端口号，可以选择未被占用的任意端口，本次设置为8700。 4、动态调试smali代码（1）普通模式调试查看app的进程pid 1adb shell ps 进行端口转发，其中的“tcp”是之前配置调试环境时指定的端口号：8700，“jdwp”这里指的是我们要调试的程序的进程pid 1adb forward tcp:8709 jdwp:4917 （2）调试模式启动应用程序调试1adb shell am start –D -n 应用程序包名/应用程序入口界面 查看app的进程pid 1adb shell ps 进行端口转发，其中的“tcp”是之前配置调试环境时指定的端口号：8700，“jdwp”这里指的是我们要调试的程序的进程pid 1adb forward tcp:8709 jdwp:4917 快捷键：F9：跳到下一个断点F8：单步步过F7：单步步入Alt+shift+F7:强制进入Shift+F8:单步步出","link":"/20210915/smali%E5%8A%A8%E6%80%81%E8%B0%83%E5%BC%8F/"},{"title":"xpath 骚操作清单","text":"一、xpath不匹配含有指定子节点或属性的节点1. 不匹配含有指定子节点的节点如，不匹配子节点含有 ‘i’ 节点的 ‘p’ 节点 1xpath('//p[not(i)]') 2. 不匹配含有指定属性的节点如，不匹配子节点含有 ‘class’ 属性的 ‘p’ 节点 1xpath('//p[not(@class)]') 3. 二者联合使用，不匹配含有指定子节点和属性的节点如，不匹配子节点含有 ‘i’ 节点和子节点含有 ‘class’ 属性的 ‘p’ 节点 1xpath('//p[not(i) and not(@class)]')","link":"/20210916/xpath-%E9%AA%9A%E6%93%8D%E4%BD%9C%E6%B8%85%E5%8D%95/"},{"title":"实战分析自毁程序Crackme IDA动态调试","text":"一、目标Crackme：https://github.com/404nofoundx/Cloud/blob/main/AliCrackme.zip 二、查看java代码二话不说上jadx，通过AndroidManifest.xml文件确定入口。 三、IDA静态分析 四、IDA动态分析打上断点 还没等到断点的时候，程序就崩溃了，猜测有反调试。 这次在JNI_OnLoad下断点，看看是哪里崩溃的，多次尝试发现在此处崩溃，用00000000修改此处命令。 修改前 修改后 反调试安全跳过，重新在Java_com_yaotong_crackme_MainActivity_securityCheck 设置断点。 查看R2寄存器 Flag = aiyou,bucuoo AliCrackme主要考验了过反调试和动态调试，还挺简单.jpg","link":"/20210917/%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E8%87%AA%E6%AF%81%E7%A8%8B%E5%BA%8FCrackme-IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"},{"title":"霸哥磁力搜索apk过签名校验","text":"一、什么是签名校验签名验证，就是在APP中写入自己私钥的hash值，和一个获取当前签名中的私钥hash值的函数两个值相一致，那么就说明APP没有被改动允许APP运行。 如果两值不一致那么说明APP是被二次打包的，APP就自我销毁进程。 签名验证可以在两个地方做，一个是在MainActivity.java的OnCreate函数中做，一个是在原生代码文件的JNI_OnLoad函数中做。 二、验证是否是签名校验用Android killer随意改下smail代码然后重新打包，发现APP闪退。 三、Jadx查看JAVA代码/IDA查看so签名校验一般都是在MainActivity.java的OnCreate函数中做，或者是在原生代码文件的JNI_OnLoad函数中做，首先查看OnCreate，里面有个qian，跟进去看看。 qian里面就是查看APP哈希值是否改变，这是第一个地方。 这里调用了一个bug，而bug写在了so里面，有很大嫌疑，ida看见这个so。 IDA查看bug这个函数采用的是静态注册，里面调用了一个getSignHashCode，跟进去看看。 四、过签名校验首先处理So文件，把exit换成nop，然后到处替换原来的so。 然后修改smail代码，把调用qian的地方给注释掉然后重新打包。 重打包后签名校验已经过掉了。","link":"/20211115/%E9%9C%B8%E5%93%A5%E7%A3%81%E5%8A%9B%E6%90%9C%E7%B4%A2apk%E8%BF%87%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/"},{"title":"某豆*__DATA__数据加密","text":"一、确定逻辑获取的数据复制给 window.__DATA__ 全局搜索，确定位置 跟进去发现，在这个位置生成数据 验证一下 二、调试巴拉巴拉 三、搭建解密服务123456789101112131415161718192021222324252627282930313233343536373839var r = &quot;WKVZcEaRd7/………………&quot;;var i = 16var Q = 4096var p = { start: 2, end: 7}var K = {}…………………………………………………………………………………………………………………………………………………此处省略N字……………………………………………………………………………………………………………………………………………………………………………………function decrypt(r) { var a = encry2arr_from(r, &quot;base64&quot;) // 0 , s = Math.max(Math.floor((a.length - 2 * i) / 3), 0) // 40 , u = a_slice(a, s, s + i); // 41 a = concat([a_slice(a, 0, s), a_slice(a, s + i)]); // 43 45 47 var c_data = hash(concat([u, encry2arr_from(&quot;&quot;)])); // 49 67 69 var l = {} l[c_data] = a var data = n_n((l = {}, l[c_data] = a, l)) // console.log(data) // console.log(data.payload.items[0]) var d_temp = data.payload.items var ret_val = JSON.stringify(d_temp) return ret_val}function get_page(arg){ console.log(arg) return decrypt(arg)}module.exports = { get_page} spider_server.js 12345678910111213141516var express = require('express');var douban = require('./douban');var app = express();const multipart = require('connect-multiparty')const multipartyMiddleware = multipart()app.post('/douban', multipartyMiddleware, (req, res) =&gt; { console.log(req) var result = douban.get_page(req.body.p1) res.send(result)})app.listen(23341, function () {}) 123全部代码放在百度云盘了链接：https://pan.baidu.com/s/1Gshwaeg8sKnb6Nx1PEI1Vw 提取码：6666 123console.log(&quot;wx:spiderskill&quot;)console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20211203/%E6%9F%90%E8%B1%86-DATA-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"title":"JNI规范文档","text":"JNI规范文档12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094#ifndef JNI_H_#define JNI_H_#include &lt;sys/cdefs.h&gt;#include &lt;stdarg.h&gt;#ifdef HAVE_INTTYPES_H# include &lt;inttypes.h&gt; /* C99 */ //这个是JNI规范中定义的基本数据类型 //typedef 关键字，可以使用它来为类型取一个新的名字。 //举个例子：typedef unsigned char BYTE;在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 */#elsetypedef unsigned char jboolean; /* unsigned 8 bits */typedef signed char jbyte; /* signed 8 bits */typedef unsigned short jchar; /* unsigned 16 bits */typedef short jshort; /* signed 16 bits */typedef int jint; /* signed 32 bits */typedef long long jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 */#endif/* &quot;cardinal indices and sizes&quot; */typedef jint jsize; //表示返回数组的大小#ifdef __cplusplus/* * Reference types, in C++ //与C++有关的定义 */class _jobject {};class _jclass : public _jobject {};class _jstring : public _jobject {};class _jarray : public _jobject {};class _jobjectArray : public _jarray {};class _jbooleanArray : public _jarray {};class _jbyteArray : public _jarray {};class _jcharArray : public _jarray {};class _jshortArray : public _jarray {};class _jintArray : public _jarray {};class _jlongArray : public _jarray {};class _jfloatArray : public _jarray {};class _jdoubleArray : public _jarray {};class _jthrowable : public _jobject {}; //为C++的一些类型进行重新定义typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak;#else /* not __cplusplus *//* * Reference types, in C. //与C有关的，继续为类型起新的名字；有arrary表示按JNI 标准定义的数组类型 */ typedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak;#endif /* not __cplusplus */ //两个方法ID和字段IDstruct _jfieldID; /* opaque structure */typedef struct _jfieldID* jfieldID; /* field IDs */struct _jmethodID; /* opaque structure */typedef struct _jmethodID* jmethodID; /* method IDs */ //定义一个结构体JNIInvokeInterface，是一个调用接口的结构体struct JNIInvokeInterface; //定义一个联合体jvalue，里面有各种类型typedef union jvalue { jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l;} jvalue; //定义一个枚举jobjectRefType，里面有各种枚举元素typedef enum jobjectRefType { JNIInvalidRefType = 0, JNILocalRefType = 1, JNIGlobalRefType = 2, JNIWeakGlobalRefType = 3} jobjectRefType; //定义一个动态注册JNINativeMethod结构体，这个与动态注册有关，里面有三个元素typedef struct { const char* name; //第一个参数 name 是java 方法名； const char* signature; //第二个参数 signature 用于描述方法的参数与返回值，也就是java方法签名信息， void* fnPtr; //第三个参数 fnPtr 是函数指针，指向 jni 函数；} JNINativeMethod; // 其中，第二个参数 signature 使用字符串记录方法的参数与返回值，具体格式形如“()V”、“(II)V”，其中分为两部分，括号内表示的是参数，括号右侧表示的是返回值；struct _JNIEnv;struct _JavaVM; //定义一个JNINativeInterface结构体，表示原生调用接口的结构体typedef const struct JNINativeInterface* C_JNIEnv;#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#else //这里有两个接口，一个是本地接口，一个是调用接口typedef const struct JNINativeInterface* JNIEnv;//JNI本地接口typedef const struct JNIInvokeInterface* JavaVM;//JNI调用接口#endif //本地接口结构体的定义struct JNINativeInterface { void* reserved0; void* reserved1; void* reserved2; void* reserved3; jint (*GetVersion)(JNIEnv *); //jint返回的是版本信息 //jclass，返回的是类 jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*,jsize); jclass (*FindClass)(JNIEnv*, const char*); jmethodID (*FromReflectedMethod)(JNIEnv*, jobject); jfieldID (*FromReflectedField)(JNIEnv*, jobject); jobject (*ToReflectedMethod)(JNIEnv*, jclass, jmethodID, jboolean); jclass (*GetSuperclass)(JNIEnv*, jclass); jboolean (*IsAssignableFrom)(JNIEnv*, jclass, jclass); jobject (*ToReflectedField)(JNIEnv*, jclass, jfieldID, jboolean); //与异常有关的方法 jint (*Throw)(JNIEnv*, jthrowable); jint (*ThrowNew)(JNIEnv *, jclass, const char *); jthrowable (*ExceptionOccurred)(JNIEnv*); void (*ExceptionDescribe)(JNIEnv*); void (*ExceptionClear)(JNIEnv*); void (*FatalError)(JNIEnv*, const char*); jint (*PushLocalFrame)(JNIEnv*, jint); jobject (*PopLocalFrame)(JNIEnv*, jobject); jobject (*NewGlobalRef)(JNIEnv*, jobject); void (*DeleteGlobalRef)(JNIEnv*, jobject); void (*DeleteLocalRef)(JNIEnv*, jobject); jboolean (*IsSameObject)(JNIEnv*, jobject, jobject); jobject (*NewLocalRef)(JNIEnv*, jobject); jint (*EnsureLocalCapacity)(JNIEnv*, jint); //新建object jobject (*AllocObject)(JNIEnv*, jclass); jobject (*NewObject)(JNIEnv*, jclass, jmethodID, ...); jobject (*NewObjectV)(JNIEnv*, jclass, jmethodID, va_list); jobject (*NewObjectA)(JNIEnv*, jclass, jmethodID, jvalue*); jclass (*GetObjectClass)(JNIEnv*, jobject); jboolean (*IsInstanceOf)(JNIEnv*, jobject, jclass); jmethodID (*GetMethodID)(JNIEnv*, jclass, const char*, const char*); //调用方法 jobject (*CallObjectMethod)(JNIEnv*, jobject, jmethodID, ...); jobject (*CallObjectMethodV)(JNIEnv*, jobject, jmethodID, va_list); jobject (*CallObjectMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jboolean (*CallBooleanMethod)(JNIEnv*, jobject, jmethodID, ...); jboolean (*CallBooleanMethodV)(JNIEnv*, jobject, jmethodID, va_list); jboolean (*CallBooleanMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jbyte (*CallByteMethod)(JNIEnv*, jobject, jmethodID, ...); jbyte (*CallByteMethodV)(JNIEnv*, jobject, jmethodID, va_list); jbyte (*CallByteMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jchar (*CallCharMethod)(JNIEnv*, jobject, jmethodID, ...); jchar (*CallCharMethodV)(JNIEnv*, jobject, jmethodID, va_list); jchar (*CallCharMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jshort (*CallShortMethod)(JNIEnv*, jobject, jmethodID, ...); jshort (*CallShortMethodV)(JNIEnv*, jobject, jmethodID, va_list); jshort (*CallShortMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jint (*CallIntMethod)(JNIEnv*, jobject, jmethodID, ...); jint (*CallIntMethodV)(JNIEnv*, jobject, jmethodID, va_list); jint (*CallIntMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jlong (*CallLongMethod)(JNIEnv*, jobject, jmethodID, ...); jlong (*CallLongMethodV)(JNIEnv*, jobject, jmethodID, va_list); jlong (*CallLongMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jfloat (*CallFloatMethod)(JNIEnv*, jobject, jmethodID, ...) __NDK_FPABI__; jfloat (*CallFloatMethodV)(JNIEnv*, jobject, jmethodID, va_list) __NDK_FPABI__; jfloat (*CallFloatMethodA)(JNIEnv*, jobject, jmethodID, jvalue*) __NDK_FPABI__; jdouble (*CallDoubleMethod)(JNIEnv*, jobject, jmethodID, ...) __NDK_FPABI__; jdouble (*CallDoubleMethodV)(JNIEnv*, jobject, jmethodID, va_list) __NDK_FPABI__; jdouble (*CallDoubleMethodA)(JNIEnv*, jobject, jmethodID, jvalue*) __NDK_FPABI__; void (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...); void (*CallVoidMethodV)(JNIEnv*, jobject, jmethodID, va_list); void (*CallVoidMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jobject (*CallNonvirtualObjectMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jobject (*CallNonvirtualObjectMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jobject (*CallNonvirtualObjectMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jboolean (*CallNonvirtualBooleanMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jbyte (*CallNonvirtualByteMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jbyte (*CallNonvirtualByteMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jbyte (*CallNonvirtualByteMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jchar (*CallNonvirtualCharMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jchar (*CallNonvirtualCharMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jchar (*CallNonvirtualCharMethodA)(JNIEnv*, jobject, jclass, jmethodID, jvalue*); jshort (*CallNonvirtualShortMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jshort (*CallNonvirtualShortMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jshort (*CallNonvirtualShortMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jint (*CallNonvirtualIntMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jint (*CallNonvirtualIntMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jint (*CallNonvirtualIntMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jlong (*CallNonvirtualLongMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jlong (*CallNonvirtualLongMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jlong (*CallNonvirtualLongMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jfloat (*CallNonvirtualFloatMethod)(JNIEnv*, jobject, jclass,jmethodID, ...) __NDK_FPABI__; jfloat (*CallNonvirtualFloatMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list) __NDK_FPABI__; jfloat (*CallNonvirtualFloatMethodA)(JNIEnv*, jobject, jclass, jmethodID, jvalue*) __NDK_FPABI__; jdouble (*CallNonvirtualDoubleMethod)(JNIEnv*, jobject, jclass,jmethodID, ...) __NDK_FPABI__; jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list) __NDK_FPABI__; jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*) __NDK_FPABI__; void (*CallNonvirtualVoidMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); void (*CallNonvirtualVoidMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); void (*CallNonvirtualVoidMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); //获取各种字段 jfieldID (*GetFieldID)(JNIEnv*, jclass, const char*, const char*); jobject (*GetObjectField)(JNIEnv*, jobject, jfieldID); jboolean (*GetBooleanField)(JNIEnv*, jobject, jfieldID); jbyte (*GetByteField)(JNIEnv*, jobject, jfieldID); jchar (*GetCharField)(JNIEnv*, jobject, jfieldID); jshort (*GetShortField)(JNIEnv*, jobject, jfieldID); jint (*GetIntField)(JNIEnv*, jobject, jfieldID); jlong (*GetLongField)(JNIEnv*, jobject, jfieldID); jfloat (*GetFloatField)(JNIEnv*, jobject, jfieldID) __NDK_FPABI__; jdouble (*GetDoubleField)(JNIEnv*, jobject, jfieldID) __NDK_FPABI__; //设置各种字段，返回为空 void (*SetObjectField)(JNIEnv*, jobject, jfieldID, jobject); void (*SetBooleanField)(JNIEnv*, jobject, jfieldID, jboolean); void (*SetByteField)(JNIEnv*, jobject, jfieldID, jbyte); void (*SetCharField)(JNIEnv*, jobject, jfieldID, jchar); void (*SetShortField)(JNIEnv*, jobject, jfieldID, jshort); void (*SetIntField)(JNIEnv*, jobject, jfieldID, jint); void (*SetLongField)(JNIEnv*, jobject, jfieldID, jlong); void (*SetFloatField)(JNIEnv*, jobject, jfieldID, jfloat) __NDK_FPABI__; void (*SetDoubleField)(JNIEnv*, jobject, jfieldID, jdouble) __NDK_FPABI__; jmethodID (*GetStaticMethodID)(JNIEnv*, jclass, const char*, const char*); jobject (*CallStaticObjectMethod)(JNIEnv*, jclass, jmethodID, ...); jobject (*CallStaticObjectMethodV)(JNIEnv*, jclass, jmethodID, va_list); jobject (*CallStaticObjectMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jboolean (*CallStaticBooleanMethod)(JNIEnv*, jclass, jmethodID, ...); jboolean (*CallStaticBooleanMethodV)(JNIEnv*, jclass, jmethodID,va_list); jboolean (*CallStaticBooleanMethodA)(JNIEnv*, jclass, jmethodID,jvalue*); jbyte (*CallStaticByteMethod)(JNIEnv*, jclass, jmethodID, ...); jbyte (*CallStaticByteMethodV)(JNIEnv*, jclass, jmethodID, va_list); jbyte (*CallStaticByteMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jchar (*CallStaticCharMethod)(JNIEnv*, jclass, jmethodID, ...); jchar (*CallStaticCharMethodV)(JNIEnv*, jclass, jmethodID, va_list); jchar (*CallStaticCharMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jshort (*CallStaticShortMethod)(JNIEnv*, jclass, jmethodID, ...); jshort (*CallStaticShortMethodV)(JNIEnv*, jclass, jmethodID, va_list); jshort (*CallStaticShortMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jint (*CallStaticIntMethod)(JNIEnv*, jclass, jmethodID, ...); jint (*CallStaticIntMethodV)(JNIEnv*, jclass, jmethodID, va_list); jint (*CallStaticIntMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jlong (*CallStaticLongMethod)(JNIEnv*, jclass, jmethodID, ...); jlong (*CallStaticLongMethodV)(JNIEnv*, jclass, jmethodID, va_list); jlong (*CallStaticLongMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jfloat (*CallStaticFloatMethod)(JNIEnv*, jclass, jmethodID, ...) __NDK_FPABI__; jfloat (*CallStaticFloatMethodV)(JNIEnv*, jclass, jmethodID, va_list) __NDK_FPABI__; jfloat (*CallStaticFloatMethodA)(JNIEnv*, jclass, jmethodID, jvalue*) __NDK_FPABI__; jdouble (*CallStaticDoubleMethod)(JNIEnv*, jclass, jmethodID, ...) __NDK_FPABI__; jdouble (*CallStaticDoubleMethodV)(JNIEnv*, jclass, jmethodID, va_list) __NDK_FPABI__; jdouble (*CallStaticDoubleMethodA)(JNIEnv*, jclass, jmethodID, jvalue*) __NDK_FPABI__; void (*CallStaticVoidMethod)(JNIEnv*, jclass, jmethodID, ...); void (*CallStaticVoidMethodV)(JNIEnv*, jclass, jmethodID, va_list); void (*CallStaticVoidMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jfieldID (*GetStaticFieldID)(JNIEnv*, jclass, const char*,const char*); jobject (*GetStaticObjectField)(JNIEnv*, jclass, jfieldID); jboolean (*GetStaticBooleanField)(JNIEnv*, jclass, jfieldID); jbyte (*GetStaticByteField)(JNIEnv*, jclass, jfieldID); jchar (*GetStaticCharField)(JNIEnv*, jclass, jfieldID); jshort (*GetStaticShortField)(JNIEnv*, jclass, jfieldID); jint (*GetStaticIntField)(JNIEnv*, jclass, jfieldID); jlong (*GetStaticLongField)(JNIEnv*, jclass, jfieldID); jfloat (*GetStaticFloatField)(JNIEnv*, jclass, jfieldID) __NDK_FPABI__; jdouble (*GetStaticDoubleField)(JNIEnv*, jclass, jfieldID) __NDK_FPABI__; void (*SetStaticObjectField)(JNIEnv*, jclass, jfieldID, jobject); void (*SetStaticBooleanField)(JNIEnv*, jclass, jfieldID, jboolean); void (*SetStaticByteField)(JNIEnv*, jclass, jfieldID, jbyte); void (*SetStaticCharField)(JNIEnv*, jclass, jfieldID, jchar); void (*SetStaticShortField)(JNIEnv*, jclass, jfieldID, jshort); void (*SetStaticIntField)(JNIEnv*, jclass, jfieldID, jint); void (*SetStaticLongField)(JNIEnv*, jclass, jfieldID, jlong); void (*SetStaticFloatField)(JNIEnv*, jclass, jfieldID, jfloat) __NDK_FPABI__; void (*SetStaticDoubleField)(JNIEnv*, jclass, jfieldID, jdouble) __NDK_FPABI__; jstring (*NewString)(JNIEnv*, const jchar*, jsize); jsize (*GetStringLength)(JNIEnv*, jstring); const jchar*(*GetStringChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringChars)(JNIEnv*, jstring, const jchar*); jstring (*NewStringUTF)(JNIEnv*, const char*); jsize (*GetStringUTFLength)(JNIEnv*, jstring); const char* (*GetStringUTFChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringUTFChars)(JNIEnv*, jstring, const char*); jsize (*GetArrayLength)(JNIEnv*, jarray); jobjectArray(*NewObjectArray)(JNIEnv*, jsize, jclass, jobject); jobject (*GetObjectArrayElement)(JNIEnv*, jobjectArray, jsize); void (*SetObjectArrayElement)(JNIEnv*, jobjectArray, jsize, jobject); jbooleanArray (*NewBooleanArray)(JNIEnv*, jsize); jbyteArray (*NewByteArray)(JNIEnv*, jsize); jcharArray (*NewCharArray)(JNIEnv*, jsize); jshortArray (*NewShortArray)(JNIEnv*, jsize); jintArray (*NewIntArray)(JNIEnv*, jsize); jlongArray (*NewLongArray)(JNIEnv*, jsize); jfloatArray (*NewFloatArray)(JNIEnv*, jsize); jdoubleArray (*NewDoubleArray)(JNIEnv*, jsize); jboolean* (*GetBooleanArrayElements)(JNIEnv*, jbooleanArray, jboolean*); jbyte* (*GetByteArrayElements)(JNIEnv*, jbyteArray, jboolean*); jchar* (*GetCharArrayElements)(JNIEnv*, jcharArray, jboolean*); jshort* (*GetShortArrayElements)(JNIEnv*, jshortArray, jboolean*); jint* (*GetIntArrayElements)(JNIEnv*, jintArray, jboolean*); jlong* (*GetLongArrayElements)(JNIEnv*, jlongArray, jboolean*); jfloat* (*GetFloatArrayElements)(JNIEnv*, jfloatArray, jboolean*); jdouble* (*GetDoubleArrayElements)(JNIEnv*, jdoubleArray, jboolean*); void (*ReleaseBooleanArrayElements)(JNIEnv*, jbooleanArray,jboolean*, jint); void (*ReleaseByteArrayElements)(JNIEnv*, jbyteArray,jbyte*, jint); void (*ReleaseCharArrayElements)(JNIEnv*, jcharArray,jchar*, jint); void (*ReleaseShortArrayElements)(JNIEnv*, jshortArray,jshort*, jint); void (*ReleaseIntArrayElements)(JNIEnv*, jintArray,jint*, jint); void (*ReleaseLongArrayElements)(JNIEnv*, jlongArray,jlong*, jint); void (*ReleaseFloatArrayElements)(JNIEnv*, jfloatArray,jfloat*, jint); void (*ReleaseDoubleArrayElements)(JNIEnv*, jdoubleArray,jdouble*, jint); void (*GetBooleanArrayRegion)(JNIEnv*, jbooleanArray,jsize,jsize, jboolean*); void (*GetByteArrayRegion)(JNIEnv*, jbyteArray,jsize, jsize,jbyte*); void (*GetCharArrayRegion)(JNIEnv*, jcharArray, jsize, jsize,jchar*); void (*GetShortArrayRegion)(JNIEnv*, jshortArray,jsize, jsize,jshort*); void (*GetIntArrayRegion)(JNIEnv*, jintArray,jsize, jsize, jint*); void (*GetLongArrayRegion)(JNIEnv*, jlongArray,jsize, jsize, jlong*); void (*GetFloatArrayRegion)(JNIEnv*, jfloatArray,jsize, jsize, jfloat*); void (*GetDoubleArrayRegion)(JNIEnv*, jdoubleArray,jsize, jsize, jdouble*); void (*SetBooleanArrayRegion)(JNIEnv*, jbooleanArray,jsize, jsize, const jboolean*); void (*SetByteArrayRegion)(JNIEnv*, jbyteArray,jsize, jsize, const jbyte*); void (*SetCharArrayRegion)(JNIEnv*, jcharArray,jsize, jsize, const jchar*); void (*SetShortArrayRegion)(JNIEnv*, jshortArray,jsize, jsize, const jshort*); void (*SetIntArrayRegion)(JNIEnv*, jintArray,jsize, jsize, const jint*); void (*SetLongArrayRegion)(JNIEnv*, jlongArray, jsize, jsize, const jlong*); void (*SetFloatArrayRegion)(JNIEnv*, jfloatArray, jsize, jsize, const jfloat*); void (*SetDoubleArrayRegion)(JNIEnv*, jdoubleArray,jsize, jsize, const jdouble*); jint (*RegisterNatives)(JNIEnv*, jclass, const JNINativeMethod*,jint); jint (*UnregisterNatives)(JNIEnv*, jclass); jint (*MonitorEnter)(JNIEnv*, jobject); jint (*MonitorExit)(JNIEnv*, jobject); jint (*GetJavaVM)(JNIEnv*, JavaVM**); void (*GetStringRegion)(JNIEnv*, jstring, jsize, jsize, jchar*); void (*GetStringUTFRegion)(JNIEnv*, jstring, jsize, jsize, char*); void* (*GetPrimitiveArrayCritical)(JNIEnv*, jarray, jboolean*); void (*ReleasePrimitiveArrayCritical)(JNIEnv*, jarray, void*, jint); const jchar*(*GetStringCritical)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringCritical)(JNIEnv*, jstring, const jchar*); jweak (*NewWeakGlobalRef)(JNIEnv*, jobject); void (*DeleteWeakGlobalRef)(JNIEnv*, jweak); jboolean (*ExceptionCheck)(JNIEnv*); jobject (*NewDirectByteBuffer)(JNIEnv*, void*, jlong); void* (*GetDirectBufferAddress)(JNIEnv*, jobject); jlong (*GetDirectBufferCapacity)(JNIEnv*, jobject); jobjectRefType (*GetObjectRefType)(JNIEnv*, jobject);};/* * C++ */ //C++的JNI 本地接口结构体的调用struct _JNIEnv { const struct JNINativeInterface* functions;#if defined(__cplusplus) //各种函数 jint GetVersion() { return functions-&gt;GetVersion(this); } jclass DefineClass(const char *name, jobject loader, const jbyte* buf, jsize bufLen) { return functions-&gt;DefineClass(this, name, loader, buf, bufLen); } jclass FindClass(const char* name) { return functions-&gt;FindClass(this, name); } jmethodID FromReflectedMethod(jobject method) { return functions-&gt;FromReflectedMethod(this, method); } jfieldID FromReflectedField(jobject field) { return functions-&gt;FromReflectedField(this, field); } jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic) { return functions-&gt;ToReflectedMethod(this, cls, methodID, isStatic); } jclass GetSuperclass(jclass clazz) { return functions-&gt;GetSuperclass(this, clazz); } jboolean IsAssignableFrom(jclass clazz1, jclass clazz2) { return functions-&gt;IsAssignableFrom(this, clazz1, clazz2); } jobject ToReflectedField(jclass cls, jfieldID fieldID, jboolean isStatic) { return functions-&gt;ToReflectedField(this, cls, fieldID, isStatic); } jint Throw(jthrowable obj) { return functions-&gt;Throw(this, obj); } jint ThrowNew(jclass clazz, const char* message) { return functions-&gt;ThrowNew(this, clazz, message); } jthrowable ExceptionOccurred() { return functions-&gt;ExceptionOccurred(this); } void ExceptionDescribe() { functions-&gt;ExceptionDescribe(this); } void ExceptionClear() { functions-&gt;ExceptionClear(this); } void FatalError(const char* msg) { functions-&gt;FatalError(this, msg); } jint PushLocalFrame(jint capacity) { return functions-&gt;PushLocalFrame(this, capacity); } jobject PopLocalFrame(jobject result) { return functions-&gt;PopLocalFrame(this, result); } jobject NewGlobalRef(jobject obj) { return functions-&gt;NewGlobalRef(this, obj); } void DeleteGlobalRef(jobject globalRef) { functions-&gt;DeleteGlobalRef(this, globalRef); } void DeleteLocalRef(jobject localRef) { functions-&gt;DeleteLocalRef(this, localRef); } jboolean IsSameObject(jobject ref1, jobject ref2) { return functions-&gt;IsSameObject(this, ref1, ref2); } jobject NewLocalRef(jobject ref) { return functions-&gt;NewLocalRef(this, ref); } jint EnsureLocalCapacity(jint capacity) { return functions-&gt;EnsureLocalCapacity(this, capacity); } jobject AllocObject(jclass clazz) { return functions-&gt;AllocObject(this, clazz); } jobject NewObject(jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); jobject result = functions-&gt;NewObjectV(this, clazz, methodID, args); va_end(args); return result; } jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args) { return functions-&gt;NewObjectV(this, clazz, methodID, args); } jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args) { return functions-&gt;NewObjectA(this, clazz, methodID, args); } jclass GetObjectClass(jobject obj) { return functions-&gt;GetObjectClass(this, obj); } jboolean IsInstanceOf(jobject obj, jclass clazz) { return functions-&gt;IsInstanceOf(this, obj, clazz); } jmethodID GetMethodID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetMethodID(this, clazz, name, sig); }#define CALL_TYPE_METHOD(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype Call##_jname##Method(jobject obj, jmethodID methodID, ...) \\ { \\ _jtype result; \\ va_list args; \\ va_start(args, methodID); \\ result = functions-&gt;Call##_jname##MethodV(this, obj, methodID, \\ args); \\ va_end(args); \\ return result; \\ }#define CALL_TYPE_METHODV(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype Call##_jname##MethodV(jobject obj, jmethodID methodID, \\ va_list args) \\ { return functions-&gt;Call##_jname##MethodV(this, obj, methodID, args); }#define CALL_TYPE_METHODA(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype Call##_jname##MethodA(jobject obj, jmethodID methodID, \\ jvalue* args) \\ { return functions-&gt;Call##_jname##MethodA(this, obj, methodID, args); }#define CALL_TYPE(_jtype, _jname) \\ CALL_TYPE_METHOD(_jtype, _jname) \\ CALL_TYPE_METHODV(_jtype, _jname) \\ CALL_TYPE_METHODA(_jtype, _jname) CALL_TYPE(jobject, Object) CALL_TYPE(jboolean, Boolean) CALL_TYPE(jbyte, Byte) CALL_TYPE(jchar, Char) CALL_TYPE(jshort, Short) CALL_TYPE(jint, Int) CALL_TYPE(jlong, Long) CALL_TYPE(jfloat, Float) CALL_TYPE(jdouble, Double) void CallVoidMethod(jobject obj, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-&gt;CallVoidMethodV(this, obj, methodID, args); va_end(args); } void CallVoidMethodV(jobject obj, jmethodID methodID, va_list args) { functions-&gt;CallVoidMethodV(this, obj, methodID, args); } void CallVoidMethodA(jobject obj, jmethodID methodID, jvalue* args) { functions-&gt;CallVoidMethodA(this, obj, methodID, args); }#define CALL_NONVIRT_TYPE_METHOD(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallNonvirtual##_jname##Method(jobject obj, jclass clazz, \\ jmethodID methodID, ...) \\ { \\ _jtype result; \\ va_list args; \\ va_start(args, methodID); \\ result = functions-&gt;CallNonvirtual##_jname##MethodV(this, obj, \\ clazz, methodID, args); \\ va_end(args); \\ return result; \\ }#define CALL_NONVIRT_TYPE_METHODV(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallNonvirtual##_jname##MethodV(jobject obj, jclass clazz, \\ jmethodID methodID, va_list args) \\ { return functions-&gt;CallNonvirtual##_jname##MethodV(this, obj, clazz, \\ methodID, args); }#define CALL_NONVIRT_TYPE_METHODA(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallNonvirtual##_jname##MethodA(jobject obj, jclass clazz, \\ jmethodID methodID, jvalue* args) \\ { return functions-&gt;CallNonvirtual##_jname##MethodA(this, obj, clazz, \\ methodID, args); }#define CALL_NONVIRT_TYPE(_jtype, _jname) \\ CALL_NONVIRT_TYPE_METHOD(_jtype, _jname) \\ CALL_NONVIRT_TYPE_METHODV(_jtype, _jname) \\ CALL_NONVIRT_TYPE_METHODA(_jtype, _jname) CALL_NONVIRT_TYPE(jobject, Object) CALL_NONVIRT_TYPE(jboolean, Boolean) CALL_NONVIRT_TYPE(jbyte, Byte) CALL_NONVIRT_TYPE(jchar, Char) CALL_NONVIRT_TYPE(jshort, Short) CALL_NONVIRT_TYPE(jint, Int) CALL_NONVIRT_TYPE(jlong, Long) CALL_NONVIRT_TYPE(jfloat, Float) CALL_NONVIRT_TYPE(jdouble, Double) void CallNonvirtualVoidMethod(jobject obj, jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-&gt;CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args); va_end(args); } void CallNonvirtualVoidMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) { functions-&gt;CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args); } void CallNonvirtualVoidMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue* args) { functions-&gt;CallNonvirtualVoidMethodA(this, obj, clazz, methodID, args); } jfieldID GetFieldID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetFieldID(this, clazz, name, sig); } jobject GetObjectField(jobject obj, jfieldID fieldID) { return functions-&gt;GetObjectField(this, obj, fieldID); } jboolean GetBooleanField(jobject obj, jfieldID fieldID) { return functions-&gt;GetBooleanField(this, obj, fieldID); } jbyte GetByteField(jobject obj, jfieldID fieldID) { return functions-&gt;GetByteField(this, obj, fieldID); } jchar GetCharField(jobject obj, jfieldID fieldID) { return functions-&gt;GetCharField(this, obj, fieldID); } jshort GetShortField(jobject obj, jfieldID fieldID) { return functions-&gt;GetShortField(this, obj, fieldID); } jint GetIntField(jobject obj, jfieldID fieldID) { return functions-&gt;GetIntField(this, obj, fieldID); } jlong GetLongField(jobject obj, jfieldID fieldID) { return functions-&gt;GetLongField(this, obj, fieldID); } __NDK_FPABI__ jfloat GetFloatField(jobject obj, jfieldID fieldID) { return functions-&gt;GetFloatField(this, obj, fieldID); } __NDK_FPABI__ jdouble GetDoubleField(jobject obj, jfieldID fieldID) { return functions-&gt;GetDoubleField(this, obj, fieldID); } void SetObjectField(jobject obj, jfieldID fieldID, jobject value) { functions-&gt;SetObjectField(this, obj, fieldID, value); } void SetBooleanField(jobject obj, jfieldID fieldID, jboolean value) { functions-&gt;SetBooleanField(this, obj, fieldID, value); } void SetByteField(jobject obj, jfieldID fieldID, jbyte value) { functions-&gt;SetByteField(this, obj, fieldID, value); } void SetCharField(jobject obj, jfieldID fieldID, jchar value) { functions-&gt;SetCharField(this, obj, fieldID, value); } void SetShortField(jobject obj, jfieldID fieldID, jshort value) { functions-&gt;SetShortField(this, obj, fieldID, value); } void SetIntField(jobject obj, jfieldID fieldID, jint value) { functions-&gt;SetIntField(this, obj, fieldID, value); } void SetLongField(jobject obj, jfieldID fieldID, jlong value) { functions-&gt;SetLongField(this, obj, fieldID, value); } __NDK_FPABI__ void SetFloatField(jobject obj, jfieldID fieldID, jfloat value) { functions-&gt;SetFloatField(this, obj, fieldID, value); } __NDK_FPABI__ void SetDoubleField(jobject obj, jfieldID fieldID, jdouble value) { functions-&gt;SetDoubleField(this, obj, fieldID, value); } jmethodID GetStaticMethodID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetStaticMethodID(this, clazz, name, sig); }#define CALL_STATIC_TYPE_METHOD(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallStatic##_jname##Method(jclass clazz, jmethodID methodID, \\ ...) \\ { \\ _jtype result; \\ va_list args; \\ va_start(args, methodID); \\ result = functions-&gt;CallStatic##_jname##MethodV(this, clazz, \\ methodID, args); \\ va_end(args); \\ return result; \\ }#define CALL_STATIC_TYPE_METHODV(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallStatic##_jname##MethodV(jclass clazz, jmethodID methodID, \\ va_list args) \\ { return functions-&gt;CallStatic##_jname##MethodV(this, clazz, methodID, \\ args); }#define CALL_STATIC_TYPE_METHODA(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallStatic##_jname##MethodA(jclass clazz, jmethodID methodID, \\ jvalue* args) \\ { return functions-&gt;CallStatic##_jname##MethodA(this, clazz, methodID, \\ args); }#define CALL_STATIC_TYPE(_jtype, _jname) \\ CALL_STATIC_TYPE_METHOD(_jtype, _jname) \\ CALL_STATIC_TYPE_METHODV(_jtype, _jname) \\ CALL_STATIC_TYPE_METHODA(_jtype, _jname) CALL_STATIC_TYPE(jobject, Object) CALL_STATIC_TYPE(jboolean, Boolean) CALL_STATIC_TYPE(jbyte, Byte) CALL_STATIC_TYPE(jchar, Char) CALL_STATIC_TYPE(jshort, Short) CALL_STATIC_TYPE(jint, Int) CALL_STATIC_TYPE(jlong, Long) CALL_STATIC_TYPE(jfloat, Float) CALL_STATIC_TYPE(jdouble, Double) void CallStaticVoidMethod(jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-&gt;CallStaticVoidMethodV(this, clazz, methodID, args); va_end(args); } void CallStaticVoidMethodV(jclass clazz, jmethodID methodID, va_list args) { functions-&gt;CallStaticVoidMethodV(this, clazz, methodID, args); } void CallStaticVoidMethodA(jclass clazz, jmethodID methodID, jvalue* args) { functions-&gt;CallStaticVoidMethodA(this, clazz, methodID, args); } jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetStaticFieldID(this, clazz, name, sig); } jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticObjectField(this, clazz, fieldID); } jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticBooleanField(this, clazz, fieldID); } jbyte GetStaticByteField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticByteField(this, clazz, fieldID); } jchar GetStaticCharField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticCharField(this, clazz, fieldID); } jshort GetStaticShortField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticShortField(this, clazz, fieldID); } jint GetStaticIntField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticIntField(this, clazz, fieldID); } jlong GetStaticLongField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticLongField(this, clazz, fieldID); } __NDK_FPABI__ jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticFloatField(this, clazz, fieldID); } __NDK_FPABI__ jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticDoubleField(this, clazz, fieldID); } void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value) { functions-&gt;SetStaticObjectField(this, clazz, fieldID, value); } void SetStaticBooleanField(jclass clazz, jfieldID fieldID, jboolean value) { functions-&gt;SetStaticBooleanField(this, clazz, fieldID, value); } void SetStaticByteField(jclass clazz, jfieldID fieldID, jbyte value) { functions-&gt;SetStaticByteField(this, clazz, fieldID, value); } void SetStaticCharField(jclass clazz, jfieldID fieldID, jchar value) { functions-&gt;SetStaticCharField(this, clazz, fieldID, value); } void SetStaticShortField(jclass clazz, jfieldID fieldID, jshort value) { functions-&gt;SetStaticShortField(this, clazz, fieldID, value); } void SetStaticIntField(jclass clazz, jfieldID fieldID, jint value) { functions-&gt;SetStaticIntField(this, clazz, fieldID, value); } void SetStaticLongField(jclass clazz, jfieldID fieldID, jlong value) { functions-&gt;SetStaticLongField(this, clazz, fieldID, value); } __NDK_FPABI__ void SetStaticFloatField(jclass clazz, jfieldID fieldID, jfloat value) { functions-&gt;SetStaticFloatField(this, clazz, fieldID, value); } __NDK_FPABI__ void SetStaticDoubleField(jclass clazz, jfieldID fieldID, jdouble value) { functions-&gt;SetStaticDoubleField(this, clazz, fieldID, value); } jstring NewString(const jchar* unicodeChars, jsize len) { return functions-&gt;NewString(this, unicodeChars, len); } jsize GetStringLength(jstring string) { return functions-&gt;GetStringLength(this, string); } const jchar* GetStringChars(jstring string, jboolean* isCopy) { return functions-&gt;GetStringChars(this, string, isCopy); } void ReleaseStringChars(jstring string, const jchar* chars) { functions-&gt;ReleaseStringChars(this, string, chars); } jstring NewStringUTF(const char* bytes) { return functions-&gt;NewStringUTF(this, bytes); } jsize GetStringUTFLength(jstring string) { return functions-&gt;GetStringUTFLength(this, string); } const char* GetStringUTFChars(jstring string, jboolean* isCopy) { return functions-&gt;GetStringUTFChars(this, string, isCopy); } void ReleaseStringUTFChars(jstring string, const char* utf) { functions-&gt;ReleaseStringUTFChars(this, string, utf); } jsize GetArrayLength(jarray array) { return functions-&gt;GetArrayLength(this, array); } jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement) { return functions-&gt;NewObjectArray(this, length, elementClass, initialElement); } jobject GetObjectArrayElement(jobjectArray array, jsize index) { return functions-&gt;GetObjectArrayElement(this, array, index); } void SetObjectArrayElement(jobjectArray array, jsize index, jobject value) { functions-&gt;SetObjectArrayElement(this, array, index, value); } jbooleanArray NewBooleanArray(jsize length) { return functions-&gt;NewBooleanArray(this, length); } jbyteArray NewByteArray(jsize length) { return functions-&gt;NewByteArray(this, length); } jcharArray NewCharArray(jsize length) { return functions-&gt;NewCharArray(this, length); } jshortArray NewShortArray(jsize length) { return functions-&gt;NewShortArray(this, length); } jintArray NewIntArray(jsize length) { return functions-&gt;NewIntArray(this, length); } jlongArray NewLongArray(jsize length) { return functions-&gt;NewLongArray(this, length); } jfloatArray NewFloatArray(jsize length) { return functions-&gt;NewFloatArray(this, length); } jdoubleArray NewDoubleArray(jsize length) { return functions-&gt;NewDoubleArray(this, length); } jboolean* GetBooleanArrayElements(jbooleanArray array, jboolean* isCopy) { return functions-&gt;GetBooleanArrayElements(this, array, isCopy); } jbyte* GetByteArrayElements(jbyteArray array, jboolean* isCopy) { return functions-&gt;GetByteArrayElements(this, array, isCopy); } jchar* GetCharArrayElements(jcharArray array, jboolean* isCopy) { return functions-&gt;GetCharArrayElements(this, array, isCopy); } jshort* GetShortArrayElements(jshortArray array, jboolean* isCopy) { return functions-&gt;GetShortArrayElements(this, array, isCopy); } jint* GetIntArrayElements(jintArray array, jboolean* isCopy) { return functions-&gt;GetIntArrayElements(this, array, isCopy); } jlong* GetLongArrayElements(jlongArray array, jboolean* isCopy) { return functions-&gt;GetLongArrayElements(this, array, isCopy); } jfloat* GetFloatArrayElements(jfloatArray array, jboolean* isCopy) { return functions-&gt;GetFloatArrayElements(this, array, isCopy); } jdouble* GetDoubleArrayElements(jdoubleArray array, jboolean* isCopy) { return functions-&gt;GetDoubleArrayElements(this, array, isCopy); } void ReleaseBooleanArrayElements(jbooleanArray array, jboolean* elems, jint mode) { functions-&gt;ReleaseBooleanArrayElements(this, array, elems, mode); } void ReleaseByteArrayElements(jbyteArray array, jbyte* elems, jint mode) { functions-&gt;ReleaseByteArrayElements(this, array, elems, mode); } void ReleaseCharArrayElements(jcharArray array, jchar* elems, jint mode) { functions-&gt;ReleaseCharArrayElements(this, array, elems, mode); } void ReleaseShortArrayElements(jshortArray array, jshort* elems, jint mode) { functions-&gt;ReleaseShortArrayElements(this, array, elems, mode); } void ReleaseIntArrayElements(jintArray array, jint* elems, jint mode) { functions-&gt;ReleaseIntArrayElements(this, array, elems, mode); } void ReleaseLongArrayElements(jlongArray array, jlong* elems, jint mode) { functions-&gt;ReleaseLongArrayElements(this, array, elems, mode); } void ReleaseFloatArrayElements(jfloatArray array, jfloat* elems, jint mode) { functions-&gt;ReleaseFloatArrayElements(this, array, elems, mode); } void ReleaseDoubleArrayElements(jdoubleArray array, jdouble* elems, jint mode) { functions-&gt;ReleaseDoubleArrayElements(this, array, elems, mode); } void GetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, jboolean* buf) { functions-&gt;GetBooleanArrayRegion(this, array, start, len, buf); } void GetByteArrayRegion(jbyteArray array, jsize start, jsize len, jbyte* buf) { functions-&gt;GetByteArrayRegion(this, array, start, len, buf); } void GetCharArrayRegion(jcharArray array, jsize start, jsize len, jchar* buf) { functions-&gt;GetCharArrayRegion(this, array, start, len, buf); } void GetShortArrayRegion(jshortArray array, jsize start, jsize len, jshort* buf) { functions-&gt;GetShortArrayRegion(this, array, start, len, buf); } void GetIntArrayRegion(jintArray array, jsize start, jsize len, jint* buf) { functions-&gt;GetIntArrayRegion(this, array, start, len, buf); } void GetLongArrayRegion(jlongArray array, jsize start, jsize len, jlong* buf) { functions-&gt;GetLongArrayRegion(this, array, start, len, buf); } void GetFloatArrayRegion(jfloatArray array, jsize start, jsize len, jfloat* buf) { functions-&gt;GetFloatArrayRegion(this, array, start, len, buf); } void GetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, jdouble* buf) { functions-&gt;GetDoubleArrayRegion(this, array, start, len, buf); } void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, const jboolean* buf) { functions-&gt;SetBooleanArrayRegion(this, array, start, len, buf); } void SetByteArrayRegion(jbyteArray array, jsize start, jsize len, const jbyte* buf) { functions-&gt;SetByteArrayRegion(this, array, start, len, buf); } void SetCharArrayRegion(jcharArray array, jsize start, jsize len, const jchar* buf) { functions-&gt;SetCharArrayRegion(this, array, start, len, buf); } void SetShortArrayRegion(jshortArray array, jsize start, jsize len, const jshort* buf) { functions-&gt;SetShortArrayRegion(this, array, start, len, buf); } void SetIntArrayRegion(jintArray array, jsize start, jsize len, const jint* buf) { functions-&gt;SetIntArrayRegion(this, array, start, len, buf); } void SetLongArrayRegion(jlongArray array, jsize start, jsize len, const jlong* buf) { functions-&gt;SetLongArrayRegion(this, array, start, len, buf); } void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len, const jfloat* buf) { functions-&gt;SetFloatArrayRegion(this, array, start, len, buf); } void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, const jdouble* buf) { functions-&gt;SetDoubleArrayRegion(this, array, start, len, buf); } jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods) { return functions-&gt;RegisterNatives(this, clazz, methods, nMethods); } jint UnregisterNatives(jclass clazz) { return functions-&gt;UnregisterNatives(this, clazz); } jint MonitorEnter(jobject obj) { return functions-&gt;MonitorEnter(this, obj); } jint MonitorExit(jobject obj) { return functions-&gt;MonitorExit(this, obj); } jint GetJavaVM(JavaVM** vm) { return functions-&gt;GetJavaVM(this, vm); } void GetStringRegion(jstring str, jsize start, jsize len, jchar* buf) { functions-&gt;GetStringRegion(this, str, start, len, buf); } void GetStringUTFRegion(jstring str, jsize start, jsize len, char* buf) { return functions-&gt;GetStringUTFRegion(this, str, start, len, buf); } void* GetPrimitiveArrayCritical(jarray array, jboolean* isCopy) { return functions-&gt;GetPrimitiveArrayCritical(this, array, isCopy); } void ReleasePrimitiveArrayCritical(jarray array, void* carray, jint mode) { functions-&gt;ReleasePrimitiveArrayCritical(this, array, carray, mode); } const jchar* GetStringCritical(jstring string, jboolean* isCopy) { return functions-&gt;GetStringCritical(this, string, isCopy); } void ReleaseStringCritical(jstring string, const jchar* carray) { functions-&gt;ReleaseStringCritical(this, string, carray); } jweak NewWeakGlobalRef(jobject obj) { return functions-&gt;NewWeakGlobalRef(this, obj); } void DeleteWeakGlobalRef(jweak obj) { functions-&gt;DeleteWeakGlobalRef(this, obj); } jboolean ExceptionCheck() { return functions-&gt;ExceptionCheck(this); } jobject NewDirectByteBuffer(void* address, jlong capacity) { return functions-&gt;NewDirectByteBuffer(this, address, capacity); } void* GetDirectBufferAddress(jobject buf) { return functions-&gt;GetDirectBufferAddress(this, buf); } jlong GetDirectBufferCapacity(jobject buf) { return functions-&gt;GetDirectBufferCapacity(this, buf); } /* added in JNI 1.6 */ jobjectRefType GetObjectRefType(jobject obj) { return functions-&gt;GetObjectRefType(this, obj); }#endif /*__cplusplus*/};/* * JNI invocation interface. */ //调用接口结构体JNIInvokeInterface的定义struct JNIInvokeInterface { void* reserved0; void* reserved1; void* reserved2; jint (*DestroyJavaVM)(JavaVM*); jint (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*); jint (*DetachCurrentThread)(JavaVM*); jint (*GetEnv)(JavaVM*, void**, jint); jint (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);};/* * C++ version. */struct _JavaVM { const struct JNIInvokeInterface* functions;#if defined(__cplusplus) jint DestroyJavaVM() { return functions-&gt;DestroyJavaVM(this); } jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) { return functions-&gt;AttachCurrentThread(this, p_env, thr_args); } jint DetachCurrentThread() { return functions-&gt;DetachCurrentThread(this); } jint GetEnv(void** env, jint version) { return functions-&gt;GetEnv(this, env, version); } jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) { return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); }#endif /*__cplusplus*/};struct JavaVMAttachArgs { jint version; /* must be &gt;= JNI_VERSION_1_2 */ const char* name; /* NULL or name of thread as modified UTF-8 str */ jobject group; /* global ref of a ThreadGroup object, or NULL */};typedef struct JavaVMAttachArgs JavaVMAttachArgs;/* * JNI 1.2+ initialization. (As of 1.6, the pre-1.2 structures are no * longer supported.) */typedef struct JavaVMOption { const char* optionString; void* extraInfo;} JavaVMOption;typedef struct JavaVMInitArgs { jint version; /* use JNI_VERSION_1_2 or later */ jint nOptions; JavaVMOption* options; jboolean ignoreUnrecognized;} JavaVMInitArgs;#ifdef __cplusplusextern &quot;C&quot; {#endif/* * VM initialization functions. * * Note these are the only symbols exported for JNI by the VM. */#if 0 /* In practice, these are not exported by the NDK so don't declare them */jint JNI_GetDefaultJavaVMInitArgs(void*);jint JNI_CreateJavaVM(JavaVM**, JNIEnv**, void*);jint JNI_GetCreatedJavaVMs(JavaVM**, jsize, jsize*);#endif#define JNIIMPORT#define JNIEXPORT __attribute__ ((visibility (&quot;default&quot;)))#define JNICALL __NDK_FPABI__/* * Prototypes for functions exported by loadable shared libs. These are * called by JNI, not provided by JNI. */JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);#ifdef __cplusplus}#endif/* * Manifest constants. */#define JNI_FALSE 0#define JNI_TRUE 1#define JNI_VERSION_1_1 0x00010001#define JNI_VERSION_1_2 0x00010002#define JNI_VERSION_1_4 0x00010004#define JNI_VERSION_1_6 0x00010006#define JNI_OK (0) /* no error */#define JNI_ERR (-1) /* generic error */#define JNI_EDETACHED (-2) /* thread detached from the VM */#define JNI_EVERSION (-3) /* JNI version error */#define JNI_COMMIT 1 /* copy content, do not free buffer */#define JNI_ABORT 2 /* free buffer w/o copying back */#endif /* JNI_H_ */","link":"/20211201/JNI%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"安卓逆向","slug":"安卓逆向","link":"/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"Unidbg","slug":"Unidbg","link":"/tags/Unidbg/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"xpath","slug":"xpath","link":"/tags/xpath/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"安卓逆向","slug":"安卓逆向","link":"/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"Unidbg","slug":"Unidbg","link":"/categories/Unidbg/"},{"name":"自动化","slug":"自动化","link":"/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"爬虫","slug":"爬虫","link":"/categories/%E7%88%AC%E8%99%AB/"}]}