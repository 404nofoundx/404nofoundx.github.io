{"pages":[],"posts":[{"title":"20211209|每日算法—最接近的三数之和","text":"疾风知劲草，板荡识诚臣。勇夫安识义，智者必怀仁。 0x001、最接近的三数之和地址：https://leetcode-cn.com/problems/3sum-closest/ 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 实例一123输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 方法一、排序+双指针 1234567891011121314151617181920212223242526272829303132class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: nums.sort() flag = float(&quot;inf&quot;) lenght = len(nums) for i in range(lenght): if i&gt;0 and nums[i]==nums[i-1]: continue left,right = i+1,lenght-1 while left&lt;right: curr = nums[i]+nums[left]+nums[right] if curr==target: return curr elif curr&lt;target: flag = self.update_flag(flag=flag,curr=curr,target=target) # 解决重复 while left&lt;right and nums[left]==nums[left+1]: left+=1 left+=1 else: flag = self.update_flag(flag=flag,curr=curr,target=target) # 解决重复 while left&lt;right and nums[right]==nums[right-1]: right-=1 right-=1 return flag def update_flag(self,flag,curr,target): if abs(curr-target)&lt;abs(flag-target): return curr return flag 12console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20211109/20211209%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"},{"title":"20211208|每日算法—两数之和","text":"咬定青山不放松，立根原在破岩中。千磨万击还坚劲，任尔东西南北风。 0x001、两数之和地址：https://leetcode-cn.com/problems/two-sum/ 方法一、暴力循环 1234567class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: for i in range(len(nums)): for j in range(i+1,len(nums)): if nums[i]+nums[j]==target: return [i,j] return [] 方法二、哈希表 123456789class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: item = {} for i in range(len(nums)): if target-nums[i] in item: return [item[target-nums[i]],i] else: item[nums[i]] = i return [] 0x002、盛最多水的容器地址：https://leetcode-cn.com/problems/container-with-most-water/ 木桶能装多少水取决于最短的木板。 方法一、双指针 左右指针，每次移动比较矮的一侧。 123456789101112class Solution: def maxArea(self, height: List[int]) -&gt; int: left,right = 0,len(height)-1 max_area = 0 while left&lt;right: area = (right-left)*(min(height[right],height[left])) max_area = max(max_area,area) if height[left]&gt;=height[right]: right-=1 else: left+=1 return max_area 0x003、三数之和地址：https://leetcode-cn.com/problems/3sum/方法一、排序+双指针 长度小于3返回空列表 排序 取锚点元素，如果锚点元素大于0，代表后面没有三数和为零的元素，直接break，毕竟排过序 取锚点元素后一个为左指针left，最后一个为右指针right 循环 left&lt;right 三数和大于零，右边距向左移动一位 三数和小于零，左边距向右移动一位 三数和等于零，添加到result 判断左右边距是否重合，left是否等于left+1 left+=1 判断左右边距是否重合，right是否等于right-1 right-=1 收缩左右边距 12345678910111213141516171819202122232425262728class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: lenght = len(nums) result = list() if lenght&lt;3: return result nums.sort() for i in range(lenght): if nums[i]&gt;0: break if i&gt;0 and nums[i]==nums[i-1]: continue left,right = i+1,lenght-1 while left&lt;right: flag = nums[i] + nums[left] + nums[right] if flag&gt;0: right-=1 elif flag&lt;0: left+=1 else: result.append([nums[i],nums[left],nums[right]]) while left&lt;right and nums[left]==nums[left+1]: left+=1 while left&lt;right and nums[right]==nums[right-1]: right-=1 right-=1 left+=1 return result 12console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20211108/20211208%E6%AF%8F%E6%97%A5%E7%AE%97%E6%B3%95/"},{"title":"ARM指令集","text":"1 、LDR 和 STR加载/存储字和无符号字节指令，使用单一数据传送指令(STR 和 LDR)来装载和存储，单一字节或字的数据从/到内存LDR指令用于从内存中读取数据放入寄存器中，STR指令用于将寄存器中的数据保存到内存。 指令格式如下： 1234567LDR{cond}{T} Rd,&lt;地址&gt; ;加载指定地址上的数据(字),放入 Rd 中 STR{cond}{T} Rd,&lt;地址&gt; ;存储数据(字)到指定地址的存储单元,要存储的数据在 Rd 中 LDR{cond}B{T} Rd,&lt;地址&gt; ;加载字节数据,放入 Rd 中,即 Rd 最低字节有效,高 24 位清零 STR{cond}B{T} Rd,&lt;地址&gt; ;存储字节数据,要存储的数据在 Rd,最低字节有效 2、LDM 和 STM批量加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数，LDM 为加载多个寄存器，STM 为存储多个寄存器，允许一条指令传送 16 个寄存器任何子集或所有寄存器。LDM /STM 的主要用途是现场保护、数据复制、参数传送等。 指令格式如下: 1234567LDM{cond}&lt;模式&gt; Rn{!},reglist{^} STM{cond}&lt;模式&gt; Rn{!},reglist{^} LDMIA R0!,{R3-R9} ;加载 R0 指向的地址上的多字数据,保存到 R3～R9 中,R0 值更新 STMIA R1!,{R3-R9} ;将 R3～R9 的数据存储到 R1 指向的地址上,R1 值更新 STMFD SP!,{R0-R7,LR} ;现场保存,将 R0～R7、LR 入栈 LDMFD SP!,{R0-R7,PC}^;恢复现场,异常处理返回 3、 SWP寄存器和存储器交换指令，SWP 指令用于将一个内存单元(该单元地址放在寄存器Rn 中)的内容读取到一个寄存器 Rd 中,同时将另一个寄存器 Rm 的内容写入到该内存单元中。 指令格式如下: SWP{cond}{B} Rd,Rm,[Rn]、 其中，B 为可选后缀,若有B，则交换字节，否则交换 32 位字；Rd 为数据从存储器加载到的寄存器；Rm 的数据用于存储到存储器中，若 Rm 与 Rn 相同，则为寄存器与存储器内容进行交换；Rn 为要进行数据交换的存储器地址,Rn 不能与 Rd 和 Rm 相同. SWP 指令举例如下： 123SWP R1,R1,[R0] ;将 R1 的内容与 R0 指向的存储单元的内容进行交换 SWP R1,R2,,[R0] ;将R0指向的存储单元内容读取一字节数据到R1中(高24 位清零),并将R2的内容写入到该内存单元中(最低字节有效) ​ ​ 数据传送指令4、MOV数据传送指令，将 8 位图立即数或寄存器(operant2)传送到目标寄存器 Rd，可用于移位运算等操作。 指令格式如下： MOV{cond}{S} Rd,operand2 MOV 指令举例如下: 12345MOV R1#0x10 ;R1=0x10 MOV R0,R1 ;R0=R1 MOVS R3,R1,LSL #2 ;R3=R1＜＜2,并影响标志位 MOV PC,LR ;PC=LR ,子程序返回 5、MVN数据非传送指令，将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数。 指令格式如下: MVN{cond}{S} Rd,operand2 MVN 指令举例如下: 12MVN R1,#0xFF ;R1=0xFFFFFF00 MVN R1,R2 ;将 R2 取反,结果存到 R1 算术逻辑运算指令6、ADD加法运算指令，将 operand2 数据与 Rn 的值相加，结果保存到 Rd 寄存器。 指令格式如下： ADD{cond}{S} Rd,Rn,operand2 ADD 指令举例如下: 123ADDS R1,R1,#1 ;R1=R1+1 ADD R1,R1,R2 ;R1=R1+R2 ADDS R3,R1,R2,LSL #2 ;R3=R1+R2＜＜2 7、SUB减法运算指令，用寄存器 Rn 减去 operand2.结果保存到 Rd 中。 指令格式如下：SUB{cond}{S} Rd,Rn,operand2 SUB 指令举例如下： 1234SUBS R0,R0,#1 ;R0=R0-1 SUBS R2,R1,R2 ;R2=R1-R2 SUB R6,R7,#0x10 ;R6=R7-0x10 8、RSB逆向减法指令，用寄存器 operand2 减法 Rn，结果保存到 Rd 中。 指令格式如下：RSB{cond}{S} Rd,Rn,operand2 RSB 指令举例如下： 123RSB R3,R1,#0xFF00 ;R3=0xFF00-R1 RSBS R1,R2,R2,LSL #2 ;R1=R2＜＜2-R2=R2×3 RSB R0,R1,#0 ;R0=-R1 9、ADC带进位加法指令，将 operand2 的数据与 Rn 的值相加，再加上 CPSR 中的 C 条件标志位，结果保存到 Rd 寄存器。 指令格式如下; ADC{cond}{S} Rd,Rn,operand2 ADC 指令举例如下: 12ADDS R0,R0,R2 ADC R1,R1,R3 ;使用 ADC 实现 64 位加法,(R1、R0)=(R1、R0)+（R3、R2） 10、SBC带进位减法指令。用寄存器 Rn 减去 operand2，再减去 CPSR 中的 C 条件标志位的非（即若 C 标志清零，则结果减去 1），结果保存到 Rd 中。 指令格式如下： SCB{cond}{S} Rd,Rn,operand2 SBC 指令举例如下： 12SUBS R0，R0，R2 SBC R1，R1，R3 ;使用 SBC 实现 64 位减法,(R1,R0)-(R3,R2) 11、RSC带进位逆向减法指令。用寄存器 operand2 减去 Rn，再减去 CPSR 中的 C 条件标志位，结果保存到 Rd 中。 指令格式如下：RSC{cond}{S} Rd,Rn,operand2 RSC 指令举例如下： 12RSBS R2,R0,#0 RSC R3,R1,#0 ;使用 RSC 指令实现求 64 位数值的负数 12、AND逻辑与操作指令，将 operand2 值与寄存器 Rn 的值按位作逻辑与操作，结果保存到Rd 中。 指令格式如下： AND{cond}{S} Rd,Rn,operand2 AND 指令举例如下: 12ANDS R0,R0,#x01 ;R0=R0&amp;0x01,取出最低位数据 AND R2,R1,R3 ;R2=R1&amp;R3 13、ORR逻辑或操作指令，将operand2的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中。 指令格式如下：ORR{cond}{S} Rd,Rn,operand2 ORR 指令举例如下: 123ORR R0,R0,#x0F ;将 R0 的低 4 位置 1 MOV R1,R2,LSR #4 ORR R3,R1,R3,LSL #8 ;使用 ORR 指令将近 R2 的高 8 位数据移入到 R3 低 8 位 中 14、 EOR逻辑异或操作指令。将operand2的值与寄存器Rn的值按位作逻辑异或操作，结果保存到 Rd 中。 指令格式如下： EOR{cond}{S} Rd,Rn,operand2 EOR 指令举例如下 123EOR R1,R1,#0x0F ;将 R1 的低 4 位取反 EOR R2,R1,R0 ;R2=R1^R0 EORS R0,R5,#0x01 ;将 R5 和 0x01 进行逻辑异或,结果保存到 R0,并影响标志位","link":"/20211130/ARM%E6%8C%87%E4%BB%A4%E9%9B%86/"},{"title":"ARM汇编小结","text":"一、ARM汇编规范1、书写规范 所有的符号都必须在一行书写，在后面不用添加高级语言所用的分号。 ARM汇编器对标识符的大小写敏感，书写符号以及指令时字母大小写一定要一致。 一条ARM指令，伪指令。寄存器名可以全部写为大写字母,也可以全部为小写字母, 但是不能大小写混合编写使用。 注释使用(分号)，注释内容由(分号)开始到执行结束。 例如：[符号] &lt;指令|条件|S&gt; &lt;操作数&gt;[;注释] 2、符号符号可以代表地址、变量、数字变量，当符号代表地址时又叫标号，符号就是变量的变量名、数字常量的名称、标号，符号的命名规则如下： 符号由大小写字母、数字以及下划线组成； 除局部标号以数字开头外，其它的符号不能以数字开头； 符号区分大小写，且所有字符都是有意义的； 符号在其作用域范围必须是唯一的； 符号不能与系统内部或系统预定义的符号同名； 符号不要与指令助记符、伪指令同名。 3、常量常量的分类：数字常数、字符常量、布尔常量 （1）数字常数有三种表示方式： 十进制数，如：12、5、876、0 十六进制数如：0x4387、0xFF0、0x1 n 进制数用n-XXX 表示，其中n 为2～9，XXX 为具体的数，如：2-010111、8-4363156 （2）字符常量 字符常量由一对单引号及中间字符串表示，标准C 语言中的转义符也可使用。如果需要包含双引号或$，必须使用”” “”和$$代替。 如：Hello SETS “Hello World！” Errorl SETS “The parameter ““VFH””error$$2” （3）布尔常量 布尔常量的逻辑真为{TRUE}，逻辑假为{FALSE}。 如： testno SETS {FALSE} 4、ARM指令的格式ARM是三地址指令格式，指令的基本格式为： 1234567&lt;opcode&gt; {&lt;cond&gt;} {s} &lt;Rd&gt;, &lt;Rn&gt; {,&lt;operand2&gt;} opcode: 指令助记符 cond: 执行条件 s: 是否影响CPSR寄存器的值 Rd: 目标寄存器 Rn: 第一个操作数的寄存器 operand2: 第二个操作数 其中&lt; &gt;号内为必须的，{ }里面的项是可选的 5、跳转指令B 无条件跳转 BEQ 相等后跳转 BNE 不相等后跳转 BL 带链接的无条件跳转 BX 带状态切换的无条件跳转 根据目标地址最低位切换状态（arm/thumb） BLX 带链接和状态切换的无条件跳转 B loc_地址 6.存储器与寄存器交互数据指令存储器（主存，内存）寄存器中放的数据：可以是字符串，可以是数，也可以是一个地址，它可以放各种类型的数据存储地址单元：地址（如0x00004000）与地址中存在的值 A、LDR指令 (Load from memory into register)LDR指令的格式： LDR{条件} 目的寄存器 &lt;存储器地址&gt; 作用：将存储器地址所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 ← LDR指令的寻址方式比较灵活,实例如下： 123456789101112131415161718192021LDR R0，[R1] ；将存储器地址为R1的字数据读入寄存器R0。LDR R0，[R1，R2] ；将存储器地址为R1+R2的字数据读入寄存器R0。LDR R0，[R1，#8] ；将存储器地址为R1+8的字数据读入寄存器R0。LDR R0，[R1],R2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1],#8 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+8的值存入R1。LDR R0，[R1，R2]! ；将存储器地址为R1+R2的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1，LSL #3] ；将存储器地址为R1*8的字数据读入寄存器R0。LDR R0，[R1，R2，LSL #2] ；将存储器地址为R1+R2*4的字数据读入寄存器R0。LDR R0，[R1,,R2，LSL #2]！ ；将存储器地址为R1+R2*4的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，[R1],R2，LSL #2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，Label ；Label为程序标号，Label必须是当前指令的-4~4KB范围内。 B、STR指令 (Store from a register into memory)STR指令的格式为： STR{条件} 源寄存器，&lt;存储器地址&gt; STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。→ 123456STR r1, [r0] ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中STR R0，[R1]，＃8 ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。STR R0，[R1，＃8] ；将R0中的字数据写入以R1＋8为地址的存储器中。 C、LDM指令 (Load from memory into register / Load much)LDM指令的格式为： LDM {cond} &lt;模式&gt; Rn{!},reglist{^} LDM是将内存中堆栈内的数据，批量的赋值给寄存器，即是出栈操作 → LDM R0,｛R1-R3｝将R0指向的存储单元的数据依次加载到R1,R2,R3寄存器 D、STM指令 (Store from a register into memory / Store much)STM指令的格式为： STM {cond} &lt;模式&gt; Rn{!},reglist{^} STM：将一个寄存器列表的数据存储到指定的存储器 ← STM R0,{R1-R3} ;把R1,R2,R3保存到堆栈R0中 E、PUSH和POPPUSH:将寄存器值推入堆栈 压栈--&gt; POP：将堆栈值推出到寄存器 出栈 &lt;-- F、SWPSWP将寄存器与存储器之间的数据进行交换 SWP指令的格式为： SWP Rd,Rm,[Rn] Rd 为数据从存储器加载到的寄存器；Rm的数据用于存储到存储器中，若Rm与Rn相同，则为寄存器与存储器内容进行交换；Rn为要进行数据交换的存储器地址，Rn不能与Rd和Rm相同。 123SWP R1, R1 [R0] ;将R1寄存器与R0指向的存储单元的内容进行交换SWP R1, R2, [R0] ;把R0所指向的内容读到R1，同时把R2的内容写到 [R0] 7、数据传送指令MOV：将立即数或寄存器的数据传送到目标寄存器 ← 1MOV R0, #8 ;R0=8 8、数据算术运算指令​ ←​ ADD,SUB,MUL,DIV (加、减、乘、除)​ 有符号，无符号运算；带进位运算 9、数据算术运算指令与：AND或：ORR异或：EOR 移位：实质是乘，除，类似于小数点移位，但相反。小数点左移，数变小；右移变大。但逻辑移位，左移变大，右移变小，且按2的倍数进行，因为是2进制。 LSL：逻辑左移←LSR：逻辑右移← LSL R0,R1，#2 ；R0=R1*4 LSR R0,R1，#2 ；R0=R1*2 10、比较指令CMP：比较 1CMP R0 #0 ;R0寄存器中的值与0比较","link":"/20210906/ARM%E6%B1%87%E7%BC%96%E5%B0%8F%E7%BB%93/"},{"title":"Crakeme01实战分析 IDA动态静态分析","text":"一、APK下载Crakeme01:Crakeme01.apk 二、jadx分析java代码根据AndroidManifest.xml找到程序入口第一眼看到的System.loadLibrary()，就知道有NDK开发SO了，首先判断输入是否是空，非空的话调用NI.greywolf(this, this.editText.getText().toString());，而greywolf是 三、IDA静态分析上来一看，发现没有java_开头，敲定是动态注册，直接看伪代码。 跟进去AD()看下，发现里面全是各种反调试，动态调试的时候直接nop掉就ok。 四、IDA动态调试在JNI_OnLoad开头下断点，nop掉反调试的部分。 JNI_OnLoad有三个函数，找最后一个的函数就是RegisterNatives，然后找RegisterNatives中的第三个参数，里面包含着对应关系。 跟进去按C，找到个bc函数。 在静态分析中找到bc，分析逻辑，dh主要做的是调试检测，如果没有被反调试，则return 1，否则kill 然后再return 0，ds这个函数猜测是加解密用的，flag没准就是v4的返回值，动态调试试一下。 ds函数打断点，对照静态调试的伪代码，找到指令，BLX后的返回值推测是flag，查看R0寄存器。 找到flag=hello5.1，还不算难.jpg。","link":"/20210918/Crakeme01%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90-IDA%E5%8A%A8%E6%80%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90/"},{"title":"Docker布置mitmproxy镜像使用Python脚本拦截请求","text":"mitmproxy 就是用于 MITM 的 proxy，MITM 即中间人攻击（Man-in-the-middle-attack）。用于中间人攻击的代理首先会向正常的代理一样转发请求，保障服务端与客户端的通信，其次，会适时的查、记录其截获的数据，或篡改数据，引发服务端或客户端特定的行为。本文教会读者如何用Docker搭建一个mitmproxy服务。 一、官方镜像及启动命令官方镜像 1docker pull mitmproxy/mitmproxy 1、挂载证书启动1docker run --rm -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -p 8080:8080 mitmproxy/mitmproxy 2、mitmdump加载脚本-v 将本地文件挂载到docker里面 1docker run --rm -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -v /mitm_proxy/:/usr/mitm_proxy -p 8899:8899 mitmproxy/mitmproxy mitmdump -p 8899 -s /usr/mitm_proxy/proxy.py 3、mitmweb1docker run --rm -it -p 8080:8080 -p 127.0.0.1:8081:8081 mitmproxy/mitmproxy mitmweb --web-host 0.0.0.0 二、定制自己的Docker1、创建Dockerfile创建自己的Docker的好处就是可以定制化下载各种各样的包 1234FROM mitmproxy/mitmproxyADD ./mitm_proxy /mitm_proxyWORKDIR /mitm_proxyRUN pip install PyMySQL 指令 说明 FROM 指定所创建镜像的基础镜像 ADD 赋值指定的路径下的内容到容器中的路径下，可以为URL；如果为tar文件，会自动解压到路径下(注意: 上边命令中.和/demo_mitm之间有空格，其中.表示宿主机的当前目录，即当前脚本所在目录,/demo_mitm表示docker容器目录，合起来的意思就是将宿主机当前目录下的文件拷贝至docker容器的/demo_mitm目录，文件夹不存在会自动创建) WORKDIR 配置工作目录，这里我配置的是/demo_mitm,即在上边通过ADD指令添加的目录下 RUN 在创建镜像时运行的命令，可写多个 2、Build1docker build -t demo_mitm:latest . 使用docker images，查看镜像 3、启动1docker run -i -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -v /data1/mitm_proxy/:/usr/mitm_proxy -p 8899:8899 demo_mitm mitmdump -p 8899 -s /usr/mitm_proxy/proxy.py 4、后台启动1docker run -i -d -it -v ~/.mitmproxy:/home/mitmproxy/.mitmproxy -v /data1/mitm_proxy/:/usr/mitm_proxy -p 8899:8899 demo_mitm mitmdump -p 8899 -s /usr/mitm_proxy/proxy.py 5、docker run参数123456789101112131415161718192021222324252627282930313233docker run --helpUsage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...] Run a command in a new container -a, --attach=[] Attach to stdin, stdout or stderr. -c, --cpu-shares=0 # 设置 cpu 使用权重 --cap-add=[] Add Linux capabilities --cap-drop=[] Drop Linux capabilities --cidfile=&quot;&quot; # 把容器 id 写入到指定文件 --cpuset=&quot;&quot; # cpu 绑定 -d, --detach=false Detached mode: Run container in the background, print new container id # 后台运行容器 --device=[] Add a host device to the container (e.g. --device=/dev/sdc:/dev/xvdc) --dns=[] # 设置 dns --dns-search=[] # 设置 dns 域搜索 -e, --env=[] # 定义环境变量 --entrypoint=&quot;&quot; Overwrite the default entrypoint of the image # ？ --env-file=[] # 从指定文件读取变量值 --expose=[] # 指定对外提供服务端口 -h, --hostname=&quot;&quot; # 设置容器主机名 -i, --interactive=false # 保持标准输出开启即使没有 attached --link=[] # 添加链接到另外一个容器 --lxc-conf=[] (lxc exec-driver only) Add custom lxc options --lxc-conf=&quot;lxc.cgroup.cpuset.cpus = 0,1&quot; -m, --memory=&quot;&quot; # 内存限制 --name=&quot;&quot; # 设置容器名 --net=&quot;bridge&quot; # 设置容器网络模式 'bridge': creates a new network stack for the container on the docker bridge 'none': no networking for this container 'container:&lt;name|id&gt;': reuses another container network stack 'host': use the host network stack inside the container. Note: the host mode gives the container full access to local system services such as D-bus and is therefore considered insecure. -P, --publish-all=false # 自动映射容器对外提供服务的端口 -p, --publish=[] # 指定端口映射 format: ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort (use 'docker port' to see the actual mapping) --privileged=false # 提供更多的权限给容器 --restart=&quot;&quot; Restart policy to apply when a container exits (no, on-failure[:max-retry], always) --rm=false # 如果容器退出自动移除和 -d 选项冲突 --security-opt=[] Security Options --sig-proxy=true Proxify received signals to the process (even in non-tty mode). SIGCHLD is not proxied. -t, --tty=false # 分配伪终端 -u, --user=&quot;&quot; # 指定运行容器的用户 uid 或者用户名 -v, --volume=[] # 挂载卷 --volumes-from=[] # 从指定容器挂载卷 -w, --workdir=&quot;&quot; # 指定容器工作目录 12console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20211209/Docker%E5%B8%83%E7%BD%AEmitmproxy%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8mitmdump%E5%90%AF%E5%8A%A8Python%E8%84%9A%E6%9C%AC/"},{"title":"IDA安卓10动态调试","text":"一、调式环境1、IDA Pro 7.5 2、Pixel 2 XL 安卓10 二、环境准备找到 IDA目录下的文件夹dbgsrv中的android_server，然后推到手机 /data/local/tmp目录 12PS D:\\IDA\\dbgsrv&gt; adb push .\\android_server /data/local/tmp.\\android_server: 1 file pushed, 0 skipped. 32.6 MB/s (786868 bytes in 0.023s) 然后切换到对应目录，给予777权限并启动，android_server默认端口23946 1234567891011PS C:\\Users\\Admin&gt; adb shelltaimen:/ $ sutaimen:/ # cd /data/local/tmp/127|taimen:/data/local/tmp # chmod 777 android_server//重要：安卓10 IDA Pro 7.5 要用这种方式启动android_server taimen:/data/local/tmp # IDA_LIBC_PATH=/apex/com.android.runtime/lib/bionic/libc.so /data/local/tmp/android_serverIDA Android 32-bit remote debug server(ST) v7.5.26. Hex-Rays (c) 2004-2020Listening on 0.0.0.0:23946... 特别注意：安卓10 IDA Pro 7.5 要用这种方式启动android_serverIDA_LIBC_PATH=/apex/com.android.runtime/lib/bionic/libc.so /data/local/tmp/android_server转发端口 1PS C:\\Users\\Admin&gt; adb forward tcp:23946 tcp:23946 三、动态调试1、调试模式挂起app1adb shell am start -D -n com.example.javandk1/.MainActivity 2、Ida选择Linux/Android debugger 3、填入Host和Port 4、选择调试的APP 5 、加载完毕后，设置ida三钩、 6、DDMS查看挂机的端口 7、jdb放开调试1jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8600 接下来就可以动态调试了 IDA调试常用快捷键： F2快速下断点。 F7单步步入，F8单步步过。 F4运行到光标所在位置。 G跳到地址和函数名。 U解析成未定义数据。 C将数据解析成汇编指令。 光标放在函数头位置，按P键将汇编指令识别为函数。 CTRL+F搜索。 F5将汇编指令识别伪代码。 ALT+G查看当前指令是Thumb指令还是ARM指令。 CTRL+S看见系统所有的模块。 X交叉引用。","link":"/20210914/IDA%E5%AE%89%E5%8D%9310%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"},{"title":"NDK开发小结","text":"一、JNI作用：用于java代码和C++、c代码的交互（代码混编）。 分类使用：Jni静态注册、jni动态注册 二、静态注册1、定义被native修饰的方法1public native String Getstring(); 2、根据java代码生成.h头文件（javah -jni 类的包名路径）1javah -jni com.example.jnitest.MainActivity 3、编写C/C++代码，导入.h头文件，实现我们.h头文件中方法123456789#include &lt;JNItest.h&gt;JNIEXPORT jstring JNICALL Java_com_example_jnitest_MainActivity_Getstring (JNIEnv *env, jobject obj) { jstring str = (*env)-&gt;NewStringUTF(env, &quot;hello ndk&quot;); return str; } 4、编写（配置）两个mk文件：application.mk/android.mk1234567891011#application.mkAPP_ABI := armeabi#android.mkLOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := JNItest LOCAL_SRC_FILES := JNItest.c LOCAL_ARM_MODE := armLOCAL_LDLIBS += -llog include $(BUILD_SHARED_LIBRARY) 5、通过ndk-build生成so文件1ndk-build 6、java代码中加载so文件/libs文件下去头去尾（头：lib；尾：.so）123static{ System.loadLibrary(&quot;JNItest&quot;);} 7、build.gradle文件配置123456androi -ddefaultConfig --ndk { // 设置支持的SO库架构 abiFilters 'armeabi' ,'x86', 'armeabi-v7a', 'x86_64','arm64-v8a' } 8、main创建jniLibs文件夹将so文件复制123456main -jniLibs --armeabi ---libJNItest.so --armeabi-v7a ---libJNItest.so 三、动态注册1、.c文件编写JNI_OnLoadFindClass处填写对应类 1234567891011121314151617JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved){ JNIEnv* env; if((*vm)-&gt;GetEnv(vm, (void**)&amp;env, JNI_VERSION_1_4)!=JNI_OK){ return JNI_ERR; } jclass cls=(*env)-&gt;FindClass(env, &quot;com/example/myjnireistest/MainActivity&quot;); if((*env)-&gt;RegisterNatives(env, cls, jninativemethod,2)!=JNI_OK){ return JNI_ERR; } return JNI_VERSION_1_4;} 2、.c文件定义方法结构体123456789101112JNINativeMethod jninativemethod[]={ { &quot;getInt&quot;, &quot;()I&quot;, (void*)GetInt }, { &quot;getChar&quot;, &quot;()C&quot;, (void*)GetChar, }}; 3、.c文件对应C函数12345678jint GetInt (JNIEnv *env, jobject obj){ return 99;}jchar GetChar(JNIEnv* env, jobject obj){ return 'y';} 4、java代码逻辑12345static { System.loadLibrary(&quot;MyJniTest&quot;);}public native int getInt();public native char getChar(); 四、SO库获取java层字段值12345678//反射获取对应类jclass clazz=(*env)-&gt;FindClass(env, &quot;com/example/myjnilogin/MainActivity&quot;);//获取实例字段id (env, clazz, 字段名,字段类型)jfieldID fieldid = (*env)-&gt;GetFieldID(env, clazz, &quot;userId&quot;,&quot;Ljava/lang/String;&quot;);//根据实例id获取对应的值jstring jstr_user = (*env)-&gt;GetObjectField(env, obj, fieldid);//将string转化charconst char* user= (*env)-&gt;GetStringUTFChars(env, jstr_user, 0); 五、SO库调用JAVA函数1234//反射获取方法idjmethodID methodID = (*env)-&gt;GetMethodID(env,clazz, &quot;pwError&quot;, &quot;()V&quot;);//call调用方法(*env)-&gt;CallVoidMethod(env,obj, methodID);","link":"/20210831/NDK%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/"},{"title":"Pycharm激活新思路所有版本无限试用！适用于所有jetbrains产品","text":"一、前言PyCharm激活码是大家一直都需要的，主要是PyCharm激活码一段时间就会过期，并且涉及到法律问题，产生侵权行为，而下面这种方法是用自动的方法代替手动卸载Pychram并重新试用，适用于所有jetbrains产品，一劳永逸，无限试用，并且我们没有对软件进行破解等不会产生侵权行为。 二、方法1、插件获取 12扫码关注公众号：虫术回复关键字：激活 (1) 可以 for free 免费进入的朋友直接将插件用鼠标拖入到代码编辑区就会安装，如果无法拖动安装，你可以在Settings–Plugins 里手动安装插件（Install Plugin From Disk），插件会提示安装成功。 ​ (2) 已经到期的朋友只有卸载重装了。(在重装之前不用特意去卸载，直接找到安装包点击再次安装，将弹窗出来的是否卸载之前的都打勾就可以卸载干净)。重装之后按照上面(1)操作即可 3、插件使用：（1）一般来说，在IDE窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（25天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示） （2）也可以手动唤出插件的主界面： 如果IDE没有打开项目，在 pycharm 界面点击菜单Get Help -&gt; Eval Reset； 如果IDE打开了项目，点击菜单：Help -&gt; Eval Reset （3)唤出的插件主界面中包含了一些显示信息，2个按钮，1个勾选项： 按钮：Reload 用来刷新界面上的显示信息。 按钮：Reset 点击会询问是否重置试用信息并重启IDE。选择Yes则执行重置操作并重启IDE生效，选择No则什么也不做。（手动重置方式） 选项：Auto reset before per restart 如果勾选了，则自勾选后每次重启/退出IDE时会自动重置试用信息，你无需做额外的事情。（自动重置试用方式）无需再管，一劳永逸。理论上这个插件支持所有的所有的版本，本人只在 pycharm 2020.2.3 安装使用（其他版本请自行测试） 重要： 手动重置的效果（插件安装3天之后）：还剩27天试用，点reset之后试用变成30天 reset之前： reset 重置试用之后： 结语：现在这种插件重置方式比补丁激活的方式更香了，官方无法封杀。只是通过重置了使用信息来保障我们可以一直用下去。 123console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/欢迎大家前来交流","link":"/20211209/Pycharm%E6%BF%80%E6%B4%BB%E6%96%B0%E6%80%9D%E8%B7%AF%E6%89%80%E6%9C%89%E7%89%88%E6%9C%AC%E6%97%A0%E9%99%90%E8%AF%95%E7%94%A8%EF%BC%81%E9%80%82%E7%94%A8%E4%BA%8E%E6%89%80%E6%9C%89jetbrains%E4%BA%A7%E5%93%81/"},{"title":"Icarus 主题配置","text":"目录粘性定位原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 123456diff:source/js/main.js if ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); 12345diff:include/style/article.styl+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll","link":"/20210814/Icarus%E9%85%8D%E7%BD%AE/"},{"title":"Python自动化构建雷电模拟器","text":"1、launch 支持2种启动雷电模拟器的方式–name顾名思义，应该是模拟器的标题栏的名字，本人经过验证果然如此!–index mnq_idx，模拟器的索引，第一个是0，第二个是1，以此类推 启动默认模拟器的2种方法：lsconsole.exe launch –name 雷神模拟器lsconsole.exe launch –index 0 2、quit 退出模拟器也提供了3种退出方式，和launch对应，不再累述。 3、quitall 退出模拟器退出所有开着的模拟器。 4、属性设置部分精彩部分来了，同样，修改属性时也要指定需要修改的是哪个模拟器的属性（多开的情况），仍然采用的是以上的3种方式，雷神提供的属性字段有： modify &lt;–name mnq_name | –index mnq_idx&gt;[–resolution ] // 自定义分辨率[–cpu &lt;1 | 2 | 3 | 4&gt;] // cpu设置[–memory &lt;512 | 1024 | 2048 | 4096 | 8192&gt;] // 内存设置[–manufacturer asus] // 手机厂商[–model ASUS_Z00DUO] // 手机型号[–pnumber 13812345678] // 手机号码[–imei ] // imei设置，auto就自动随机生成[–imsi ][–simserial ][–androidid ][–mac ] //12位m16进制mac地址[–autorotate &lt;1 | 0&gt;][–lockwindow &lt;1 | 0&gt;] 写个例子，修改默认模拟器的分辨率为600*360,dpi 160,cpu为1核，内存1024，imei随机，这样写：lsconsole.exe modify –index 0 –resolution 600,360,160 –cpu 1 –memory 1024 –imei auto 注：调用modify需要在模拟器启动前，不然可能不生效 5、新增模拟器add [–name mnq_name] 6、复制模拟器copy [–name mnq_name] –from 注意：from参数既可以是名字也可以是索引，判断规则为如果全数字就认为是索引，否则是名字 7、删除模拟器remove &lt;–name mnq_name | –index mnq_idx&gt; 8、备份，还原命令backup &lt;–name mnq_name | –index mnq_idx&gt; –filerestore &lt;–name mnq_name | –index mnq_idx&gt; –file 9、list2F:\\BaiZhi\\lsplayer&gt;lsconsole.exe list20,雷神模拟器,2032678,1704928,1,7456,35001,雷神模拟器-1,852422,590830,1,3772,3180 list2一次性返回了多个信息，依次是：索引，标题，顶层窗口句柄，绑定窗口句柄，是否进入android，进程PID，VBox进程PID官方文档 Python自动化构建模拟器1234567891011import os#切换至命令目录os.chdir('D:\\LDPlayer3.0')# 删除模拟器os.system('ldconsole.exe remove --name test2')#创建新的模拟器os.system('ldconsole.exe add --name test2')#设置模拟器属性os.system('ldconsole.exe modify --name test2 --resolution 1080,1920,480 --cpu 4 --imei auto --imsi auto --mac auto --manufacturer HUAWEI --model LIO-AN00')#打开模拟器os.system('ldconsole.exe launch --name test2') Python导入mitmproxy证书两种方式导入mitmproxy证书1、通过adb 2、是通过雷电ldconsole命令 1234567891011121314151617#adb --name &quot;雷神模拟器&quot;os.system('adb devices')# #推送至手机目录#ldconsole.exe push --name test2 --remote /sdcard --local F:/python3/RebortLeiDian/c8750f0d.0os.system('adb push F:/python3/RebortLeiDian/c8750f0d.0 /sdcard')# #给予写入权限#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell mount -o rw,remount /system&quot;os.system('adb shell &quot;mount -o rw,remount /system&quot;')# #推送至系统目录#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell mv /sdcard/c8750f0d.0 /system/etc/security/cacerts&quot;os.system('adb shell &quot;mv /sdcard/c8750f0d.0 /system/etc/security/cacerts&quot;')# #给予证书权限#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell chmod 644 /system/etc/security/cacerts/c8750f0d.0&quot;os.system('adb shell &quot;chmod 644 /system/etc/security/cacerts/c8750f0d.0&quot;')# #设置代理#ldconsole.exe adb --name &quot;test2&quot; --command &quot;shell settings put global http_proxy ip:端口&quot;os.system('adb shell &quot;settings put global http_proxy ip:端口&quot;') 完整代码，可以关注公众号回复: LD console.log(&quot;公众号:虫术&quot;) console.log(&quot;wx:spiderskill&quot;) 欢迎大家前来交流","link":"/20210723/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E9%9B%B7%E7%94%B5%E6%A8%A1%E6%8B%9F%E5%99%A8/"},{"title":"Python根据关键词在360、百度、bing下载图片","text":"1. 简介输入一组关键词，指定所需图片个数，在常见搜索引擎中检索，记录图片url地址，并将图片保存在指定目录下。 百度图片：https://image.baidu.com/ 360搜图：https://image.so.com/ 微软：https://cn.bing.com/images/trending?FORM=ILPTRD） 2. 功能 支持的搜索引擎: 360, 必应, 百度 可配置线程数及代理 3. 安装3.1 安装相关python库1pip3 install -r requirements.txt 4. 如何使用4.1 命令行12345usage: image_downloader.py [-h] [--engine {baidu,bing,360}] [--max-number MAX_NUMBER] [--num-threads NUM_THREADS] [--timeout TIMEOUT] [--output OUTPUT] [--user-proxy USER_PROXY] keywords help 12345678910111213141516171819202122usage: image_downloader.py [-h] [--engine {baidu,bing,360}] [--max-number MAX_NUMBER] [--num-threads NUM_THREADS] [--timeout TIMEOUT] [--output OUTPUT] [--user-proxy USER_PROXY] keywordsImage Downloaderpositional arguments: keywords 搜索关键词optional arguments: -h, --help show this help message and exit --engine {baidu,bing,360}, -e {baidu,bing,360} 抓取网站. --max-number MAX_NUMBER, -n MAX_NUMBER 下载图片数量 --num-threads NUM_THREADS, -j NUM_THREADS 进程数 --timeout TIMEOUT, -t TIMEOUT 下载超时 --output OUTPUT, -o OUTPUT 输出文件夹 --user-proxy USER_PROXY, -p USER_PROXY 是否使用代理(默认不使用) 运行： 123456789101112131415161718python image_downloader.py &quot;中国地图&quot; -e &quot;360&quot; -n 10目标网站为:360关键词为: 中国地图抓取数量为:10条目标网站搜索结果为:1500目标抓取:10条 已抓取:10条##下载成功: 360_a674c5fccbd187575dbe3c46698d841a.jpeg##下载成功: 360_20760e3529df9287b80066168f35eae5.png##下载成功: 360_cb28e97178694f3f45788eec0894bf55.jpg##下载成功: 360_82dcd18912bbd65572d464e3e990eb8b.png##下载成功: 360_dbfb153accb1e125ea40fcd5585e3e5e.jpeg##下载成功: 360_7f95f7893557d445c668f448b159d9e0.jpg##下载成功: 360_968b76513aa6a56866bc5a68c873f5cd.png##下载成功: 360_aabb350a736c8418f8f581a660f9fb74.png##下载成功: 360_06ffc47d52f056cb2848315c2e6cb2ef.jpeg##下载成功: 360_a99a12dd76843c48264f215c50b099d0.jpegFinished. downloader.py:做图片下载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&quot;&quot;&quot; Download image according to given urls and automatically rename them in order. &quot;&quot;&quot;# -*- coding: utf-8 -*-# author: Yabin Zheng# Email: sczhengyabin@hotmail.comfrom __future__ import print_functionimport hashlibimport shutilimport imghdrimport osimport concurrent.futuresimport requestsheaders = { &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;Proxy-Connection&quot;: &quot;keep-alive&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) &quot; &quot;AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, sdch&quot;,}def download_image(image_url, dst_dir, file_prefix, timeout=20, use_proxy=False): proxies = None # if proxy_type: # proxies = { # &quot;http&quot;: proxy_type + &quot;://&quot; + proxy, # &quot;https&quot;: proxy_type + &quot;://&quot; + proxy # } response = None try_times = 0 while True: try: try_times += 1 response = requests.get( image_url, headers=headers, timeout=timeout, proxies=proxies) image_name = get_img_name(response.content) file_name = file_prefix + &quot;_&quot; + image_name file_path = os.path.join(dst_dir, file_name) with open(file_path, 'wb') as f: f.write(response.content) response.close() file_type = imghdr.what(file_path) if file_type in [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;png&quot;, &quot;bmp&quot;]: new_file_name = &quot;{}.{}&quot;.format(file_name, file_type) else: new_file_name = &quot;{}.{}&quot;.format(file_name, 'jpg') new_file_path = os.path.join(dst_dir, new_file_name) shutil.move(file_path, new_file_path) print(&quot;##下载成功: {} &quot;.format(new_file_name)) break except Exception as e: if try_times &lt; 3: continue if response: response.close() print(&quot;##下载错误: {} {}&quot;.format(e.args,image_url)) breakdef download_images(image_urls, folder_dir='./download_images', file_prefix=&quot;img&quot;, max_workers=50, timeout=20, use_proxy=False): &quot;&quot;&quot; 图片下载 :param image_urls:图片列表 :param folder_dir:文件夹地址 :param file_prefix:文件来源 :param max_workers:最大并发 :param timeout:下载超时 :param use_proxy:是否使用代理 :return: &quot;&quot;&quot; with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor: future_list = list() count = 0 if not os.path.exists(folder_dir): os.makedirs(folder_dir) for image_url in image_urls: future_list.append(executor.submit( download_image, image_url, folder_dir, file_prefix, timeout, use_proxy)) count += 1 concurrent.futures.wait(future_list, timeout=180)def get_img_name(image_url): &quot;&quot;&quot; 图片name :param image_url: :return: &quot;&quot;&quot; md5 = hashlib.md5() md5.update(image_url) image_name = md5.hexdigest() return image_name image_downloader.py：做启动调度 123456789101112131415161718192021222324252627282930313233343536373839404142from __future__ import print_functionimport argparseimport crawlerimport downloaderimport sysdef main(argv): parser = argparse.ArgumentParser(description=&quot;Image Downloader&quot;) parser.add_argument(&quot;keywords&quot;, type=str, help='搜索关键词') parser.add_argument(&quot;--engine&quot;, &quot;-e&quot;, type=str, default=&quot;baidu&quot;, help=&quot;抓取网站.&quot;, choices=[&quot;baidu&quot;, &quot;bing&quot;, &quot;360&quot;]) parser.add_argument(&quot;--max-number&quot;, &quot;-n&quot;, type=int, default=100, help=&quot;下载图片数量&quot;) parser.add_argument(&quot;--num-threads&quot;, &quot;-j&quot;, type=int, default=50, help=&quot;进程数&quot;) parser.add_argument(&quot;--timeout&quot;, &quot;-t&quot;, type=int, default=20, help=&quot;下载超时&quot;) parser.add_argument(&quot;--output&quot;, &quot;-o&quot;, type=str, default=&quot;./download_images&quot;, help=&quot;输出文件夹&quot;) parser.add_argument(&quot;--user-proxy&quot;, &quot;-p&quot;, type=str, default=False, help=&quot;是否使用代理(默认不使用)&quot;) args = parser.parse_args(args=argv) # 默认不加代理 use_proxy = False crawled_urls = crawler.crawl_image_urls(args.keywords, engine=args.engine, max_number=args.max_number, use_proxy=use_proxy) downloader.download_images(image_urls=crawled_urls, folder_dir=args.output, max_workers=args.num_threads, timeout=args.timeout, use_proxy=use_proxy, file_prefix=args.engine) print(&quot;Finished.&quot;)if __name__ == '__main__': main(sys.argv[1:]) 项目地址:https://github.com/404SpiderMan/DownloadImage 1234console.log(&quot;公众号:虫术&quot;)console.log(&quot;wx:spiderskill&quot;)console.log(&quot;Blog:http://404nofoundx.top/&quot;)欢迎关注！探讨爬虫逆向及搬砖摸鱼技巧！","link":"/20211203/Python%E6%A0%B9%E6%8D%AE%E5%85%B3%E9%94%AE%E8%AF%8D%E5%9C%A8360%E3%80%81%E7%99%BE%E5%BA%A6%E3%80%81bing%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/"},{"title":"Tampermonkey油猴脚本安装及入门","text":"一、简介油猴脚本是是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox，通过它可以让浏览器实现各种各样的扩展功能，和浏览器扩展的作用类似。比如获去链接重定向、微博页面精简、去广告等，可以说为所欲也了。 二、油猴脚本安装官方网站选择对应预览器下载即可。 三、脚本创建及基本用法首先添加一个新脚本 一个初始化脚本已经完成。官方文档：https://www.tampermonkey.net/documentation.php?ext=dhdg#GM_openInTab 12345678910111213141516// ==UserScript==// @name New Userscript// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author You// @match https://www.tampermonkey.net/// @icon https://www.google.com/s2/favicons?domain=tampermonkey.net// @grant none// ==/UserScript==(function() { 'use strict'; // Your code here...})(); 用户脚本 Header@name脚本名称 @namesapce脚本命名空间 @include设置脚本在哪些网页中可以运行，允许设置多个标签。 @include 不支持URL hash参数。 123@include http://123.com/*@include https://123.com/*@include https://* @match与 @include 标签类似，允许设置多个。 1@match http*:// @exclude排除的URL， 在这些页面不运行脚本， 即使地址包含在 @include或@match标签内。允许设置多个。 @require表示在运行脚本前需要加载和运行的JavaScript文件。允许设置多个。注：如果加载的脚本使用use strict模式，用户脚本可能也会受严格模式影响 123@require https://code.jquery.com/jquery-2.1.4.min.js@require https://code.jquery.com/jquery-2.1.3.min.js#sha256=23456...@require https://code.jquery.com/jquery-2.1.2.min.js#md5=34567...,sha256=6789.. @resource定义一些需要预加载的资源文件，这些资源可以在脚本中通过GM_getResourceURL，GM_getResourceText访问。允许设置多个。 1234@resource icon2 /images/icon.png@resource html http://www.tampermonkey.net/index.html@resource xml http://www.tampermonkey.net/crx/tampermonkey.xml@resource SRIsecured1 http://www.tampermonkey.net/favicon.ico#md5=123434... @connect设置允许通过GM_xmlhttpRequest连接访问的域名（包括子域名）。 12@connect *@connect *://*.qidian.com/ @connect 标签允许设置的值： 域名，如tampermonkey.net, 设置后该域名下的所有子域名都是允许访问的 @run-at设置注入脚本的时间。@run-at defines the first possible moment a script wants to run. @run-at document-start The script will be injected as fast as possible.@run-at document-body The script will be injected if the body element exists.@run-at document-end The script will be injected when or after the DOMContentLoaded event was dispatched.@run-at document-idle The script will be injected after the DOMContentLoaded event was dispatched. This is the default value if no @run-at tag is given.@run-at content-menu The script will be injected if it is clicked at the browser context menu (desktop Chrome-based browsers only). @grant@grant标签用于设置GM_*方法， unsafeWindow对象， window对象方法的白名单。If no @grant tag is given TM guesses the scripts needs. 123456@grant GM_setValue@grant GM_getValue@grant GM_setClipboard@grant unsafeWindow@grant window.close@grant window.focus APIunsafeWindowunsafeWindow对象提供对页面javascript函数和变量的完全访问。 GM_addStyle(css)将给定样式添加到文档并返回注入的样式元素。 GM_addElement(tag_name, attributes), GM_addElement(parent_node, tag_name, attributes)创建由tag_name指定的HTML元素，应用所有给定的attributes，并返回注入的HTML元素。如果给定了“父节点”，则会将其附加到该节点或附加到文档头或文档体。 12345678910111213141516GM_addElement('script', { textContent: 'window.foo = &quot;bar&quot;;'});GM_addElement('script', { src: 'https://example.com/script.js', type: 'text/javascript'});GM_addElement(document.getElementsByTagName('div')[0], 'img', { src: 'https://example.com/image.png'});GM_addElement(shadowDOM, 'style', { textContent: 'div { color: black; };'}); GM_deleteValue(name)从storage中删除“名称”。 GM_listValues()列出storage的所有名称。 GM_addValueChangeListener(name, function(name, old_value, new_value, remote) {})对storage存储的变量添加监听器，返回监听器ID。 name参数是要监听的变量名 GM_removeValueChangeListener(listener_id)移除监听器。 GM_setValue(name, value)将“name”的值设置为storage。 GM_getValue(name, defaultValue)从storage里面获取’name’的值 GM_log(message)控制台输出日志 GM_getResourceText(name)获取在脚本头部用@resource标签预定义的的内容 GM_getResourceURL(name)获取在脚本头部用@resource标签预定义的的base64编码的URI GM_registerMenuCommand(name, fn, accessKey)在脚本运行页面的Tampermonkey菜单中注册新的菜单，返回菜单command ID GM_unregisterMenuCommand(menuCmdId)注销用GM_registerMenuCommand注册的菜单 GM_openInTab(url, options), GM_openInTab(url, loadInBackground)在新标签页打开URL。options可选的值： active decides whether the new tab should be focused, insert that inserts the new tab after the current one, setParent makes the browser re-focus the current tab on close and incognito makes the tab being opened inside a incognito mode/private mode window. GM_xmlhttpRequest(details)创建一个 xmlHttpRequest. GM_download(details), GM_download(url, name)下载URL指定资源到本地磁盘 四、编写Cookies转发脚本用于转发页面上的cookies信息到我们自己的服务器，供爬虫使用。 油猴脚本12345678910111213141516171819202122232425262728293031323334// ==UserScript==// @name BSpider// @namespace http://tampermonkey.net/// @version 0.1// @description cookies转发脚本// @author X// @match https://www.baidu.com/*// @icon https://www.google.com/s2/favicons?domain=tampermonkey.net// @grant GM_log// @grant GM_xmlhttpRequest// @grant GM_notification// @grant unsafeWindow// @run-at document-end// @connect *// ==/UserScript==(function() { //text, title, image, onclick) GM_log(&quot;脚本加载成功&quot;); var save_cookie = document.cookie; GM_log(save_cookie); GM_xmlhttpRequest({ url:&quot;http://ip:port/test&quot;, method :&quot;POST&quot;, data:save_cookie, headers: { &quot;Content-type&quot;: &quot;application/x-www-form-urlencoded&quot; }, onload:function(xhr){ GM_log(&quot;success&quot;); } });})(); 访问时会通知跨域，总是运行就行。查看预览器控制台，及flask端。 12345@app.route('/test',methods=['post'])def gat_cookies(): result = &quot;&quot;.join([i for i in request.form.items()][0]) print(result) return &quot;ok&quot; 五、结语油猴脚本是个很强大的浏览器辅助工具，而且相比于浏览器扩展，脚本更加轻便，占用资源极小，却可以实现丰富的功能。并且还有很多做好的插件，其中的细节有兴趣的同学可以自己研究下。 12console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20220105/Tampermonkey%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8/"},{"title":"Simhash-文本相似度算法","text":"一、什么是simhashsimhash初衷是用于解决亿万级别的网页去重任务，simhash通常用于长文本，通过降维处理，将长文本压缩至几个关键词来代表一篇文章，然后再将这些关键词编码成一个固定长度的二进制字符串（一般为32位或是64位），这样即用一个固定长度的编码来表示一整篇文章，我们想要对比多篇文章，只需要对比这些固定长度的编码就可以了。 二、 SimHash流程实现 分词 把需要判断文本分词形成这个文章的特征单词。最后形成去掉噪音词的单词序列并为每个词加上权重，我们假设权重分为5个级别（1~5）。 比如：“ 美国“51区”雇员称内部有9架飞碟，曾看见灰色外星人 ” ==&gt; 分词后为 “ 美国（4） 51区（5） 雇员（3） 称（1） 内部（2） 有（1） 9架（3） 飞碟（5） 曾（1） 看见（3） 灰色（4） 外星人（5）”，括号里是代表单词在整个句子里重要程度，数字越大越重要。 hash 通过hash算法把每个词变成hash值，比如“美国”通过hash算法计算为 100101,“51区”通过hash算法计算为 101011。这样我们的字符串就变成了一串串数字，还记得文章开头说过的吗，要把文章变为数字计算才能提高相似度计算性能，现在是降维过程进行时。 加权 通过 2步骤的hash生成结果，需要按照单词的权重形成加权数字串，比如“美国”的hash值为“100101”，通过加权计算为“4 -4 -4 4 -4 4”；“51区”的hash值为“101011”，通过加权计算为 “ 5 -5 5 -5 5 5”。 合并 把上面各个单词算出来的序列值累加，变成只有一个序列串。比如 “美国”的 “4 -4 -4 4 -4 4”，“51区”的 “ 5 -5 5 -5 5 5”， 把每一位进行累加， “4+5 -4+-5 -4+5 4+-5 -4+5 4+5” ==》 “9 -9 1 -1 1 9”。这里作为示例只算了两个单词的，真实计算需要把所有单词的序列串累加。 降维 把4步算出来的 “9 -9 1 -1 1 9” 变成 0 1 串，形成我们最终的simhash签名。 如果每一位大于0 记为 1，小于0 记为 0。最后算出结果为：“1 0 1 0 1 1”。","link":"/20211222/Simhash-%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E7%AE%97%E6%B3%95/"},{"title":"Unidbg(一)环境安装及配置","text":"一、环境准备1、IntelliJ IDEA直接官网下载就可以 2、Maven环境官网：https://maven.apache.org/download.cgi 解压文件： 1tar -zxvf apache-maven-3.5.4-bin.tar.gz 配置环境变量： 12export MAVEN_HOME=/usr/local/apache-maven-3.8.4export PATH=$MAVEN_HOME/bin:$PATH 测试是否配置成功：mvn -version配置maven 二、导入代码1git clone https://github.com/zhkl0228/unidbg.git 等待加载完成后，运行下例子，运行成功就代表配置完成 12console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20211207/Unidbg-%E4%B8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/"},{"title":"WX注入原理","text":"一、注入原理 在 Windows 系统中，每个 .exe 文件在双击打开时都会加载 kernel32.dll 这个系统模块，该模块中有一个 LoadLibrary() 函数，可以将DLL文件加载到自身进程中。 用 CreateRemoteThread() 函数创建一个远程线程，让目标进程调用LoadLibrary() 来加载我们自己写的DLL 。CreateRemoteThread() 有这几个参数比较关键：A:想要注入的进程的句柄，这里可以通过OpenProcess()得到； B:想要运行的函数，本例中当然是 LoadLibrary() 啦； C: 所运行函数的参数，本例中是自己写的DLL的存放路径。 这就需要在内存中开辟一块空间，把路径写入进去。这要先用 VirtualAllocEx(）开辟一块空间，然后用WriteProcessMemory() 函数把DLL路径写进去。 总结：先在目标进程的内存空间里开辟一块新地方，往新地方里面写入DLL的路径，再创建远程线程找到LoadLibrary() 函数，并在刚才开辟的新地方中读取DLL路径，进而加载我们自己写的DLL。 二、构成1、注入器 遍历系统中的进程，找到微信进程（CreateToolhelp32Snapshot、Process32Next） 打开微信进程，获得HANDLE（OpenProcess） 在微信进程中为DLL文件路径字符串申请内存空间（VirtualAllocEx） 把DLL文件路径字符串写入到申请的内存中（WriteProcessMemory） 从Kernel32.dll中获取LoadLibraryA的函数地址（GetModuleHandle、GetProcAddress） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 伪代码// 1、遍历系统中的进程，找到微信进程（CreateToolhelp32Snapshot、Process32Next）//CreateToolhelp32Snapshot 获取指定进程的快照，以及这些进程使用的堆、模块和线程。HANDLE handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);//将设置格式的数据写入字符串 buff中swprintf_s(buff,L&quot;CreateToolhelp32Snapshot=%p&quot;, handle);//输出调试字符串OutputDebugString(buff);//定义结构体PROCESSENTRY32 processentry32 = { 0 };processentry32.dwSize = sizeof(PROCESSENTRY32);//检索有关记录在系统快照中的下一个进程的信息BOOL next = Process32Next(handle, &amp;processentry32);while (next == TRUE){ if (wcscmp(processentry32.szExeFile, L&quot;WeChat.exe&quot;) == 0) { weChatProcessID = processentry32.th32ProcessID; break; } next = Process32Next(handle, &amp;processentry32);}//2、打开微信进程，获得HANDLE（OpenProcess）// PROCESS_ALL_ACCESS 过程对象的所有可能访问权限// weChatProcessID 要打开的本地进程的标识符HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, weChatProcessID);//3、在微信进程中为DLL文件路径字符串申请内存空间（VirtualAllocEx）//VirtualAllocEx 在指定进程的虚拟地址空间内保留，提交或更改内存区域的状态。该函数将其分配的内存初始化为零//如果函数成功，则返回值是页面分配区域的基地址LPVOID allocAddress = VirtualAllocEx(hProcess, NULL, strSize, MEM_COMMIT, PAGE_READWRITE);if (allocAddress == NULL){ MessageBox(NULL, L&quot;申请内存空间失败&quot;, L&quot;提示&quot;, MB_OK); return 0;}swprintf_s(buff, L&quot;VirtualAllocEx=%p&quot;, allocAddress);//输出调试字符串OutputDebugString(buff);//4、把DLL文件路径字符串写入到申请的内存中（WriteProcessMemory）BOOL result = WriteProcessMemory(hProcess, allocAddress, DllFileName, strSize, NULL);if (result == FALSE){ MessageBox(NULL, L&quot;DLL文件路径字符串写入到申请的内存中失败&quot;, L&quot;提示&quot;, MB_OK); return 0;}//5、从Kernel32.dll中获取LoadLibraryA的函数地址（GetModuleHandle、GetProcAddress）HMODULE hMODULE = GetModuleHandle(L&quot;Kernel32.dll&quot;);FARPROC fARPROC = GetProcAddress(hMODULE, &quot;LoadLibraryA&quot;);//6、在微信中启动内存中指定了文件名路径的DLL（CreateRemoteThread）。//也就是调用DLL中的DllMain（以DLL_PROCESS_ATTACH为参数）。HANDLE hANDLE = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)fARPROC, allocAddress, 0, NULL); 2、Dll文件 获取WeChatWin.dll的基址 hook指定地址改变函数 保存当前寄存器状况方便恢复现场 跳转至自己的逻辑 恢复现场 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167// 伪代码// DLL入口函数BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ switch (ul_reason_for_call) { // 当DLL注入时候执行逻辑 case DLL_PROCESS_ATTACH: { HANDLE hANDLE = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ShowDemoUI, hModule, NULL, 0); if (hANDLE != 0) { CloseHandle(hANDLE); } break; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;}VOID ShowDemoUI(HMODULE hModule){ // 获取WeChatWin.dll的基址 wxBaseAddress = (DWORD)GetModuleHandle(TEXT(&quot;WeChatWin.dll&quot;)); string text = &quot;微信基址：\\t&quot;; text.append(Dec2Hex(wxBaseAddress)); DialogBox(hModule, MAKEINTRESOURCE(IDD_MAIN), NULL, &amp;DialogProc);}//窗口回调函数，处理窗口事件INT_PTR CALLBACK DialogProc(_In_ HWND hwndDlg, _In_ UINT uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam){ hWinDlg = hwndDlg; switch (uMsg) { case WM_INITDIALOG: break; case WM_CLOSE: //关闭窗口事件 EndDialog(hwndDlg, 0); break; case WM_COMMAND: //接收消息 if (wParam == ID_START) { HookWx(); HWND hEditor = GetDlgItem(hwndDlg, IDC_MSG); SetWindowText(hEditor, TEXT(&quot;开始准备接收微信消息......\\r\\n&quot;)); break; } //停止接收 if (wParam == ID_STOP) { OutputDebugString(TEXT(&quot;停止接收按钮被点击&quot;)); UnHookWx(); HWND hFileHelper = GetDlgItem(hwndDlg, IDC_MSG); SetWindowText(hFileHelper, TEXT(&quot;停止准备接收微信消息......&quot;)); break; } //ID_UNLODA if (wParam == ID_UNLOAD) { //EndDialog(hwndDlg, 0); UnHookWx(); UnLoadMyself(); break; } default: break; } return FALSE;}// Hook接收消息VOID HookWx(){ if (isWxHooked == FALSE) { isWxHooked = TRUE; // hook地址 int hookAddress = wxBaseAddress + 0x4112FB; // 跳回的地址 jumBackAddress = wxBaseAddress + 0x411300; // 组装跳转数据 BYTE jmpCode[5] = { 0 }; jmpCode[0] = 0xE9; // 新跳转指令中的数据=跳转的地址-原地址（HOOK的地址）-跳转指令的长度 *(DWORD*)&amp;jmpCode[1] = (DWORD)RecieveMsgHook - hookAddress - 5; // 保存当前位置的指令,在unhook的时候使用。 ReadProcessMemory(GetCurrentProcess(), (LPVOID)hookAddress, originalCode, 5, 0); // 覆盖指令 B9 E8CF895C //mov ecx,0x5C89CFE8 WriteProcessMemory(GetCurrentProcess(), (LPVOID)hookAddress, jmpCode, 5, 0); }}DWORD C_EAX;DWORD C_EBX;DWORD C_ECX;DWORD C_EDX;DWORD C_ESI;DWORD C_EDI;DWORD C_EBP;DWORD C_ESP;// 跳转到这里，让我们自己处理消息__declspec(naked) VOID RecieveMsgHook(){ __asm { //保存寄存器 mov C_EAX, eax mov C_EBX, ebx mov C_ECX, ecx mov C_EDX, edx mov C_ESI, esi mov C_EDI, edi mov C_EBP, ebp mov C_ESP, esp mov r_esp, esp } //调用接收消息的函数 //RecieveMsg(); //起一个线程去做 CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)RecieveMsg, NULL,NULL, NULL); //恢复现场 __asm { mov eax, C_EAX mov ebx, C_EBX mov ecx, C_ECX mov edx, C_EDX mov esi, C_ESI mov edi, C_EDI mov ebp, C_EBP mov esp, C_ESP //跳回被HOOK指令的下一条指令 //07DD0000 - B9 C8FB0B5E - mov ecx, WeChatWin.dll + 1DDFBC8{ (5DD09EA0) } //07DD0005 - E9 F0129254 - jmp WeChatWin.dll + 4112FA call dword ptr[eax + 0x08] push edi push ecx jmp jumBackAddress }} 三、wx多开在Windows系统里面要实现单实例运行，基本都是用互斥体来实现的。互斥体，只能同时被一个线程持有， 只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。 微信的Mutex名字是：**_WeChat_App_Instance_Identity_Mutex_Name** 1、修改WeChatWin.dll修改字节，改变Mutex名字。 2、Hook内存","link":"/20211222/WX%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"},{"title":"smali语法基础详解","text":"一、介绍apk文件通过apktool反编译出来的都有一个smali文件夹，里面都是以.smali结尾的文件。smali语言是Davlik的寄存器语言，语法上和汇编语言相似，Dalvik VM与JVM的最大的区别之一就是Dalvik VM是基于寄存器的。基于寄存器的意思是，在smali里的所有操作都必须经过寄存器来进行。 二、类型Java中的基本数据类型与Dalvik字节码类型的对应关系| Dalvik | Java || —— | ——- || B | byte || C | char || D | double || F | float || I | int || S | short || V | void || J | long || Z | boolean | *注意J、Z两个不是对应类型的首字母；在dalvik字节码中，寄存器都是32位的，能够支持任何类型，Long和Double类型是64位的，需要2个寄存器；V 只能用于返回值类型； 三、描述类的信息在打开smali文件的时候，它的头三行描述了当前类的一些信息 .class &lt; 访问权限&gt; [ 修饰关键字] &lt; 类名&gt; .super &lt; 父类名&gt;.source &lt;源文件名&gt;.class指令表示当前的类名，类的访问权限是public，类名为LHelloWorld，类开头的L表示后面跟随的字符串是一个类。.super指定了当前类所继承的父类，后面指的就是这个父类的类名，L表示后面跟的字符串是一个类.例： 123.class public Lcom/tt/android/xigua/detail/c/a$1;.super Ljava/lang/Object;.source &quot;SourceFile&quot; 四、静态字段#static fields .field &lt; 访问权限&gt; static [ 修饰关键字]&lt; 字段名&gt;:&lt; 字段类型&gt;baksmali在生成smali文件时，会在静态字段声明的起始处添加注释”static fields”，注释是以#开头。访问权限包括：private、protected、public修饰关键字为字段其他属性。例： 12# static fields.field public static a:Lcom/meituan/robust/ChangeQuickRedirect; 五、实例字段#instance fields .field &lt; 访问权限&gt; [ 修饰关键字] &lt; 字段名&gt;:&lt; 字段类型&gt;例： 12# instance fields.field final synthetic b:Lcom/tt/android/xigua/detail/c/a; 六、直接方法直接方法指的是该类中定义的方法。 #direct methods .method &lt;访问权限&gt; [ 修饰关键字] &lt; 方法原型&gt;、&lt;.registers&gt;、&lt;.locals&gt; [.param][.prologue][.line]&lt;代码体&gt; .end method例： 12345678910.method public f()Ljava/lang/String; .locals 4 .prologue .line 196608 const/4 v0, 0x0 …………………… .line 196609.end method #direct methods 是注释，是baksmali添加的，访问权限和修饰关键字 跟字段是一样的。方法原型 描述了方法的名称、参数与返回值。.registers 指令指定了方法中寄存器的总数,这个数量是参数和本地变量总和。.param 表明了方法的参数，每个.param指令表示一个参数，方法使用了几个参数就有几个.parameter指令。.prologue 指定了代码的开始处，混淆过的代码可能去掉了该指令。.line 指明了该处代码在源代码中的行号，同样，混淆后的代码可能去掉了行号。.local 使用这个指定表明方法中非参寄存器 七、虚方法虚方法指的是从父类中继承的方法或者实现的接口的方法，它的声明跟直接方法相同，只是起始的初始为“virtual methods”。 #virtual methods .method &lt;访问权限&gt; [ 修饰关键字] &lt; 方法原型&gt;&lt;.registers&gt;&lt;.locals&gt; [.param] [.prologue] [.line] &lt;代码体&gt;.end method 八、接口如果一个类实现了一个接口，那么会在smali文件中用.implements指令指出。 #interfaces .implements &lt; 接口名&gt;#interfaces是注释，.implements 是接口关键字，后面的接口名是 DexClassDef 结构中 interfacesOff 字段指定的内容 12# interfaces.implements Lcom/tt/floatwindow/video/a/d; 12console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20211110/smali%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"},{"title":"smali动态调式","text":"一、Android Studio 调试的原理使用 Android Studio 进行动态调试，通过 Android Studio 导入反编译出的完整的 smali 代码，设置好调试所需的条件，设置断点。将移动设备连接至 PC端，然后运行待调试的apk应用程序，当该应用程序执行流程，运行至smali代码的断点处时，就会触发断点。从而可以进行进一步的分析和调试，让程序的运行流程和中间参数更清晰。 二、流程1、待调试的apk设置debuggable=”true”使用AndroidKiller工具，反编译我们要调试的APK文件，反编译成功后，在“工程管理器”找到AndroidManiFest.xml文件，再找到该文件里的application标签，查看标签中是否存在android:debuggable=“true”属性，如果文件中不存在android:debuggable=“true”，则需要进行添加。 2、导入Project3、调试环境配置​ 配置远程调试的选项，选择Run–&gt;Edit Configurations选项， 点击“+”号，新建remote类型调试器，设置Name，修改端口号，可以选择未被占用的任意端口，本次设置为8700。 4、动态调试smali代码（1）普通模式调试查看app的进程pid 1adb shell ps 进行端口转发，其中的“tcp”是之前配置调试环境时指定的端口号：8700，“jdwp”这里指的是我们要调试的程序的进程pid 1adb forward tcp:8709 jdwp:4917 （2）调试模式启动应用程序调试1adb shell am start –D -n 应用程序包名/应用程序入口界面 查看app的进程pid 1adb shell ps 进行端口转发，其中的“tcp”是之前配置调试环境时指定的端口号：8700，“jdwp”这里指的是我们要调试的程序的进程pid 1adb forward tcp:8709 jdwp:4917 快捷键：F9：跳到下一个断点F8：单步步过F7：单步步入Alt+shift+F7:强制进入Shift+F8:单步步出","link":"/20210915/smali%E5%8A%A8%E6%80%81%E8%B0%83%E5%BC%8F/"},{"title":"xpath 骚操作清单","text":"一、xpath不匹配含有指定子节点或属性的节点1. 不匹配含有指定子节点的节点如，不匹配子节点含有 ‘i’ 节点的 ‘p’ 节点 1xpath('//p[not(i)]') 2. 不匹配含有指定属性的节点如，不匹配子节点含有 ‘class’ 属性的 ‘p’ 节点 1xpath('//p[not(@class)]') 3. 二者联合使用，不匹配含有指定子节点和属性的节点如，不匹配子节点含有 ‘i’ 节点和子节点含有 ‘class’ 属性的 ‘p’ 节点 1xpath('//p[not(i) and not(@class)]')","link":"/20210916/xpath-%E9%AA%9A%E6%93%8D%E4%BD%9C%E6%B8%85%E5%8D%95/"},{"title":"实战分析自毁程序Crackme IDA动态调试","text":"一、目标Crackme：https://github.com/404nofoundx/Cloud/blob/main/AliCrackme.zip 二、查看java代码二话不说上jadx，通过AndroidManifest.xml文件确定入口。 三、IDA静态分析 四、IDA动态分析打上断点 还没等到断点的时候，程序就崩溃了，猜测有反调试。 这次在JNI_OnLoad下断点，看看是哪里崩溃的，多次尝试发现在此处崩溃，用00000000修改此处命令。 修改前 修改后 反调试安全跳过，重新在Java_com_yaotong_crackme_MainActivity_securityCheck 设置断点。 查看R2寄存器 Flag = aiyou,bucuoo AliCrackme主要考验了过反调试和动态调试，还挺简单.jpg","link":"/20210917/%E5%AE%9E%E6%88%98%E5%88%86%E6%9E%90%E8%87%AA%E6%AF%81%E7%A8%8B%E5%BA%8FCrackme-IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"},{"title":"反制Unidbg","text":"一、JNI交互尽可能增加补JAVA环境所需的时间成本，打个比方，在SO中编写1000个对JAVA层的访问和调用函数，每次计算时根据时间戳使用其中的50个，这样做的话，运算的时间成本不高，但因为时间戳一直在变，所以得在Unidbg中补齐全量的JAVA访问。使用Unidbg暂不支持的JNI调用src/main/java/com/github/unidbg/linux/android/dvm/DalvikVM.java 是Unidbg中实现JNI方法的类，可以发现，只实现了最常用的那部分JNI方法，所以可以在样本中使用这些Unidbg尚未实现的JNI方法。 二、系统调用Unidbg实现了许多常见的系统调用，但还有一些偏冷门的系统调用未实现，以及不偏僻但较难完美实现的系统调用，典型代表——fork相关系统调用。 三、文件访问尽可能多的文件访问和交互 四、检测Unidbg样本可以感知并检测自己运行在Unidbg环境中，并走向错误的分支。这一块我的了解不多，但确实是可以的，Unidbg的执行环境和真机是有很大差距的。打个比方，每个Android进程都有一些初始化环境变量，Android系统启动时通过setEnv设置，Unidbg中则没有。 五、目标函数无法被单独执行尽其所能的增加目标函数被执行的”前置条件“，或者说初始化函数。这里面可以玩的花招、阴招太多了。这应该作为一个主要的反Unidbg的方向，它是有效且杀伤力巨大的。","link":"/20211214/%E5%8F%8D%E5%88%B6Unidbg/"},{"title":"某豆*__DATA__数据加密","text":"一、确定逻辑获取的数据复制给 window.__DATA__ 全局搜索，确定位置 跟进去发现，在这个位置生成数据 验证一下 二、调试巴拉巴拉 三、搭建解密服务123456789101112131415161718192021222324252627282930313233343536373839var r = &quot;WKVZcEaRd7/………………&quot;;var i = 16var Q = 4096var p = { start: 2, end: 7}var K = {}…………………………………………………………………………………………………………………………………………………此处省略N字……………………………………………………………………………………………………………………………………………………………………………………function decrypt(r) { var a = encry2arr_from(r, &quot;base64&quot;) // 0 , s = Math.max(Math.floor((a.length - 2 * i) / 3), 0) // 40 , u = a_slice(a, s, s + i); // 41 a = concat([a_slice(a, 0, s), a_slice(a, s + i)]); // 43 45 47 var c_data = hash(concat([u, encry2arr_from(&quot;&quot;)])); // 49 67 69 var l = {} l[c_data] = a var data = n_n((l = {}, l[c_data] = a, l)) // console.log(data) // console.log(data.payload.items[0]) var d_temp = data.payload.items var ret_val = JSON.stringify(d_temp) return ret_val}function get_page(arg){ console.log(arg) return decrypt(arg)}module.exports = { get_page} spider_server.js 12345678910111213141516var express = require('express');var douban = require('./douban');var app = express();const multipart = require('connect-multiparty')const multipartyMiddleware = multipart()app.post('/douban', multipartyMiddleware, (req, res) =&gt; { console.log(req) var result = douban.get_page(req.body.p1) res.send(result)})app.listen(23341, function () {}) 123全部代码放在百度云盘了链接：https://pan.baidu.com/s/1Gshwaeg8sKnb6Nx1PEI1Vw 提取码：6666 123console.log(&quot;wx:spiderskill&quot;)console.log(&quot;公众号:虫术&quot;)Blog:http://404nofoundx.top/","link":"/20211203/%E6%9F%90%E8%B1%86-DATA-%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/"},{"title":"正则及XPath基础文档","text":"一、正则表达式匹配规则 模 式 描 述 \\w 匹配字母、数字及下划线 \\W 匹配不是字母、数字及下划线的字符 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f] \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9] \\D 匹配任意非数字的字符 \\A 匹配字符串开头 \\Z 匹配字符串结尾，如果存在换行，只匹配到换行前的结束字符串 \\z 匹配字符串结尾，如果存在换行，同时还会匹配换行符 \\G 匹配最后匹配完成的位置 \\n 匹配一个换行符 \\t 匹配一个制表符 ^ 匹配一行字符串的开头 $ 匹配一行字符串的结尾 . 匹配任意字符，除了换行符，当 re.DOTALL 标记被指定时，则可以匹配包括换行符的任意字符 […] 用来表示一组字符，单独列出，比如 [amk] 匹配 a、m 或 k [^…] 不在 [] 中的字符，比如 [^abc] 匹配除了 a、b、c 之外的字符 * 匹配 0 个或多个表达式 + 匹配 1 个或多个表达式 ? 匹配 0 个或 1 个前面的正则表达式定义的片段，非贪婪方式 {n} 精确匹配 n 个前面的表达式 {n, m} 匹配 n 到 m 次由前面正则表达式定义的片段，贪婪方式 ( ) 匹配括号内的表达式，也表示一个组 修饰符 修饰符 描 述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 匹配包括换行在内的所有字符 re.U 根据 Unicode 字符集解析字符。这个标志影响 \\w、\\W、\\b 和 \\B re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解 二、XPath常用规则 表 达 式 描 述 nodename 选取此节点的所有子节点 / 从当前节点选取直接子节点 // 从当前节点选取子孙节点 . 选取当前节点 .. 选取当前节点的父节点 @ 选取属性 节点轴| 表 达 式 | 描 述 || —————– | —————————— || ancestor | 祖先节点 || attribute | 获取所有属性值 || child | 获取所有直接子节点 || descendant | 获取所有子孙节点 || following | 当前节点之后的所有节点 || following-sibling | 获取当前节点之后的所有同级节点 |","link":"/20211110/%E6%AD%A3%E5%88%99%E5%8F%8AXPath%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3/"},{"title":"霸哥磁力搜索apk过签名校验","text":"一、什么是签名校验签名验证，就是在APP中写入自己私钥的hash值，和一个获取当前签名中的私钥hash值的函数两个值相一致，那么就说明APP没有被改动允许APP运行。 如果两值不一致那么说明APP是被二次打包的，APP就自我销毁进程。 签名验证可以在两个地方做，一个是在MainActivity.java的OnCreate函数中做，一个是在原生代码文件的JNI_OnLoad函数中做。 二、验证是否是签名校验用Android killer随意改下smail代码然后重新打包，发现APP闪退。 三、Jadx查看JAVA代码/IDA查看so签名校验一般都是在MainActivity.java的OnCreate函数中做，或者是在原生代码文件的JNI_OnLoad函数中做，首先查看OnCreate，里面有个qian，跟进去看看。 qian里面就是查看APP哈希值是否改变，这是第一个地方。 这里调用了一个bug，而bug写在了so里面，有很大嫌疑，ida看见这个so。 IDA查看bug这个函数采用的是静态注册，里面调用了一个getSignHashCode，跟进去看看。 四、过签名校验首先处理So文件，把exit换成nop，然后到处替换原来的so。 然后修改smail代码，把调用qian的地方给注释掉然后重新打包。 重打包后签名校验已经过掉了。","link":"/20211115/%E9%9C%B8%E5%93%A5%E7%A3%81%E5%8A%9B%E6%90%9C%E7%B4%A2apk%E8%BF%87%E7%AD%BE%E5%90%8D%E6%A0%A1%E9%AA%8C/"},{"title":"常见的几种DLL注入技术","text":"原文链接: https://bbs.pediy.com/thread-269910.htm 一、前言这次实验是在WIN7 X86系统上进程，使用的编译器是VS2017。 所谓的DLL注入，其实就是在其他的进程中把我们编写的DLL加载进去。如下图所示 而加载Dll的API就是LoadLibrary，它的参数是保存要加载的DLL的路径的地址。所以DLL注入的核心就是把要注入的DLL的路径写到目标进程中，然后在目标进程中调用LoadLibrary函数，并且指定参数为保存了DLL路径的地址。 要实现DLL注入，首先就要创建一个用来注入的DLL。在VS2017中要生成一个DLL项目，只需要向下图这样创建一个DLL工程就好 在生成的文件中，有个dllmain.cpp，打开以后内容如下 当DLL的状态发生变化的时候，就会调用DllMain函数。而传递的ul_reason_for_call这个参数代表了4种不同的状态变化的情况，我们就可以根据这四种不同的状态根据需要来写出相应的代码，就会让注入的DLL执行我们需要的功能 ul_reason_for_call的值 代表的状态 DLL_PROCESS_ATTACH Dll刚刚映射到进程空间中 DLL_THREAD_ATTACH 进程中有新线程创建 DLL_THREAD_DETACH 进程中有新线程销毁 DLL_PROCESS_DETACH Dll从进程空间中接触映射 不过在实现DLL注入的时候用的DLL几乎都是在Dll刚刚映射到进程空间的时候就执行相关的代码。比如像下面这样，创建一个新线程来执行代码，这里在桌面打开一个文件来并写入加载这个DLL的进程的完成路径名。由于是独占方式打开，此时如果多个线程同时打开这个文件，CreateFile就会出错，错误码就会是32，根据这个来对线程进行休眠，等其他线程使用完了，再次打开文件进行操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &lt;Windows.h&gt;#include &lt;Shlobj.h&gt;#pragma comment(lib, &quot;shell32.lib&quot;) #define FILE_NAME &quot;result.txt&quot; DWORD WINAPI ThreadProc(LPVOID lpParameter){ HANDLE hFile = NULL; CHAR szDesktopFile[MAX_PATH] = { 0 }; //保存系统桌面路径 CHAR szFullFilePath[MAX_PATH] = { 0 }; //保存完成的加载DLL文件的文件路径 DWORD dwRetLen = 0, dwFileLen = 0; BOOL bRet = TRUE; //获取桌面路径 bRet = SHGetSpecialFolderPath(NULL, szDesktopFile, CSIDL_DESKTOP, TRUE); if (bRet) { strcat(szDesktopFile, &quot;\\\\&quot;); strcat(szDesktopFile, FILE_NAME); while (TRUE) { hFile = CreateFile( szDesktopFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) //打开文件错误 { if (GetLastError() == 32) //错误码是不是其他进程正在使用这个文件,是的话等待一会在继续打开 { Sleep(200); continue; } else break; } else { GetModuleFileName(NULL, szFullFilePath, MAX_PATH); //获取加载DLL的进程的完整路径 dwFileLen = strlen(szFullFilePath); szFullFilePath[dwFileLen] = '\\r'; //由于是在WIN7运行，换行符是\\r\\n szFullFilePath[dwFileLen + 1] = '\\n'; SetFilePointer(hFile, 0, NULL, FILE_END); WriteFile(hFile, szFullFilePath, dwFileLen + 2, &amp;dwRetLen, NULL); if (hFile) CloseHandle(hFile); break; } } } return 0;} BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ){ switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); if (hThread) CloseHandle(hThread); break; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE;} 点击生成解决方案以后就可以在项目目录下找到相应的DLL文件，如下图。这个文件就是用来注入到其他进程的DLL。 二、代码框架由于要编写的代码中，只有注入功能不同，但是其他的辅助功能。比如，提权，获取进程PID等等是一样的，为了避免重复就先在这给出代码的框架。后面的不同注入技术只需根据需要加进去就好。注意，如果想要提权成功，需要用管理员权限运行代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;cstdio&gt;#include &lt;Windows.h&gt;#include &lt;TlHelp32.h&gt; #define PROCESS_NAME &quot;taskmgr.exe&quot; //要注入的进程名，这个是任务管理器的进程名#define DLL_NAME &quot;InjectDll.dll&quot; //要注入的DLL的名称 BOOL InjectDll(DWORD dwPid, CHAR szDllName[]); //注入DLLDWORD GetPID(PCHAR pProName); //根据进程名获取PIDVOID ShowError(PCHAR msg); //打印错误信息BOOL EnbalePrivileges(HANDLE hProcess, char *pszPrivilegesName); //提升进程权限 int main(){ CHAR szDllPath[MAX_PATH] = { 0 }; //保存要注入的DLL的路径 DWORD dwPID = 0; //保存要注入的进程的PID // 提升当前进程令牌权限 if (!EnbalePrivileges(GetCurrentProcess(), SE_DEBUG_NAME)) { printf(&quot;权限提升失败\\n&quot;); } dwPID = GetPID(PROCESS_NAME); if (dwPID == 0) { printf(&quot;没有找到要注入的进程\\n&quot;); goto exit; } GetCurrentDirectory(MAX_PATH, szDllPath); //获取程序的目录 strcat(szDllPath, &quot;\\\\&quot;); strcat(szDllPath, DLL_NAME); //与DLL名字拼接得到DLL的完整路径 printf(&quot;要注入的进程名:%s PID:%d\\n&quot;, PROCESS_NAME, dwPID); printf(&quot;要注入的DLL的完整路径%s\\n&quot;, szDllPath); if (InjectDll(dwPID, szDllPath)) { printf(&quot;Dll注入成功\\n&quot;); }exit: system(&quot;pause&quot;); return 0;} BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; return bRet;} DWORD GetPID(PCHAR pProName){ PROCESSENTRY32 pe32 = { 0 }; HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); BOOL bRet = FALSE; DWORD dwPID = 0; if (hSnap == INVALID_HANDLE_VALUE) { printf(&quot;CreateToolhelp32Snapshot process %d\\n&quot;, GetLastError()); goto exit; } pe32.dwSize = sizeof(pe32); bRet = Process32First(hSnap, &amp;pe32); while (bRet) { if (lstrcmp(pe32.szExeFile, pProName) == 0) { dwPID = pe32.th32ProcessID; break; } bRet = Process32Next(hSnap, &amp;pe32); } CloseHandle(hSnap);exit: return dwPID;} VOID ShowError(PCHAR msg){ printf(&quot;%s Error %d\\n&quot;, msg, GetLastError());} BOOL EnbalePrivileges(HANDLE hProcess, char *pszPrivilegesName){ HANDLE hToken = NULL; LUID luidValue = { 0 }; TOKEN_PRIVILEGES tokenPrivileges = { 0 }; BOOL bRet = FALSE; DWORD dwRet = 0; // 打开进程令牌并获取具有 TOKEN_ADJUST_PRIVILEGES 权限的进程令牌句柄 if (!OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) { ShowError(&quot;OpenProcessToken&quot;); goto exit; } // 获取本地系统的 pszPrivilegesName 特权的LUID值 if (!LookupPrivilegeValue(NULL, pszPrivilegesName, &amp;luidValue)) { ShowError(&quot;LookupPrivilegeValue&quot;); goto exit; } // 设置提升权限信息 tokenPrivileges.PrivilegeCount = 1; tokenPrivileges.Privileges[0].Luid = luidValue; tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; // 提升进程令牌访问权限 if (!AdjustTokenPrivileges(hToken, FALSE, &amp;tokenPrivileges, 0, NULL, NULL)) { ShowError(&quot;AdjustTokenPrivileges&quot;); goto exit; } else { // 根据错误码判断是否特权都设置成功 dwRet = ::GetLastError(); if (ERROR_SUCCESS == dwRet) { bRet = TRUE; goto exit; } else if (ERROR_NOT_ALL_ASSIGNED == dwRet) { ShowError(&quot;ERROR_NOT_ALL_ASSIGNED&quot;); goto exit; } }exit: return bRet;} 三、远程线程注入这种注入方式可以说是最常用的注入方式了，它的核心就是调用Windows提供的CreateRemoteThread函数。该函数可以在其他的进程空间中创建一个新的线程进行执行，该函数在文档中的定义如下 12345678HANDLE WINAPI CreateRemoteThread( __in HANDLE hProcess, __in LPSECURITY_ATTRIBUTES lpThreadAttributes, __in SIZE_T dwStackSize, __in LPTHREAD_START_ROUTINE lpStartAddress, __in LPVOID lpParameter, __in DWORD dwCreationFlags, __out LPDWORD lpThreadId); 参数 说明 hProcess 要创建线程的进程句柄 lpThreadAttributes 新线程的安全描述符 dwStackSize 堆栈起始大小，为0表示默认大小 lpStartAddress 表示要运行线程的起始地址 lpParameter 保存要传递给线程参数的地址 dwCreationFlags 控制线程创建的标志，为0表示创建后立即执行 lpThreadId 指向接收线程标识符变量的指针。为NULL表示不返回线程标识符 其中的关键三个参数分别是 hProcess用来指定在哪个进程中创建新线程 lpStartAddress用来指定将进程中的哪个地址开始作为新线程运行的起始地址 lpParameter保存的也是一个地址，这个地址中保存的就是新线程要用到的参数 那也就是说只要我们指定了一个地址给lpStartAddress，那么我们就可以在其他进程中创建一个线程来执行程序。而再看加载DLL的LoadLibrary函数在文档中的定义如下 1HMODULE WINAPI LoadLibrary(__in LPCTSTR lpFileName); 可以看到，这个函数同样也只需要一个参数，这个参数是一个地址，而这个地址中保存的是我们要加载的DLL的名称的字符串。 根据这些，不难想到，只要我们可以获取新进程中的LoadLibrary函数的地址以及包含有要加载的DLL的字符串的地址就可以通过CreateRemoteThread函数来成功开起一个线程执行LoadLibrary函数来加载我们的DLL。 那么现在的问题就是如何获得LoadLibrary函数的地址以及保存有要加载的DLL路径的字符串的地址。 对于LoadLibrary函数，由于它是在常用的系统DLL，也就是KERNEL32.dll中，所以这个DLL是可以按照它的ImageBase成功装载到每个进程的空间中。这样的话Kernel32.dll在每个进程中的起始地址是一样的，那么LoadLibrary函数的地址也就会一样。那么我们就可以在本进程中查找LoadLibrary函数的地址，并且完全可以相信，在要注入DLL的进程中LoadLibrary的地址也是这个。 至于DLL名称的字符串，我们可以通过在进程中申请一块可以将DLL完整路径写入的内存，并在这个内存中将DLL的完整路径写入，将写入到注入进程DLL完整路径的内存地址作为参数就可以实现进程的注入。 具体代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HANDLE hProcess = NULL, hRemoteThread = NULL; HMODULE hKernel32 = NULL; DWORD dwSize = 0; LPVOID pDllPathAddr = NULL; PVOID pLoadLibraryAddr = NULL; // 打开注入进程，获取进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (NULL == hProcess) { ShowError(&quot;OpenProcess&quot;); bRet = FALSE; goto exit; } // 在注入进程中申请可以容纳DLL完成路径名的内存空间 dwSize = 1 + strlen(szDllName); pDllPathAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (!pDllPathAddr) { ShowError(&quot;VirtualAllocEx&quot;); bRet = FALSE; goto exit; } // 把DLL完整路径名写入进程中 if (!WriteProcessMemory(hProcess, pDllPathAddr, szDllName, dwSize, NULL)) { ShowError(&quot;WriteProcessMemory&quot;); bRet = FALSE; goto exit; } hKernel32 = LoadLibrary(&quot;kernel32.dll&quot;); if (hKernel32 == NULL) { ShowError(&quot;LoadLibrary&quot;); bRet = FALSE; goto exit; } // 获取LoadLibraryA函数地址 pLoadLibraryAddr = GetProcAddress(hKernel32, &quot;LoadLibraryA&quot;); if (pLoadLibraryAddr == NULL) { ShowError(&quot;GetProcAddress &quot;); bRet = FALSE; goto exit; } //创建远程线程进行DLL注入 hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryAddr, pDllPathAddr, 0, NULL); if (hRemoteThread == NULL) { ShowError(&quot;CreateRemoteThread&quot;); bRet = FALSE; goto exit; } exit: if (hKernel32) FreeLibrary(hKernel32); if (hProcess) CloseHandle(hProcess); if (hRemoteThread) CloseHandle(hRemoteThread); return bRet;} 四、加强版远程线程注入上面的方法虽然可以方便的注入DLL。但是在WIN7,WIN10系统上，会由于SESSION 0隔离机制从而导致只能成功注入普通的用户进程，如果注入系统进程就会导致失败。而经过逆向分析发现，使用Kernel32.dll中的CreateRemoteThread进行注入的时候，程序会走到ntdll.dll中的ZwCreateThreadEx函数进行执行。这是一个未导出的函数，所以需要手动获取函数地址来进行调用，相比于CreateRemoteThread更加底层。这个函数在64位和32位系统中的函数声明也不相同，在32位中的声明如下 123456789101112typedef DWORD(WINAPI *pFnZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, BOOL CreateSuspended, DWORD dwStackSize, DWORD dw1, DWORD dw2, LPVOID pUnkown); 而在64位中的声明如下 123456789101112typedef DWORD(WINAPI *pFnZwCreateThreadEx)( PHANDLE ThreadHandle, ACCESS_MASK DesiredAccess, LPVOID ObjectAttributes, HANDLE ProcessHandle, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, ULONG CreateThreadFlags, SIZE_T ZeroBits, SIZE_T StackSize, SIZE_T MaximumStackSize, LPVOID pUnkown); 根据逆向分析的结果，在内核6.0(WIN7, WIN10)等系统上调用CreateRemoteThread的时候，当程序走到ZwCreateThreaEx的时候它第7个参数，也就是CreateThreadFlags会被设置为1，如下图 它会导致线程创建的时候就被挂起，随后查看要运行的进程所在的会话层之后再决定是否要恢复线程的运行。所以要破解这种情况只需要将第7个参数设为0就可以，相应代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091typedef DWORD(WINAPI *pFnZwCreateThreadEx)(PHANDLE, ACCESS_MASK, LPVOID, HANDLE, LPTHREAD_START_ROUTINE, LPVOID, BOOL, DWORD, DWORD, DWORD, LPVOID); BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HANDLE hProcess = NULL, hRemoteThread = NULL; HMODULE hKernel32 = NULL, hNtDll = NULL; DWORD dwSize = 0; LPVOID pDllPathAddr = NULL; PVOID pLoadLibraryAddr = NULL; pFnZwCreateThreadEx ZwCreateThreadEx = NULL; // 打开注入进程，获取进程句柄 hProcess = ::OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (NULL == hProcess) { ShowError(&quot;OpenProcess&quot;); bRet = FALSE; goto exit; } // 在注入进程中申请可以容纳DLL完成路径名的内存空间 dwSize = 1 + strlen(szDllName); pDllPathAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (!pDllPathAddr) { ShowError(&quot;VirtualAllocEx&quot;); bRet = FALSE; goto exit; } // 把DLL完成路径名写入进程中 if (!WriteProcessMemory(hProcess, pDllPathAddr, szDllName, dwSize, NULL)) { ShowError(&quot;WriteProcessMemory&quot;); bRet = FALSE; goto exit; } hKernel32 = LoadLibrary(&quot;kernel32.dll&quot;); if (hKernel32 == NULL) { ShowError(&quot;LoadLibrary kernel32&quot;); bRet = FALSE; goto exit; } // 获取LoadLibraryA函数地址 pLoadLibraryAddr = GetProcAddress(hKernel32, &quot;LoadLibraryA&quot;); if (pLoadLibraryAddr == NULL) { ShowError(&quot;GetProcAddress LoadLibraryA&quot;); bRet = FALSE; goto exit; } hNtDll = LoadLibrary(&quot;ntdll.dll&quot;); if (hNtDll == NULL) { ShowError(&quot;LoadLibrary ntdll&quot;); bRet = FALSE; goto exit; } ZwCreateThreadEx = (pFnZwCreateThreadEx)GetProcAddress(hNtDll, &quot;ZwCreateThreadEx&quot;); if (!ZwCreateThreadEx) { ShowError(&quot;GetProcAddress ZwCreateThreadEx&quot;); bRet = FALSE; goto exit; } ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, NULL, hProcess, (LPTHREAD_START_ROUTINE)pLoadLibraryAddr, pDllPathAddr, 0, 0, 0, 0, NULL); if (hRemoteThread == NULL) { ShowError(&quot;ZwCreateThreadEx&quot;); bRet = FALSE; goto exit; }exit: if (hKernel32) FreeLibrary(hKernel32); if (hNtDll) FreeLibrary(hNtDll); if (hProcess) CloseHandle(hProcess); if (hRemoteThread) CloseHandle(hRemoteThread); return bRet;} 五、APC注入在Windows系统中，每个线程都会维护一个自己的APC队列，这个APC队列中保存了要求线程执行的一些APC函数。对于用户模式的APC队列，当线程处在可警告状态时，就会执行这些APC函数。而要往APC队列中增加APC函数，需要通过QueueUserAPC函数来实现，这个函数在文档中的定义如下 1234DWORD WINAPI QueueUserAPC( __in PAPCFUNC pfnAPC, __in HANDLE hThread, __in ULONG_PTR dwData); 参数 说明 pfnAPC 当满足条件时，要执行的APC函数的地址 hThread 指定增加APC函数的线程句柄 dwData 要执行的APC函数参数地址 可以看到pfnAPC和dwData这两个参数和CreateRemoteThread中的lpStartAddress和lpParameter的作用是一样的。不过这里是对线程进行操作，一个进程有多个线程。所以为了确保程序正确运行，所以需要遍历所有线程，查看是否是要注入的进程的线程，依次获得句柄插入APC函数。具体代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HANDLE hProcess = NULL, hThread = NULL, hSnap = NULL; HMODULE hKernel32 = NULL; DWORD dwSize = 0; PVOID pDllPathAddr = NULL; PVOID pLoadLibraryAddr = NULL; THREADENTRY32 te32 = { 0 }; // 打开注入进程，获取进程句柄 hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid); if (NULL == hProcess) { ShowError(&quot;OpenProcess&quot;); bRet = FALSE; goto exit; } // 在注入进程中申请可以容纳DLL完成路径名的内存空间 dwSize = 1 + strlen(szDllName); pDllPathAddr = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (!pDllPathAddr) { ShowError(&quot;VirtualAllocEx&quot;); bRet = FALSE; goto exit; } // 把DLL完成路径名写入进程中 if (!WriteProcessMemory(hProcess, pDllPathAddr, szDllName, dwSize, NULL)) { ShowError(&quot;WriteProcessMemory&quot;); bRet = FALSE; goto exit; } hKernel32 = LoadLibrary(&quot;kernel32.dll&quot;); if (hKernel32 == NULL) { ShowError(&quot;LoadLibrary&quot;); bRet = FALSE; goto exit; } // 获取LoadLibraryA函数地址 pLoadLibraryAddr = GetProcAddress(hKernel32, &quot;LoadLibraryA&quot;); if (pLoadLibraryAddr == NULL) { ShowError(&quot;GetProcAddress&quot;); bRet = FALSE; goto exit; } //获得线程快照 hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); if (!hSnap) { ShowError(&quot;CreateToolhelp32Snapshot&quot;); bRet = FALSE; goto exit; } //遍历线程 te32.dwSize = sizeof(te32); if (Thread32First(hSnap, &amp;te32)) { do { //这个线程的进程ID是不是要注入的进程的PID if (te32.th32OwnerProcessID == dwPid) { hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID); if (hThread) { QueueUserAPC((PAPCFUNC)pLoadLibraryAddr, hThread, (ULONG_PTR)pDllPathAddr); CloseHandle(hThread); hThread = NULL; } else { ShowError(&quot;OpenThread&quot;); bRet = FALSE; goto exit; } } } while (Thread32Next(hSnap, &amp;te32)); }exit: if (hKernel32) FreeLibrary(hKernel32); if (hProcess) CloseHandle(hProcess); if (hThread) CloseHandle(hThread); return bRet;} 六、AppInit_DLLs注入这种注入方式主要是通过修改注册表中HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows中的AppInit_DLLs和LoadAppInit_Dlls，如下图 只要将AppInit_DLLs设置为要注入的DLL的路径并且将LoadAppInit_DLLs的值改成1。那么，当程序重启的时候，所有加载user32.dll的进程都会根据AppInit_Dlls中的DLL路径加载指定的DLL。 所以这种DLL注入的实现代码如下 1234567891011121314151617181920212223242526272829303132333435BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HKEY hKey = NULL; CHAR szAppKeyName[] = { &quot;AppInit_DLLs&quot; }; CHAR szLoadAppKeyName[] = { &quot;LoadAppInit_DLLs&quot; }; DWORD dwLoadAppInit = 1; //设置LoadAppInit_DLLs的值 //打开相应注册表键 if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, &quot;Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Windows&quot;, 0, KEY_ALL_ACCESS, &amp;hKey) != ERROR_SUCCESS) { ShowError(&quot;RegOpenKeyEx&quot;); bRet = FALSE; goto exit; } //设置AppInit_DLLs为相应的DLL路径 if (RegSetValueEx(hKey, szAppKeyName, 0, REG_SZ, (PBYTE)szDllName, strlen(szDllName) + 1) != ERROR_SUCCESS) { ShowError(&quot;RegSetValueEx&quot;); bRet = FALSE; goto exit; } //将LoadAppInit_DLLs的值设为1 if (RegSetValueEx(hKey, szLoadAppKeyName, 0, REG_DWORD, (PBYTE)&amp;dwLoadAppInit, sizeof(dwLoadAppInit)) != ERROR_SUCCESS) { ShowError(&quot;RegSetValueEx&quot;); bRet = FALSE; goto exit; }exit: return bRet;} 运行程序以后，会发现相应的键值已经被设置 七、全局钩子注入Windows系统中的大多数应用都是基于消息机制的，也就是说它们都有一个消息过程函数，可以根据收到的不同消息来执行不同的代码。基于这种消息机制，Windows维护了一个OS message queue以及为每个程序维护着一个application message queue。当发生各种事件的时候，比如敲击键盘，点击鼠标等等，操作系统会从OS message queue将消息取出给到相应的程序的application message queue。 而OS message queue和application message queue的中间有一个称为钩链的结果如下 在这个钩链中保存的就是设置的各种钩子函数，而这些钩子函数会比应用程序还早接收到消息并对消息进行处理。所以程序员可以通过在钩子中设置钩子函数，而要设置钩子函数就需要使用SetWindowHookEx来将钩子函数安装到钩链中，函数在文档中的定义如下 1HHOOK SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hMod, DWORD dwThreadId); 参数 含义 idHook 要安装的钩子类型，为了挂全局钩子，这里选择WH_GETMESSAGE。表示的是安装一个挂钩过程，它监视发送到消息队列的消息 lpfn 表示的是钩子的回调函数。如果dwThreadId为0，则lpfn指向的钩子过程必须指向DLL中的钩子过程 hMod 包含由lpfn参数执行的钩子过程的DLL句柄 dwThreadId 与钩子过程关联的线程标识符，如果为0则表示与所有线程相关联。 如果函数成功，则返回钩子过程的句柄，否则为NULL。 根据上面的介绍可以得知，想要创建一个全局钩子，就必须在DLL文件中创建。这是因为进程的地址空间是独立的，发生对应事件的进程不能调用其他进程地址空间的钩子函数。如果钩子函数的实现代码在DLL中，则在对应事件发生时，系统会把这个DLL加载到发生事件的进程地址空间中，使它可以调用钩子函数进行处理。 所以只要在系统中安装了全局钩子，那么只要进程接收到可以发出钩子的消息，全局钩子的DLL就会被系统自动或者强行加载到进程空间中，这就可以实现DLL注入。 而这里之所以设置为WH_GETMESSAGE，是因为这种类型的钩子会监视消息队列，又因为Windows系统是基于消息驱动的，所以所有的进程都会有自己的一个消息队列，都会加载WH_GETMESSAGE类型的全局钩子。 当idHook设置为WH_GETMESSAGE的时候，回调函数lpfn的定义如下 123LRESULT CALLBACK GetMsgProc(int code, WPARAM wParam, LPARAM lParam); 参数 含义 code 指定钩子过程是否必须处理该消息。如果代码是HC_ACTION，则钩子过程必须处理该消息。如果代码小于零，则钩子过程必须将消息传递给CallNextHookEx函数而无需进一步处理，并且应该返回CallNextHookEx返回的值 wParam 指定消息是否已从队列中删除。此参数可以是以下值之一。PM_NOREMOVE:指定消息尚未从队列中删除PM_REMOVE:指定消息已从队列中删除 lParam 指向包含消息详细信息的MSG结构体的指针 如果要卸载钩子，则需要使用UnhookWindowsHookEx，该函数定义如下 1BOOL UnhookWindowsHookEx(HHOOK hhk); 参数 含义 hhk 需要卸载的钩子句柄。此参数是通过上一次调用SetWindowsHookEx获得的钩子句柄 由于设置全局钩子的代码需要在DLL文件中完成，所以首先需要新建一个InjectDll.cpp。 随后在文件中写入如下设置全局钩子的函数 1234567891011extern HMODULE g_hDllModule;// 设置全局钩子BOOL SetGlobalHook(){ g_hHook = SetWindowsHookEx(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, 0); if (NULL == g_hHook) { return FALSE; } return TRUE;} 其中的回调函数的实现如下 12345678// 钩子回调函数LRESULT GetMsgProc( int code, WPARAM wParam, LPARAM lParam){ return CallNextHookEx(g_hHook, code, wParam, lParam);} 这里只是简单的调用CallNextHookEx函数表示将当前钩子传递给钩链中的下一个钩子，第一个参数要指定当前钩子的句柄。如果直接返回0，则表示中断钩子传递，这就实现了对钩子进行拦截。 而g_hDllModule则是在DLL加载的时候被赋值的 当钩子不再使用，可以卸载掉全局钩子，这样此时已经包含钩子回调函数的DLL模块的进程就会释放DLL模块。卸载钩子的代码如下 123456789// 卸载钩子BOOL UnSetGlobalHook(){ if (g_hHook) { UnhookWindowsHookEx(g_hHook); } return TRUE;} 上面的全局钩子的设置，钩子回调函数的实现以及全局钩子的卸载都需要使用到全局钩子的句柄。为了让任意一个独立的进程中对句柄的修改都可以影响到其他进程，就需要在DLL中使用共享内存的，来保证将DLL中加载到多个进程以后，一个进程对它的修改可以影响到其他进程。设置共享内存的方式如下 12345// 共享内存#pragma data_seg(&quot;mydata&quot;)HHOOK g_hHook = NULL;#pragma data_seg()#pragma comment(linker, &quot;/SECTION:mydata,RWS&quot;) 而为了调用设置钩子和卸载钩子的函数，就需要创建一个.def文件来将两个函数导出 此时使用PEID查看InjectDll.dll可以看到导出表有如下的导出函数 接下来只要在代码中将DLL引入并或者对应的函数对它们进行调用就好 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647BOOL InjectDll(DWORD dwPid, CHAR szDllName[]){ BOOL bRet = TRUE; HMODULE hDll = NULL; pFnSetGlobalHook SetGlobalHook = NULL; pFnUnSetGlobalHook UnSetGlobalHook = NULL; hDll = LoadLibrary(szDllName); if (hDll == NULL) { ShowError(&quot;LoadLibrary&quot;); bRet = FALSE; goto exit; } SetGlobalHook = (pFnSetGlobalHook)GetProcAddress(hDll, &quot;SetGlobalHook&quot;); if (SetGlobalHook == NULL) { ShowError(&quot;GetProcAddress SetGlobalHook&quot;); bRet = FALSE; goto exit; } if (!SetGlobalHook()) { printf(&quot;钩子安装失败\\n&quot;); bRet = FALSE; goto exit; } printf(&quot;钩子安装成功,按回车卸载钩子\\n&quot;); system(&quot;pause&quot;); UnSetGlobalHook = (pFnUnSetGlobalHook)GetProcAddress(hDll, &quot;UnSetGlobalHook&quot;); if (UnSetGlobalHook == NULL) { ShowError(&quot;GetProcAddress UnSetGlobalHook&quot;); bRet = FALSE; goto exit; } if (UnSetGlobalHook()) { printf(&quot;已将全局钩子卸载\\n&quot;); }exit: return bRet;} 八、实验结果将编译好的exe文件和dll文件放到同一路径中，运行exe以后会在桌面生成一个result.txt文件。打开文件以后会看到里面的内容是被注入的进程的完整的路径名","link":"/20211220/%E8%BD%AC-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8DDLL%E6%B3%A8%E5%85%A5%E6%8A%80%E6%9C%AF/"},{"title":"安卓逆向Hook So","text":"原文链接: https://kevinspider.github.io/fridahookso/ 1、frida-envhttps://github.com/frida/frida-java-bridge/blob/master/lib/env.js 2、IDA判断Thumb指令集和Arm指令集 IDA - Options - General - number of opcode bytes - 设置为 4 此时查看 IDA VIew 中 opcode 的长度, 如果出现 2 个字节和 4 个字节的, 说明为 thumb 指令集 如果都是 4 个字节的, 说明是 arm 指令集; 在 Thumb 指令集下, inline hook 的偏移地址需要进行 +1 操作; 3、枚举内存中的so文件用于查看目标 module 是否被正常加载, 使用 Process.enumerateModules() 将当前加载的所有 so 文件打印出来 1234567891011function hook_native(){ var modules = Process.enumerateModules(); for (var i in modules){ var module = modules[i]; console.log(module.name); if (module.name.indexOf(&quot;target.so&quot;) &gt; -1 ){ console.log(module.base); } }} 4、获取指定 so 文件的基地址1234function hook_module() { var baseAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;); console.log(&quot;baseAddr&quot;, baseAddr);} 5、获取指定 so 文件的函数通过导出函数名定位 native 方法1234function hook_func_from_exports(){ var add_c_addr = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;add_c&quot;); console.log(&quot;add_c_addr is :&quot;,add_c_addr);} 通过 symbols 符号定位 native 方法123456789101112131415161718192021222324252627282930313233343536373839404142function find_func_from_symbols() { var NewStringUTF_addr = null; var symbols = Process.findModuleByName(&quot;libart.so&quot;).enumerateSymbols(); for (var i in symbols) { var symbol = symbols[i]; if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0 ){ if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;= 0) { console.log(&quot;find target symbols&quot;, symbol.name, &quot;address is &quot;, symbol.address); NewStringUTF_addr = symbol.address; } } } console.log(&quot;NewStringUTF_addr is &quot;, NewStringUTF_addr); Interceptor.attach(NewStringUTF_addr, { onEnter: function (args) { console.log(&quot;args0&quot;,args[0]) console.log(&quot;args0&quot;, args[0], hexdump(args[0])); console.log(&quot;args1&quot;, args[1], hexdump(args[1])); var env = Java.vm.tryGetEnv(); if (env != null) { // 直接读取 c 里面的 char console.log(&quot;Memory readCstring is :&quot;, Memory.readCString(args[1])); }else{ console.log(&quot;get env error&quot;); } }, onLeave: function (returnResult) { console.log(&quot;result: &quot;, Java.cast(returnResult, Java.use(&quot;java.lang.String&quot;))); var env = Java.vm.tryGetEnv(); if (env != null) { var jstring = env.newStringUtf(&quot;修改返回值&quot;); returnResult.replace(ptr(jstring)); } } })} 通过地址偏移 inline-hook 任意函数1234567891011121314151617181920212223242526272829function main(){ // get base address of target so; var libnative_lib_addr = Module.findBaseAddress(&quot;libnative-lib.so&quot;); console.log(&quot;base module addr -&gt;&quot;, libnative_lib_addr); if (libnative_lib_addr){ var add_addr1 = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;_Z5r0addii&quot;); var add_addr2 = libnative_lib_addr.add(0x94B2 + 1); // 32位需要加1 console.log(add_addr1); console.log(add_addr2); } // 主动调用 var add1 = new NativeFunction(add_addr1, &quot;int&quot;, [&quot;int&quot;, &quot;int&quot;]); var add2 = new NativeFunction(add_addr2, &quot;int&quot;, [&quot;int&quot;, &quot;int&quot;]); console.log(&quot;add1 result is -&gt;&quot; + add1(10, 20)); console.log(&quot;add2 result is -&gt;&quot; + add2(10, 20));}setImmediate(main);/*base module addr -&gt; 0xd430b0000xd43144b30xd43144b3add1 result is -&gt;30add2 result is -&gt;30*/ 6、通过 Intercept 拦截器打印 native 方法参数和返回值, 并修改返回值 onEnter: 函数(args) : 回调函数, 给定一个参数 args, 用于读取或者写入参数作为 NativePointer 对象的指针; onLeave: 函数(retval) : 回调函数给定一个参数 retval, 该参数是包含原始返回值的 NativePointer 派生对象; 可以调用 retval.replace(1234) 以整数 1234 替换返回值, 或者调用retval.replace(ptr(&quot;0x1234&quot;)) 以替换为指针; 注意: retval 对象会在 onLeave 调用中回收, 因此不要将其存储在回调之外使用, 如果需要存储包含的值, 需要制作深拷贝, 如 ptr(retval.toString()) 12345678910111213141516171819function find_func_from_exports() { var add_c_addr = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;add_c&quot;); console.log(&quot;add_c_addr is :&quot;,add_c_addr); // 添加拦截器 Interceptor.attach(add_c_addr,{ // 打印入参 onEnter: function (args) { console.log(&quot;add_c called&quot;); console.log(&quot;arg1:&quot;,args[0].toInt32()); console.log(&quot;arg2&quot;, args[1].toInt32()); }, // 打印返回值 onLeave: function (returnValue) { console.log(&quot;add_c result is :&quot;, returnValue.toInt32()); // 修改返回值 returnValue.replace(100); } })} 7、通过 Intercept 拦截器替换原方法123456789101112131415161718function frida_Interceptor() { Java.perform(function () { //这个c_getSum方法有两个int参数、返回结果为两个参数相加 //这里用NativeFunction函数自己定义了一个c_getSum函数 var add_method = new NativeFunction(Module.findExportByName('libhello.so', 'c_getSum'), 'int',['int','int']); //输出结果 那结果肯定就是 3 console.log(&quot;result:&quot;,add_method(1,2)); //这里对原函数的功能进行替换实现 Interceptor.replace(add_method, new NativeCallback(function (a, b) { //h不论是什么参数都返回123 return 123; }, 'int', ['int', 'int'])); //再次调用 则返回123 console.log(&quot;result:&quot;,add_method(1,2)); });} 8、so 层方法注册到 js 中, 主动调用1new NativeFunction(address, returnType, argTypes[, options]) address : 函数地址 returnType : 指定返回类型 argTypes : 数组指定参数类型 类型可选: void, pointer, int, uint, long, ulong, char, uchar, float, double, int8, uint8, int16, int32, uint32, int64, uint64; 参照函数所需的 type 来定义即可; 12345678910function invoke_native_func() { var baseAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;); console.log(&quot;baseAddr&quot;, baseAddr); var offset = 0x0000A28C + 1; var add_c_addr = baseAddr.add(offset); var add_c_func = new NativeFunction(add_c_addr, &quot;int&quot;, [&quot;int&quot;,&quot;int&quot;]); var result = add_c_func(1, 2); console.log(result);} 1234567891011121314Java.perform(function () { // 获取 so 文件基地址 var base = Module.findBaseAddress(&quot;libnative-lib.so&quot;); // 获取目标函数偏移 var sub_834_addr = base.add(0x835) // thumb 需要 +1 // 使用 new NativeFunction 将函数注册到 js var sub_834 = new NativeFunction(sub_834_addr, 'pointer', ['pointer']); // 开辟内存, 创建入参 var arg0 = Memory.alloc(10); ptr(arg0).writeUtf8String(&quot;123&quot;); var result = sub_834(arg0); console.log(&quot;result is :&quot;, hexdump(result));}) 9、hook libart 中的 jni 方法jni 全部定在在 /system/lib(64)/libart.so 文件中, 通过枚举 symbols 筛选出指定的方法 12345678910111213141516171819202122232425262728293031323334353637function hook_libart() { var GetStringUTFChars_addr = null; // jni 系统函数都在 libart.so 中 var module_libart = Process.findModuleByName(&quot;libart.so&quot;); var symbols = module_libart.enumerateSymbols(); for (var i = 0; i &lt; symbols.length; i++) { var name = symbols[i].name; if ((name.indexOf(&quot;JNI&quot;) &gt;= 0) &amp;&amp; (name.indexOf(&quot;CheckJNI&quot;) == -1) &amp;&amp; (name.indexOf(&quot;art&quot;) &gt;= 0)) { if (name.indexOf(&quot;GetStringUTFChars&quot;) &gt;= 0) { console.log(name); // 获取到指定 jni 方法地址 GetStringUTFChars_addr = symbols[i].address; } } } Java.perform(function(){ Interceptor.attach(GetStringUTFChars_addr, { onEnter: function(args){ // console.log(&quot;args[0] is : &quot;, args[0]); // console.log(&quot;args[1] is : &quot;, args[1]); console.log(&quot;native args[1] is :&quot;,Java.vm.getEnv().getStringUtfChars(args[1],null).readCString()); console.log('GetStringUTFChars onEnter called from:\\n' + Thread.backtrace(this.context, Backtracer.FUZZY) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); // console.log(&quot;native args[1] is :&quot;, Java.cast(args[1], Java.use(&quot;java.lang.String&quot;))); // console.log(&quot;native args[1] is :&quot;, Memory.readCString(Java.vm.getEnv().getStringUtfChars(args[1],null))); }, onLeave: function(retval){ // retval const char* console.log(&quot;GetStringUTFChars onLeave : &quot;, ptr(retval).readCString()); } }) })} 10、hook libc 中的系统方法/system/lib(64)/libc.so 导出的符号没有进行 namemanline , 直接过滤筛选即可 123456789101112131415161718192021222324// hook libc.sovar pthread_create_addr = null;// console.log(JSON.stringify(Process.enumerateModules())); // Process.enumerateModules() 枚举加载的so文件var symbols = Process.findModuleByName(&quot;libc.so&quot;).enumerateSymbols();for (var i = 0; i &lt; symbols.length; i++){ if (symbols[i].name === &quot;pthread_create&quot;){ // console.log(&quot;symbols name is -&gt; &quot; + symbols[i].name); // console.log(&quot;symbols address is -&gt; &quot; + symbols[i].address); pthread_create_addr = symbols[i].address; }}Interceptor.attach(pthread_create_addr,{ onEnter: function(args){ console.log(&quot;args is -&gt;&quot; + args[0], args[1], args[2],args[3]); }, onLeave: function(retval){ console.log(retval); }});} libc.so 中方法替换 1234567891011121314151617181920212223242526272829303132333435// hook 检测frida 的方法function main() { // var exports = Process.findModuleByName(&quot;libnative-lib.so&quot;).enumerateExports(); 导出 // var imports = Process.findModuleByName(&quot;libnative-lib.so&quot;).enumerateImports(); 导入 // var symbols = Process.findModuleByName(&quot;libnative-lib.so&quot;).enumerateSymbols(); 符号 var pthread_create_addr = null; var symbols = Process.getModuleByName(&quot;libc.so&quot;).enumerateSymbols(); for (var i = 0; i &lt; symbols.length; i++) { var symbol = symbols[i]; if (symbol.name === &quot;pthread_create&quot;) { pthread_create_addr = symbol.address; console.log(&quot;pthread_create name is -&gt;&quot;, symbol.name); console.log(&quot;pthread_create address is -&gt;&quot;, pthread_create_addr); } } Java.perform(function(){ // 定义方法 之后主动调用的时候使用 var pthread_create = new NativeFunction(pthread_create_addr, 'int', ['pointer', 'pointer','pointer','pointer']) Interceptor.replace(pthread_create_addr,new NativeCallback(function (a0, a1, a2, a3) { var result = null; var detect_frida_loop = Module.findExportByName(&quot;libnative-lib.so&quot;, &quot;_Z17detect_frida_loopPv&quot;); console.log(&quot;a0,a1,a2,a3 -&gt;&quot;,a0,a1,a2,a3); if (String(a2) === String(detect_frida_loop)) { result = 0; console.log(&quot;阻止frida反调试启动&quot;); } else { result = pthread_create(a0,a1,a2,a3); console.log(&quot;正常启动&quot;); } return result; }, 'int', ['pointer', 'pointer','pointer','pointer'])); })} 11、hook native 调用栈1234567Interceptor.attach(f, { onEnter: function (args) { console.log('RegisterNatives called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); }}); 12、jnitrace1、安装jnitrace: https://github.com/chame1eon/jnitrace python : pip install jnitrace 2、基础用法ndk 开发是没有办法脱离 [libc.so](http://libc.so) 和 [libart.so](http://libart.so) 进行开发, 所以只要降维打击, 通过 trace 的方式就可以监控到 so 层 3、启动命令jnitrace [options] -l libname packagename 例如: jnitrace -l [libnative-lib.so](http://libnative-lib.so) com.example.myapplication 必要参数 -l libname : 指定要trace的.so文件, 可以同时trace多个.so文件, 直接使用 *来trace所有的.so文件; 如: -l libnative-lib.so -l libanother-lib.so or -l * packagename : 指定要trace的package name 可选参数 -m: 指定是spawn还是attach -b: 指定是fuzzy还是accurate -i &lt;regex&gt;: 指定一个正则表达式来过滤出方法名, 例如: -i Get -i RegisterNatives 就只会打印出名字里包含Get或者RegisterNatives的JNI methods -e &lt;regex&gt;和i相反，同样通过正则表达式来过滤，但这次会将指定的内容忽略掉 -I &lt;string&gt;trace导出的方法，jnitrace认为导出的函数应该是从Java端能够直接调用的函数，所以可以包括使用RegisterNatives来注册的函数，例如I stringFromJNI -I nativeMethod([B)V，就包括导出名里有stringFromJNI，以及使用RegisterNames来注册，并带有nativeMethod([B)V签名的函数。 -o path/output.json，导出输出到文件里。 -p path/to/script.js，用于在加载jnitrace脚本之前将指定路径的Frida脚本加载到目标进程中，这可以用于在jnitrace启动之前对抗反调试。 -a path/to/script.js，用于在加载jnitrace脚本之后将指定路径的Frida脚本加载到目标进程中 -ignore-env，不打印所有的JNIEnv函数 -ignore-vm，不打印所有的JavaVM函数 启动方式默认使用 spawn 启动, 可以通过 -m attach 设置通过 attach 启动 jnitrace -m attach -l[libnative-lib.so](http://libnative-lib.so) com.kevin.demoso1 设置回溯器默认情况下使用 accurate的精确模式来进行回溯, 可以通过 -b fuzzy 修改为模糊模式 jnitrace -l [libnative-lib.so](http://libnative-lib.so) -b fuzzy com.kevin.demoso1 监控指定规则的方法用于指定应该跟踪的方法名, 该选项可以多次提供; jnitrace -l libnative-lib.so -i RegisterNatives com.kevin.demoso1 只过滤出RegisterNatives相关的内容 忽略指定规则的方法用于指定在跟踪中应被忽略的方法名, 这个选项可以被多次提供; 忽略以Find开头的所有方法; jnitrace -l libnative-lib.so -e ^Find com.kevin.demoso 4、jnitace 计算偏移地址 0x8e4f3b1 是方法 initSN 方法的绝对地址 0xd8e4e000 是 [libmyjni.so](http://libmyjni.so) 基地址 使用使用 initSN()V的绝对地址 0xd8e4f3b1 减去 [libmyjni.so](http://libmyjni.so) 的基地址 0xd8e4e000 , 得到偏移 0x13B1 g 进行跳转到 0x13B1 即可进入方法 13、frida-trace文档地址: https://frida.re/docs/frida-trace/ options123456789101112131415161718192021222324252627282930Usage: frida-trace [options] target Options: --version show program's version number and exit -h, --help show this help message and exit -D ID, --device=ID connect to device with the given ID -U, --usb connect to USB device -R, --remote connect to remote frida-server -H HOST, --host=HOST connect to remote frida-server on HOST -f FILE, --file=FILE spawn FILE -F, --attach-frontmost attach to frontmost application -n NAME, --attach-name=NAME attach to NAME -p PID, --attach-pid=PID attach to PID --stdio=inherit|pipe stdio behavior when spawning (defaults to “inherit”) --runtime=duk|v8 script runtime to use (defaults to “duk”) --debug enable the Node.js compatible script debugger -I MODULE, --include-module=MODULE include MODULE -X MODULE, --exclude-module=MODULE exclude MODULE -i FUNCTION, --include=FUNCTION include FUNCTION -x FUNCTION, --exclude=FUNCTION exclude FUNCTION -a MODULE!OFFSET, --add=MODULE!OFFSET add MODULE!OFFSET -T, --include-imports include program's imports -t MODULE, --include-module-imports=MODULE include MODULE imports -m OBJC_METHOD, --include-objc-method=OBJC_METHOD include OBJC_METHOD -M OBJC_METHOD, --exclude-objc-method=OBJC_METHOD exclude OBJC_METHOD -s DEBUG_SYMBOL, --include-debug-symbol=DEBUG_SYMBOL include DEBUG_SYMBOL -q, --quiet do not format output messages -d, --decorate Add module name to generated onEnter log statement -o OUTPUT, --output=OUTPUT dump messages to file 基础使用frida-trace [options] packagename 启动模式默认使用 attach 模式, 可以指定 -f packageName 使用 spawn 模式启动 frida-trace -U -i strcmp -f com.gdufs.xman 文件输出frida-trace -U -i &quot;strcmp&quot; -f com.gdufs.xman -o xman.json -o filepath 指定输出的文件路径, 方便内容过多时进行查看 trace 任意 functionfrida-trace -U -i &quot;strcmp&quot; com.example.demoso1 trace 任意 modulefrida-trace -U -I &quot;libnative-lib.so&quot; com.example.demoso1 根据地址进行 tracefrida-trace -U -a &quot;libnative-lib.so!0x9281&quot; com.example.demoso1 批量 trace源码地址: https://github.com/Pr0214/trace_natives ps: 需要切换到 frida14 版本 1.将traceNatives.py丢进IDA plugins目录中 在ida 的python console中运行如下命令即可找到plugins目录：os.path.join(idaapi.get_user_idadir(), &quot;plugins&quot;) 2.IDA中，Edit-Plugins-traceNatives –&gt; IDA输出窗口就会显示如下字眼：使用方法如下： frida-trace -UF -O C:\\Users\\Lenovo\\Desktop\\2021\\mt\\libmtguard.txt 14、frida-hook-libart下载地址: https://github.com/lasting-yang/frida_hook_libart hook artfrida -U --no-pause -f package_name -l hook_art.js hook_RegisterNativesfrida -U --no-pause -f package_name -l hook_RegisterNatives.js hook_artmethodinit libext first time adb push lib/libext64.so /data/local/tmp/libext64.so adb push lib/libext.so /data/local/tmp/libext.so adb shell su -c &quot;cp /data/local/tmp/libext64.so /data/app/libext64.so&quot; adb shell su -c &quot;cp /data/local/tmp/libext.so /data/app/libext.so&quot; adb shell su -c &quot;chown 1000.1000 /data/app/libext*.so&quot; adb shell su -c &quot;chmod 777 /data/app/libext*.so&quot; adb shell su -c &quot;ls -al /data/app/libext*&quot; use hook_artmethod.jsfrida -U --no-pause -f package_name -l hook_artmethod.js # or frida -U --no-pause -f package_name -l hook_artmethod.js &gt; hook_artmethod.log frida-fart-hook首先拷贝fart.so和fart64.so到/data/app目录下，并使用chmod 777 设置好权限,然后就可以使用了。 如果目标 app 没有 sdcard 权限则需要手动添加; 或者可以修改 frida_fart_hook.js 中的源码, 将 savepath 改为 /data/data/应用包名/; 该frida版fart是使用hook的方式实现的函数粒度的脱壳，仅仅是对类中的所有函数进行了加载，但依然可以解决绝大多数的抽取保护 需要以spawn方式启动app，等待app进入Activity界面后，执行fart()函数即可。如app包名为com.example.test,则 frida -U -f com.example.test -l frida_fart_hook.js --no-pause ，然后等待app进入主界面,执行fart() 高级用法：如果发现某个类中的函数的CodeItem没有dump下来，可以调用dump(classname),传入要处理的类名，完成对该类下的所有函数体的dump,dump下来的函数体会追加到bin文件当中。 15、frida 文件写入(frida/hook libc)frida api 写入文件 123456function writeFile(){ var file = new File(&quot;/sdcard/reg.dat&quot;, &quot;w&quot;); file.write(&quot;content from frida&quot;); file.flush(); file.close();} frida 定义 NativeFunction 写入文件 123456789101112131415161718192021222324function writeFileNative(){ var addr_fopen = Module.findExportByName(&quot;libc.so&quot;, &quot;fopen&quot;); var addr_fputs = Module.findExportByName(&quot;libc.so&quot;, &quot;fputs&quot;); var addr_fclose = Module.findExportByName(&quot;libc.so&quot;, &quot;fclose&quot;); // 将 libc 的系统方法注册到 js 层 var fopen = new NativeFunction(addr_fopen, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); var fputs = new NativeFunction(addr_fputs, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); var fclose = new NativeFunction(addr_fclose, &quot;int&quot;, [&quot;pointer&quot;]); // 在 js 层主动调用 libc 的方法 // 不能直接将 js 的字符串传给 libc中的方法, 需要进行转换 var filename = Memory.allocUtf8String(&quot;/sdcard/reg.dat&quot;); var open_mode = Memory.allocUtf8String(&quot;w&quot;); var file = fopen(filename, open_mode); var buffer = Memory.allocUtf8String(&quot;content from frida&quot;); var result = fputs(buffer, file); console.log(&quot;fputs ret: &quot;, result); // 关闭文件 fclose(file); } 16、hook 读写 std::string12345678910111213141516171819function readStdString(str){ var isTiny = (str.readU8 &amp; 1) === 0; if (isTiny){ return str.add(1).readUtf8String(); } return str.add(2 * Process.pointerSize).readPointer().readUtf8String();}function writeStdString(str, content){ var isTiny = (str.readU8() &amp; 1) === 0; if (isTiny){ str.add(1).writeUtf8String(content); }else{ str.add(2 * Process.pointerSize).readPointer().writeUtf8String(content); }} 17、hook so 文件加载后马上 hook1234567891011121314151617181920212223242526272829303132333435363738394041424344//第一种方式（针对较老的系统版本）var dlopen = Module.findExportByName(null, &quot;dlopen&quot;);console.log(dlopen);if(dlopen != null){ Interceptor.attach(dlopen,{ onEnter: function(args){ var soName = args[0].readCString(); console.log(soName); if(soName.indexOf(&quot;libc.so&quot;) != -1){ this.hook = true; } }, onLeave: function(retval){ if(this.hook) { dlopentodo(); }; } });}//第二种方式（针对新系统版本） android 8.1 使用该方法var android_dlopen_ext = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);console.log(android_dlopen_ext);if(android_dlopen_ext != null){ Interceptor.attach(android_dlopen_ext,{ onEnter: function(args){ var soName = args[0].readCString(); console.log(soName); if(soName.indexOf(&quot;libc.so&quot;) != -1){ this.hook = true; } }, onLeave: function(retval){ if(this.hook) { dlopentodo(); }; } });}function dlopentodo(){ //todo ...} 18、hook libc kill1234567891011function replaceKILL(){ var kill_addr = Module.findExportByName(&quot;libc.so&quot;,&quot;kill&quot;); Interceptor.replace(kill_addr, new NativeCallback(function(arg0, arg1){ console.log(&quot;arg0=&gt; &quot;, arg0); console.log(&quot;arg1=&gt; &quot;, arg1); console.log('libc.so!kill called from:\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE) .map(DebugSymbol.fromAddress).join('\\n') + '\\n'); },&quot;int&quot;,[&quot;int&quot;,&quot;int&quot;]))} 19、hook init_array1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//应用以32位在64位终端环境下运行//adb install --abi armeabi-v7a &lt;path to apk&gt;function get_call_function() { var call_function_addr = null; var symbols = Process.getModuleByName(&quot;linker&quot;).enumerateSymbols(); for (var m = 0; m &lt; symbols.length; m++) { if (symbols[m].name == &quot;__dl__ZL13call_functionPKcPFviPPcS2_ES0_&quot;) { call_function_addr = symbols[m].address; console.log(&quot;found call_function_addr =&gt; &quot;, call_function_addr) hook_call_function(call_function_addr) } }}function hook_call_function(_call_function_addr){ console.log(&quot;hook call function begin!hooking address :=&gt;&quot;,_call_function_addr) Interceptor.attach(_call_function_addr,{ onEnter:function(args){ if(args[2].readCString().indexOf(&quot;base.odex&quot;)&lt;0){ console.log(&quot;============================&quot;) console.log(&quot;function_name =&gt;&quot;,args[0].readCString()) var soPath = args[2].readCString() console.log(&quot;so path : =&gt;&quot;,soPath) var soName = soPath.split(&quot;/&quot;).pop(); console.log(&quot;function offset =&gt;&quot;,&quot;0x&quot;+(args[1]-Module.findBaseAddress(soName)).toString(16)) console.log(&quot;============================&quot;) } },onLeave:function(retval){ } })}setImmediate(get_call_function)function hook_constructor() { if (Process.pointerSize == 4) { var linker = Process.findModuleByName(&quot;linker&quot;); } else { var linker = Process.findModuleByName(&quot;linker64&quot;); } var addr_call_function =null; var addr_g_ld_debug_verbosity = null; var addr_async_safe_format_log = null; if (linker) { var symbols = linker.enumerateSymbols(); for (var i = 0; i &lt; symbols.length; i++) { var name = symbols[i].name; if (name.indexOf(&quot;call_function&quot;) &gt;= 0){ addr_call_function = symbols[i].address; } else if(name.indexOf(&quot;g_ld_debug_verbosity&quot;) &gt;=0){ addr_g_ld_debug_verbosity = symbols[i].address; ptr(addr_g_ld_debug_verbosity).writeInt(2); } else if(name.indexOf(&quot;async_safe_format_log&quot;) &gt;=0 &amp;&amp; name.indexOf('va_list') &lt; 0){ addr_async_safe_format_log = symbols[i].address; } } } if(addr_async_safe_format_log){ Interceptor.attach(addr_async_safe_format_log,{ onEnter: function(args){ this.log_level = args[0]; this.tag = ptr(args[1]).readCString() this.fmt = ptr(args[2]).readCString() if(this.fmt.indexOf(&quot;c-tor&quot;) &gt;= 0 &amp;&amp; this.fmt.indexOf('Done') &lt; 0){ this.function_type = ptr(args[3]).readCString(), // func_type this.so_path = ptr(args[5]).readCString(); var strs = new Array(); //定义一数组 strs = this.so_path.split(&quot;/&quot;); //字符分割 this.so_name = strs.pop(); this.func_offset = ptr(args[4]).sub(Module.findBaseAddress(this.so_name)) console.log(&quot;func_type:&quot;, this.function_type, '\\nso_name:',this.so_name, '\\nso_path:',this.so_path, '\\nfunc_offset:',this.func_offset ); } }, onLeave: function(retval){ } }) }}function main() { hook_constructor();}setImmediate(main); 20、frida dumpdocument: https://github.com/lasting-yang/frida_dump frida dump so123456789101112131415161718192021function dump_so(so_name) { Java.perform(function () { var currentApplication = Java.use(&quot;android.app.ActivityThread&quot;).currentApplication(); var dir = currentApplication.getApplicationContext().getFilesDir().getPath(); var libso = Process.getModuleByName(so_name); console.log(&quot;[name]:&quot;, libso.name); console.log(&quot;[base]:&quot;, libso.base); console.log(&quot;[size]:&quot;, ptr(libso.size)); console.log(&quot;[path]:&quot;, libso.path); var file_path = dir + &quot;/&quot; + libso.name + &quot;_&quot; + libso.base + &quot;_&quot; + ptr(libso.size) + &quot;.so&quot;; var file_handle = new File(file_path, &quot;wb&quot;); if (file_handle &amp;&amp; file_handle != null) { Memory.protect(ptr(libso.base), libso.size, 'rwx'); var libso_buffer = ptr(libso.base).readByteArray(libso.size); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(&quot;[dump]:&quot;, file_path); } });} frida dump dex123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161function get_self_process_name() { var openPtr = Module.getExportByName('libc.so', 'open'); var open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var readPtr = Module.getExportByName(&quot;libc.so&quot;, &quot;read&quot;); var read = new NativeFunction(readPtr, &quot;int&quot;, [&quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]); var closePtr = Module.getExportByName('libc.so', 'close'); var close = new NativeFunction(closePtr, 'int', ['int']); var path = Memory.allocUtf8String(&quot;/proc/self/cmdline&quot;); var fd = open(path, 0); if (fd != -1) { var buffer = Memory.alloc(0x1000); var result = read(fd, buffer, 0x1000); close(fd); result = ptr(buffer).readCString(); return result; } return &quot;-1&quot;;}function mkdir(path) { var mkdirPtr = Module.getExportByName('libc.so', 'mkdir'); var mkdir = new NativeFunction(mkdirPtr, 'int', ['pointer', 'int']); var opendirPtr = Module.getExportByName('libc.so', 'opendir'); var opendir = new NativeFunction(opendirPtr, 'pointer', ['pointer']); var closedirPtr = Module.getExportByName('libc.so', 'closedir'); var closedir = new NativeFunction(closedirPtr, 'int', ['pointer']); var cPath = Memory.allocUtf8String(path); var dir = opendir(cPath); if (dir != 0) { closedir(dir); return 0; } mkdir(cPath, 755); chmod(path);}function chmod(path) { var chmodPtr = Module.getExportByName('libc.so', 'chmod'); var chmod = new NativeFunction(chmodPtr, 'int', ['pointer', 'int']); var cPath = Memory.allocUtf8String(path); chmod(cPath, 755);}function dump_dex() { var libart = Process.findModuleByName(&quot;libart.so&quot;); var addr_DefineClass = null; var symbols = libart.enumerateSymbols(); for (var index = 0; index &lt; symbols.length; index++) { var symbol = symbols[index]; var symbol_name = symbol.name; //这个DefineClass的函数签名是Android9的 //_ZN3art11ClassLinker11DefineClassEPNS_6ThreadEPKcmNS_6HandleINS_6mirror11ClassLoaderEEERKNS_7DexFileERKNS9_8ClassDefE if (symbol_name.indexOf(&quot;ClassLinker&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;DefineClass&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;Thread&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;DexFile&quot;) &gt;= 0) { console.log(symbol_name, symbol.address); addr_DefineClass = symbol.address; } } var dex_maps = {}; var dex_count = 1; console.log(&quot;[DefineClass:]&quot;, addr_DefineClass); if (addr_DefineClass) { Interceptor.attach(addr_DefineClass, { onEnter: function(args) { var dex_file = args[5]; //ptr(dex_file).add(Process.pointerSize) is &quot;const uint8_t* const begin_;&quot; //ptr(dex_file).add(Process.pointerSize + Process.pointerSize) is &quot;const size_t size_;&quot; var base = ptr(dex_file).add(Process.pointerSize).readPointer(); var size = ptr(dex_file).add(Process.pointerSize + Process.pointerSize).readUInt(); if (dex_maps[base] == undefined) { dex_maps[base] = size; var magic = ptr(base).readCString(); if (magic.indexOf(&quot;dex&quot;) == 0) { var process_name = get_self_process_name(); if (process_name != &quot;-1&quot;) { var dex_dir_path = &quot;/data/data/&quot; + process_name + &quot;/files/dump_dex_&quot; + process_name; mkdir(dex_dir_path); var dex_path = dex_dir_path + &quot;/class&quot; + (dex_count == 1 ? &quot;&quot; : dex_count) + &quot;.dex&quot;; console.log(&quot;[find dex]:&quot;, dex_path); var fd = new File(dex_path, &quot;wb&quot;); if (fd &amp;&amp; fd != null) { dex_count++; var dex_buffer = ptr(base).readByteArray(size); fd.write(dex_buffer); fd.flush(); fd.close(); console.log(&quot;[dump dex]:&quot;, dex_path); } } } } }, onLeave: function(retval) {} }); }}var is_hook_libart = false;function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, &quot;dlopen&quot;), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(&quot;dlopen:&quot;, path); if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) { this.can_hook_libart = true; console.log(&quot;[dlopen:]&quot;, path); } } }, onLeave: function(retval) { if (this.can_hook_libart &amp;&amp; !is_hook_libart) { dump_dex(); is_hook_libart = true; } } }) Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), { onEnter: function(args) { var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(&quot;android_dlopen_ext:&quot;, path); if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) { this.can_hook_libart = true; console.log(&quot;[android_dlopen_ext:]&quot;, path); } } }, onLeave: function(retval) { if (this.can_hook_libart &amp;&amp; !is_hook_libart) { dump_dex(); is_hook_libart = true; } } });}setImmediate(dump_dex); frida dump dex class123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193function get_self_process_name() { var openPtr = Module.getExportByName('libc.so', 'open'); var open = new NativeFunction(openPtr, 'int', ['pointer', 'int']); var readPtr = Module.getExportByName(&quot;libc.so&quot;, &quot;read&quot;); var read = new NativeFunction(readPtr, &quot;int&quot;, [&quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]); var closePtr = Module.getExportByName('libc.so', 'close'); var close = new NativeFunction(closePtr, 'int', ['int']); var path = Memory.allocUtf8String(&quot;/proc/self/cmdline&quot;); var fd = open(path, 0); if (fd != -1) { var buffer = Memory.alloc(0x1000); var result = read(fd, buffer, 0x1000); close(fd); result = ptr(buffer).readCString(); return result; } return &quot;-1&quot;;}function load_all_class() { if (Java.available) { Java.perform(function () { var DexFileclass = Java.use(&quot;dalvik.system.DexFile&quot;); var BaseDexClassLoaderclass = Java.use(&quot;dalvik.system.BaseDexClassLoader&quot;); var DexPathListclass = Java.use(&quot;dalvik.system.DexPathList&quot;); Java.enumerateClassLoaders({ onMatch: function (loader) { try { var basedexclassloaderobj = Java.cast(loader, BaseDexClassLoaderclass); var pathList = basedexclassloaderobj.pathList.value; var pathListobj = Java.cast(pathList, DexPathListclass) var dexElements = pathListobj.dexElements.value; for (var index in dexElements) { var element = dexElements[index]; try { var dexfile = element.dexFile.value; var dexfileobj = Java.cast(dexfile, DexFileclass); console.log(&quot;dexFile:&quot;, dexfileobj); const classNames = []; const enumeratorClassNames = dexfileobj.entries(); while (enumeratorClassNames.hasMoreElements()) { var className = enumeratorClassNames.nextElement().toString(); classNames.push(className); try { loader.loadClass(className); } catch (error) { console.log(&quot;loadClass error:&quot;, error); } } } catch (error) { console.log(&quot;dexfile error:&quot;, error); } } } catch (error) { console.log(&quot;loader error:&quot;, error); } }, onComplete: function () { } }) console.log(&quot;load_all_class end.&quot;); }); }}var dex_maps = {};function print_dex_maps() { for (var dex in dex_maps) { console.log(dex, dex_maps[dex]); }}function dump_dex() { load_all_class(); for (var base in dex_maps) { var size = dex_maps[base]; console.log(base); var magic = ptr(base).readCString(); if (magic.indexOf(&quot;dex&quot;) == 0) { var process_name = get_self_process_name(); if (process_name != &quot;-1&quot;) { var dex_path = &quot;/data/data/&quot; + process_name + &quot;/files/&quot; + base.toString(16) + &quot;_&quot; + size.toString(16) + &quot;.dex&quot;; console.log(&quot;[find dex]:&quot;, dex_path); var fd = new File(dex_path, &quot;wb&quot;); if (fd &amp;&amp; fd != null) { var dex_buffer = ptr(base).readByteArray(size); fd.write(dex_buffer); fd.flush(); fd.close(); console.log(&quot;[dump dex]:&quot;, dex_path); } } } }}function hook_dex() { var libart = Process.findModuleByName(&quot;libart.so&quot;); var addr_DefineClass = null; var symbols = libart.enumerateSymbols(); for (var index = 0; index &lt; symbols.length; index++) { var symbol = symbols[index]; var symbol_name = symbol.name; //这个DefineClass的函数签名是Android9的 //_ZN3art11ClassLinker11DefineClassEPNS_6ThreadEPKcmNS_6HandleINS_6mirror11ClassLoaderEEERKNS_7DexFileERKNS9_8ClassDefE if (symbol_name.indexOf(&quot;ClassLinker&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;DefineClass&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;Thread&quot;) &gt;= 0 &amp;&amp; symbol_name.indexOf(&quot;DexFile&quot;) &gt;= 0) { console.log(symbol_name, symbol.address); addr_DefineClass = symbol.address; } } console.log(&quot;[DefineClass:]&quot;, addr_DefineClass); if (addr_DefineClass) { Interceptor.attach(addr_DefineClass, { onEnter: function (args) { var dex_file = args[5]; //ptr(dex_file).add(Process.pointerSize) is &quot;const uint8_t* const begin_;&quot; //ptr(dex_file).add(Process.pointerSize + Process.pointerSize) is &quot;const size_t size_;&quot; var base = ptr(dex_file).add(Process.pointerSize).readPointer(); var size = ptr(dex_file).add(Process.pointerSize + Process.pointerSize).readUInt(); if (dex_maps[base] == undefined) { dex_maps[base] = size; console.log(&quot;hook_dex:&quot;, base, size); } }, onLeave: function (retval) {} }); }}var is_hook_libart = false;function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, &quot;dlopen&quot;), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(&quot;dlopen:&quot;, path); if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) { this.can_hook_libart = true; console.log(&quot;[dlopen:]&quot;, path); } } }, onLeave: function (retval) { if (this.can_hook_libart &amp;&amp; !is_hook_libart) { hook_dex(); is_hook_libart = true; } } }) Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined &amp;&amp; pathptr != null) { var path = ptr(pathptr).readCString(); //console.log(&quot;android_dlopen_ext:&quot;, path); if (path.indexOf(&quot;libart.so&quot;) &gt;= 0) { this.can_hook_libart = true; console.log(&quot;[android_dlopen_ext:]&quot;, path); } } }, onLeave: function (retval) { if (this.can_hook_libart &amp;&amp; !is_hook_libart) { hook_dex(); is_hook_libart = true; } } });}setImmediate(hook_dex); 21、指针运算符和读写 API hook so readPointer()1234567891011Java.perform(function () { var libc_addr = Process.findModuleByName(&quot;libc.so&quot;).base; console.log(&quot;libc address is &quot; + libc_addr); // 0x10 转为十进制为 16, 读取 console.log(libc_addr.readByteArray(0x10)); // readPointer(), 从此内存位置读取 NativePointer console.log(&quot;pointer size&quot;, Process.pointerSize); console.log(&quot;readPointer() is &quot; + libc_addr.readPointer()); console.log(&quot;Memory.readPointer()&quot; + Memory.readPointer(libc_addr.add(Process.pointerSize))); }) hook so writePointer()12345678910111213141516Java.perform(function () { var libc_addr = Process.findModuleByName(&quot;libc.so&quot;).base; console.log(&quot;libc_addr : &quot; + libc_addr); // 分配四个字节的空间地址 const r = Memory.alloc(4); // 将 libc_addr 指针写入刚申请的 r 中 r.writePointer(libc_addr); // 读取 r 指针的数据 var buffer = Memory.readByteArray(r, 4); console.log(buffer); })//libc_addr : 0x7da7fdf000 // 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF// 00000000 00 f0 fd a7 .... hook so readS32(), readU32()从指定内存地址读取有符号或者无符号 8/16/21/etc 或浮点数/双精度值, 并将其作为数字返回; 1234567Java.perform(function () { var libc_addr = Process.findModuleByName(&quot;libc.so&quot;).base; console.log(hexdump(libc_addr)); console.log(libc_addr.readS32(), (libc_addr.readS32()).toString(16)); console.log(libc_addr.readU32(), (libc_addr.readU32()).toString(16)); }) hook so writeS32(), writeU32()将有符号或无符号8/16/32/等或浮点数/双精度值写入此内存位置 1234567891011Java.perform(function () { // 开辟四个字节的内存空间 const r = Memory.alloc(4); r.writeS32(0x12345678); console.log(r.readByteArray(0x10)); })&lt;!-- 0 1 2 3 4 5 6 7 8 9 A B C D E F 0123456789ABCDEF00000000 78 56 34 12 7d 00 00 00 98 c0 bb a8 7d 00 00 00 xV4.}.......}... --&gt; hook so readByteArray(), writeByteArray()12345678910111213Java.perform(function () { // 定义一个需要写入的字节数组 var arr = [ 0x72, 0x6F, 0x79, 0x73, 0x75, 0x65]; //这里申请以arr大小的内存空间 var r = Memory.alloc(arr.length); // 将 arr 写入 r 中 r.writeByteArray(arr); // Memory.writeByteArray(r, arr); 同样可以写入 console.log(&quot;memory readbyteArray: &quot;) console.log(r.readByteArray(arr.length)); console.log(Memory.readByteArray(r, arr.length)); }) hook so readCString(), writeUtf8String()123456789101112Java.perform(function () { // 开辟内存空间 存有字符串 var r = Memory.allocUtf8String(&quot;你好,世界&quot;); // 读取内存中的字符串 console.log(hexdump(r)); console.log(r.readCString()); // 往内存中写入新的字符串 r.writeUtf8String(&quot;Hello,World&quot;); console.log(hexdump(r)); console.log(r.readCString()) }) 22、hook 获取 jni array123456// 获取 jbytesArray 的指针var arg1Ptr = Java.vm.getEnv().getByteArrayElements(this.arg1, null) // 获取到指针后可以直接 hexdump 打印console.log(&quot;arg1Ptr&quot;,hexdump(arg1Ptr));// 如果是字符串可以直接转console.log(&quot;arg1Ptr&quot;,arg1Ptr.readCString()); 23、jni_helper 进入目录 ~/androidFxxk/idaTools/jni_helper java -jar JadxFindJNI/JadxFindJNI.jar &lt;apk.path&gt; &lt;output.json&gt; ida 中Script File运行 jni_help脚本, 路径 ~/androidFxxk/idaTools/jni_helper/ida/jni_helper.py 导入刚才生成的 output.json 文件即可自动识别","link":"/20211227/Frida-Hook-So/"},{"title":"JNI规范文档","text":"JNI规范文档12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094#ifndef JNI_H_#define JNI_H_#include &lt;sys/cdefs.h&gt;#include &lt;stdarg.h&gt;#ifdef HAVE_INTTYPES_H# include &lt;inttypes.h&gt; /* C99 */ //这个是JNI规范中定义的基本数据类型 //typedef 关键字，可以使用它来为类型取一个新的名字。 //举个例子：typedef unsigned char BYTE;在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 */#elsetypedef unsigned char jboolean; /* unsigned 8 bits */typedef signed char jbyte; /* signed 8 bits */typedef unsigned short jchar; /* unsigned 16 bits */typedef short jshort; /* signed 16 bits */typedef int jint; /* signed 32 bits */typedef long long jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 */#endif/* &quot;cardinal indices and sizes&quot; */typedef jint jsize; //表示返回数组的大小#ifdef __cplusplus/* * Reference types, in C++ //与C++有关的定义 */class _jobject {};class _jclass : public _jobject {};class _jstring : public _jobject {};class _jarray : public _jobject {};class _jobjectArray : public _jarray {};class _jbooleanArray : public _jarray {};class _jbyteArray : public _jarray {};class _jcharArray : public _jarray {};class _jshortArray : public _jarray {};class _jintArray : public _jarray {};class _jlongArray : public _jarray {};class _jfloatArray : public _jarray {};class _jdoubleArray : public _jarray {};class _jthrowable : public _jobject {}; //为C++的一些类型进行重新定义typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak;#else /* not __cplusplus *//* * Reference types, in C. //与C有关的，继续为类型起新的名字；有arrary表示按JNI 标准定义的数组类型 */ typedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak;#endif /* not __cplusplus */ //两个方法ID和字段IDstruct _jfieldID; /* opaque structure */typedef struct _jfieldID* jfieldID; /* field IDs */struct _jmethodID; /* opaque structure */typedef struct _jmethodID* jmethodID; /* method IDs */ //定义一个结构体JNIInvokeInterface，是一个调用接口的结构体struct JNIInvokeInterface; //定义一个联合体jvalue，里面有各种类型typedef union jvalue { jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l;} jvalue; //定义一个枚举jobjectRefType，里面有各种枚举元素typedef enum jobjectRefType { JNIInvalidRefType = 0, JNILocalRefType = 1, JNIGlobalRefType = 2, JNIWeakGlobalRefType = 3} jobjectRefType; //定义一个动态注册JNINativeMethod结构体，这个与动态注册有关，里面有三个元素typedef struct { const char* name; //第一个参数 name 是java 方法名； const char* signature; //第二个参数 signature 用于描述方法的参数与返回值，也就是java方法签名信息， void* fnPtr; //第三个参数 fnPtr 是函数指针，指向 jni 函数；} JNINativeMethod; // 其中，第二个参数 signature 使用字符串记录方法的参数与返回值，具体格式形如“()V”、“(II)V”，其中分为两部分，括号内表示的是参数，括号右侧表示的是返回值；struct _JNIEnv;struct _JavaVM; //定义一个JNINativeInterface结构体，表示原生调用接口的结构体typedef const struct JNINativeInterface* C_JNIEnv;#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#else //这里有两个接口，一个是本地接口，一个是调用接口typedef const struct JNINativeInterface* JNIEnv;//JNI本地接口typedef const struct JNIInvokeInterface* JavaVM;//JNI调用接口#endif //本地接口结构体的定义struct JNINativeInterface { void* reserved0; void* reserved1; void* reserved2; void* reserved3; jint (*GetVersion)(JNIEnv *); //jint返回的是版本信息 //jclass，返回的是类 jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*,jsize); jclass (*FindClass)(JNIEnv*, const char*); jmethodID (*FromReflectedMethod)(JNIEnv*, jobject); jfieldID (*FromReflectedField)(JNIEnv*, jobject); jobject (*ToReflectedMethod)(JNIEnv*, jclass, jmethodID, jboolean); jclass (*GetSuperclass)(JNIEnv*, jclass); jboolean (*IsAssignableFrom)(JNIEnv*, jclass, jclass); jobject (*ToReflectedField)(JNIEnv*, jclass, jfieldID, jboolean); //与异常有关的方法 jint (*Throw)(JNIEnv*, jthrowable); jint (*ThrowNew)(JNIEnv *, jclass, const char *); jthrowable (*ExceptionOccurred)(JNIEnv*); void (*ExceptionDescribe)(JNIEnv*); void (*ExceptionClear)(JNIEnv*); void (*FatalError)(JNIEnv*, const char*); jint (*PushLocalFrame)(JNIEnv*, jint); jobject (*PopLocalFrame)(JNIEnv*, jobject); jobject (*NewGlobalRef)(JNIEnv*, jobject); void (*DeleteGlobalRef)(JNIEnv*, jobject); void (*DeleteLocalRef)(JNIEnv*, jobject); jboolean (*IsSameObject)(JNIEnv*, jobject, jobject); jobject (*NewLocalRef)(JNIEnv*, jobject); jint (*EnsureLocalCapacity)(JNIEnv*, jint); //新建object jobject (*AllocObject)(JNIEnv*, jclass); jobject (*NewObject)(JNIEnv*, jclass, jmethodID, ...); jobject (*NewObjectV)(JNIEnv*, jclass, jmethodID, va_list); jobject (*NewObjectA)(JNIEnv*, jclass, jmethodID, jvalue*); jclass (*GetObjectClass)(JNIEnv*, jobject); jboolean (*IsInstanceOf)(JNIEnv*, jobject, jclass); jmethodID (*GetMethodID)(JNIEnv*, jclass, const char*, const char*); //调用方法 jobject (*CallObjectMethod)(JNIEnv*, jobject, jmethodID, ...); jobject (*CallObjectMethodV)(JNIEnv*, jobject, jmethodID, va_list); jobject (*CallObjectMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jboolean (*CallBooleanMethod)(JNIEnv*, jobject, jmethodID, ...); jboolean (*CallBooleanMethodV)(JNIEnv*, jobject, jmethodID, va_list); jboolean (*CallBooleanMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jbyte (*CallByteMethod)(JNIEnv*, jobject, jmethodID, ...); jbyte (*CallByteMethodV)(JNIEnv*, jobject, jmethodID, va_list); jbyte (*CallByteMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jchar (*CallCharMethod)(JNIEnv*, jobject, jmethodID, ...); jchar (*CallCharMethodV)(JNIEnv*, jobject, jmethodID, va_list); jchar (*CallCharMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jshort (*CallShortMethod)(JNIEnv*, jobject, jmethodID, ...); jshort (*CallShortMethodV)(JNIEnv*, jobject, jmethodID, va_list); jshort (*CallShortMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jint (*CallIntMethod)(JNIEnv*, jobject, jmethodID, ...); jint (*CallIntMethodV)(JNIEnv*, jobject, jmethodID, va_list); jint (*CallIntMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jlong (*CallLongMethod)(JNIEnv*, jobject, jmethodID, ...); jlong (*CallLongMethodV)(JNIEnv*, jobject, jmethodID, va_list); jlong (*CallLongMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jfloat (*CallFloatMethod)(JNIEnv*, jobject, jmethodID, ...) __NDK_FPABI__; jfloat (*CallFloatMethodV)(JNIEnv*, jobject, jmethodID, va_list) __NDK_FPABI__; jfloat (*CallFloatMethodA)(JNIEnv*, jobject, jmethodID, jvalue*) __NDK_FPABI__; jdouble (*CallDoubleMethod)(JNIEnv*, jobject, jmethodID, ...) __NDK_FPABI__; jdouble (*CallDoubleMethodV)(JNIEnv*, jobject, jmethodID, va_list) __NDK_FPABI__; jdouble (*CallDoubleMethodA)(JNIEnv*, jobject, jmethodID, jvalue*) __NDK_FPABI__; void (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...); void (*CallVoidMethodV)(JNIEnv*, jobject, jmethodID, va_list); void (*CallVoidMethodA)(JNIEnv*, jobject, jmethodID, jvalue*); jobject (*CallNonvirtualObjectMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jobject (*CallNonvirtualObjectMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jobject (*CallNonvirtualObjectMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jboolean (*CallNonvirtualBooleanMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jbyte (*CallNonvirtualByteMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jbyte (*CallNonvirtualByteMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jbyte (*CallNonvirtualByteMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jchar (*CallNonvirtualCharMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jchar (*CallNonvirtualCharMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jchar (*CallNonvirtualCharMethodA)(JNIEnv*, jobject, jclass, jmethodID, jvalue*); jshort (*CallNonvirtualShortMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jshort (*CallNonvirtualShortMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jshort (*CallNonvirtualShortMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jint (*CallNonvirtualIntMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jint (*CallNonvirtualIntMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jint (*CallNonvirtualIntMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jlong (*CallNonvirtualLongMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); jlong (*CallNonvirtualLongMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); jlong (*CallNonvirtualLongMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); jfloat (*CallNonvirtualFloatMethod)(JNIEnv*, jobject, jclass,jmethodID, ...) __NDK_FPABI__; jfloat (*CallNonvirtualFloatMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list) __NDK_FPABI__; jfloat (*CallNonvirtualFloatMethodA)(JNIEnv*, jobject, jclass, jmethodID, jvalue*) __NDK_FPABI__; jdouble (*CallNonvirtualDoubleMethod)(JNIEnv*, jobject, jclass,jmethodID, ...) __NDK_FPABI__; jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list) __NDK_FPABI__; jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*) __NDK_FPABI__; void (*CallNonvirtualVoidMethod)(JNIEnv*, jobject, jclass,jmethodID, ...); void (*CallNonvirtualVoidMethodV)(JNIEnv*, jobject, jclass,jmethodID, va_list); void (*CallNonvirtualVoidMethodA)(JNIEnv*, jobject, jclass,jmethodID, jvalue*); //获取各种字段 jfieldID (*GetFieldID)(JNIEnv*, jclass, const char*, const char*); jobject (*GetObjectField)(JNIEnv*, jobject, jfieldID); jboolean (*GetBooleanField)(JNIEnv*, jobject, jfieldID); jbyte (*GetByteField)(JNIEnv*, jobject, jfieldID); jchar (*GetCharField)(JNIEnv*, jobject, jfieldID); jshort (*GetShortField)(JNIEnv*, jobject, jfieldID); jint (*GetIntField)(JNIEnv*, jobject, jfieldID); jlong (*GetLongField)(JNIEnv*, jobject, jfieldID); jfloat (*GetFloatField)(JNIEnv*, jobject, jfieldID) __NDK_FPABI__; jdouble (*GetDoubleField)(JNIEnv*, jobject, jfieldID) __NDK_FPABI__; //设置各种字段，返回为空 void (*SetObjectField)(JNIEnv*, jobject, jfieldID, jobject); void (*SetBooleanField)(JNIEnv*, jobject, jfieldID, jboolean); void (*SetByteField)(JNIEnv*, jobject, jfieldID, jbyte); void (*SetCharField)(JNIEnv*, jobject, jfieldID, jchar); void (*SetShortField)(JNIEnv*, jobject, jfieldID, jshort); void (*SetIntField)(JNIEnv*, jobject, jfieldID, jint); void (*SetLongField)(JNIEnv*, jobject, jfieldID, jlong); void (*SetFloatField)(JNIEnv*, jobject, jfieldID, jfloat) __NDK_FPABI__; void (*SetDoubleField)(JNIEnv*, jobject, jfieldID, jdouble) __NDK_FPABI__; jmethodID (*GetStaticMethodID)(JNIEnv*, jclass, const char*, const char*); jobject (*CallStaticObjectMethod)(JNIEnv*, jclass, jmethodID, ...); jobject (*CallStaticObjectMethodV)(JNIEnv*, jclass, jmethodID, va_list); jobject (*CallStaticObjectMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jboolean (*CallStaticBooleanMethod)(JNIEnv*, jclass, jmethodID, ...); jboolean (*CallStaticBooleanMethodV)(JNIEnv*, jclass, jmethodID,va_list); jboolean (*CallStaticBooleanMethodA)(JNIEnv*, jclass, jmethodID,jvalue*); jbyte (*CallStaticByteMethod)(JNIEnv*, jclass, jmethodID, ...); jbyte (*CallStaticByteMethodV)(JNIEnv*, jclass, jmethodID, va_list); jbyte (*CallStaticByteMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jchar (*CallStaticCharMethod)(JNIEnv*, jclass, jmethodID, ...); jchar (*CallStaticCharMethodV)(JNIEnv*, jclass, jmethodID, va_list); jchar (*CallStaticCharMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jshort (*CallStaticShortMethod)(JNIEnv*, jclass, jmethodID, ...); jshort (*CallStaticShortMethodV)(JNIEnv*, jclass, jmethodID, va_list); jshort (*CallStaticShortMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jint (*CallStaticIntMethod)(JNIEnv*, jclass, jmethodID, ...); jint (*CallStaticIntMethodV)(JNIEnv*, jclass, jmethodID, va_list); jint (*CallStaticIntMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jlong (*CallStaticLongMethod)(JNIEnv*, jclass, jmethodID, ...); jlong (*CallStaticLongMethodV)(JNIEnv*, jclass, jmethodID, va_list); jlong (*CallStaticLongMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jfloat (*CallStaticFloatMethod)(JNIEnv*, jclass, jmethodID, ...) __NDK_FPABI__; jfloat (*CallStaticFloatMethodV)(JNIEnv*, jclass, jmethodID, va_list) __NDK_FPABI__; jfloat (*CallStaticFloatMethodA)(JNIEnv*, jclass, jmethodID, jvalue*) __NDK_FPABI__; jdouble (*CallStaticDoubleMethod)(JNIEnv*, jclass, jmethodID, ...) __NDK_FPABI__; jdouble (*CallStaticDoubleMethodV)(JNIEnv*, jclass, jmethodID, va_list) __NDK_FPABI__; jdouble (*CallStaticDoubleMethodA)(JNIEnv*, jclass, jmethodID, jvalue*) __NDK_FPABI__; void (*CallStaticVoidMethod)(JNIEnv*, jclass, jmethodID, ...); void (*CallStaticVoidMethodV)(JNIEnv*, jclass, jmethodID, va_list); void (*CallStaticVoidMethodA)(JNIEnv*, jclass, jmethodID, jvalue*); jfieldID (*GetStaticFieldID)(JNIEnv*, jclass, const char*,const char*); jobject (*GetStaticObjectField)(JNIEnv*, jclass, jfieldID); jboolean (*GetStaticBooleanField)(JNIEnv*, jclass, jfieldID); jbyte (*GetStaticByteField)(JNIEnv*, jclass, jfieldID); jchar (*GetStaticCharField)(JNIEnv*, jclass, jfieldID); jshort (*GetStaticShortField)(JNIEnv*, jclass, jfieldID); jint (*GetStaticIntField)(JNIEnv*, jclass, jfieldID); jlong (*GetStaticLongField)(JNIEnv*, jclass, jfieldID); jfloat (*GetStaticFloatField)(JNIEnv*, jclass, jfieldID) __NDK_FPABI__; jdouble (*GetStaticDoubleField)(JNIEnv*, jclass, jfieldID) __NDK_FPABI__; void (*SetStaticObjectField)(JNIEnv*, jclass, jfieldID, jobject); void (*SetStaticBooleanField)(JNIEnv*, jclass, jfieldID, jboolean); void (*SetStaticByteField)(JNIEnv*, jclass, jfieldID, jbyte); void (*SetStaticCharField)(JNIEnv*, jclass, jfieldID, jchar); void (*SetStaticShortField)(JNIEnv*, jclass, jfieldID, jshort); void (*SetStaticIntField)(JNIEnv*, jclass, jfieldID, jint); void (*SetStaticLongField)(JNIEnv*, jclass, jfieldID, jlong); void (*SetStaticFloatField)(JNIEnv*, jclass, jfieldID, jfloat) __NDK_FPABI__; void (*SetStaticDoubleField)(JNIEnv*, jclass, jfieldID, jdouble) __NDK_FPABI__; jstring (*NewString)(JNIEnv*, const jchar*, jsize); jsize (*GetStringLength)(JNIEnv*, jstring); const jchar*(*GetStringChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringChars)(JNIEnv*, jstring, const jchar*); jstring (*NewStringUTF)(JNIEnv*, const char*); jsize (*GetStringUTFLength)(JNIEnv*, jstring); const char* (*GetStringUTFChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringUTFChars)(JNIEnv*, jstring, const char*); jsize (*GetArrayLength)(JNIEnv*, jarray); jobjectArray(*NewObjectArray)(JNIEnv*, jsize, jclass, jobject); jobject (*GetObjectArrayElement)(JNIEnv*, jobjectArray, jsize); void (*SetObjectArrayElement)(JNIEnv*, jobjectArray, jsize, jobject); jbooleanArray (*NewBooleanArray)(JNIEnv*, jsize); jbyteArray (*NewByteArray)(JNIEnv*, jsize); jcharArray (*NewCharArray)(JNIEnv*, jsize); jshortArray (*NewShortArray)(JNIEnv*, jsize); jintArray (*NewIntArray)(JNIEnv*, jsize); jlongArray (*NewLongArray)(JNIEnv*, jsize); jfloatArray (*NewFloatArray)(JNIEnv*, jsize); jdoubleArray (*NewDoubleArray)(JNIEnv*, jsize); jboolean* (*GetBooleanArrayElements)(JNIEnv*, jbooleanArray, jboolean*); jbyte* (*GetByteArrayElements)(JNIEnv*, jbyteArray, jboolean*); jchar* (*GetCharArrayElements)(JNIEnv*, jcharArray, jboolean*); jshort* (*GetShortArrayElements)(JNIEnv*, jshortArray, jboolean*); jint* (*GetIntArrayElements)(JNIEnv*, jintArray, jboolean*); jlong* (*GetLongArrayElements)(JNIEnv*, jlongArray, jboolean*); jfloat* (*GetFloatArrayElements)(JNIEnv*, jfloatArray, jboolean*); jdouble* (*GetDoubleArrayElements)(JNIEnv*, jdoubleArray, jboolean*); void (*ReleaseBooleanArrayElements)(JNIEnv*, jbooleanArray,jboolean*, jint); void (*ReleaseByteArrayElements)(JNIEnv*, jbyteArray,jbyte*, jint); void (*ReleaseCharArrayElements)(JNIEnv*, jcharArray,jchar*, jint); void (*ReleaseShortArrayElements)(JNIEnv*, jshortArray,jshort*, jint); void (*ReleaseIntArrayElements)(JNIEnv*, jintArray,jint*, jint); void (*ReleaseLongArrayElements)(JNIEnv*, jlongArray,jlong*, jint); void (*ReleaseFloatArrayElements)(JNIEnv*, jfloatArray,jfloat*, jint); void (*ReleaseDoubleArrayElements)(JNIEnv*, jdoubleArray,jdouble*, jint); void (*GetBooleanArrayRegion)(JNIEnv*, jbooleanArray,jsize,jsize, jboolean*); void (*GetByteArrayRegion)(JNIEnv*, jbyteArray,jsize, jsize,jbyte*); void (*GetCharArrayRegion)(JNIEnv*, jcharArray, jsize, jsize,jchar*); void (*GetShortArrayRegion)(JNIEnv*, jshortArray,jsize, jsize,jshort*); void (*GetIntArrayRegion)(JNIEnv*, jintArray,jsize, jsize, jint*); void (*GetLongArrayRegion)(JNIEnv*, jlongArray,jsize, jsize, jlong*); void (*GetFloatArrayRegion)(JNIEnv*, jfloatArray,jsize, jsize, jfloat*); void (*GetDoubleArrayRegion)(JNIEnv*, jdoubleArray,jsize, jsize, jdouble*); void (*SetBooleanArrayRegion)(JNIEnv*, jbooleanArray,jsize, jsize, const jboolean*); void (*SetByteArrayRegion)(JNIEnv*, jbyteArray,jsize, jsize, const jbyte*); void (*SetCharArrayRegion)(JNIEnv*, jcharArray,jsize, jsize, const jchar*); void (*SetShortArrayRegion)(JNIEnv*, jshortArray,jsize, jsize, const jshort*); void (*SetIntArrayRegion)(JNIEnv*, jintArray,jsize, jsize, const jint*); void (*SetLongArrayRegion)(JNIEnv*, jlongArray, jsize, jsize, const jlong*); void (*SetFloatArrayRegion)(JNIEnv*, jfloatArray, jsize, jsize, const jfloat*); void (*SetDoubleArrayRegion)(JNIEnv*, jdoubleArray,jsize, jsize, const jdouble*); jint (*RegisterNatives)(JNIEnv*, jclass, const JNINativeMethod*,jint); jint (*UnregisterNatives)(JNIEnv*, jclass); jint (*MonitorEnter)(JNIEnv*, jobject); jint (*MonitorExit)(JNIEnv*, jobject); jint (*GetJavaVM)(JNIEnv*, JavaVM**); void (*GetStringRegion)(JNIEnv*, jstring, jsize, jsize, jchar*); void (*GetStringUTFRegion)(JNIEnv*, jstring, jsize, jsize, char*); void* (*GetPrimitiveArrayCritical)(JNIEnv*, jarray, jboolean*); void (*ReleasePrimitiveArrayCritical)(JNIEnv*, jarray, void*, jint); const jchar*(*GetStringCritical)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringCritical)(JNIEnv*, jstring, const jchar*); jweak (*NewWeakGlobalRef)(JNIEnv*, jobject); void (*DeleteWeakGlobalRef)(JNIEnv*, jweak); jboolean (*ExceptionCheck)(JNIEnv*); jobject (*NewDirectByteBuffer)(JNIEnv*, void*, jlong); void* (*GetDirectBufferAddress)(JNIEnv*, jobject); jlong (*GetDirectBufferCapacity)(JNIEnv*, jobject); jobjectRefType (*GetObjectRefType)(JNIEnv*, jobject);};/* * C++ */ //C++的JNI 本地接口结构体的调用struct _JNIEnv { const struct JNINativeInterface* functions;#if defined(__cplusplus) //各种函数 jint GetVersion() { return functions-&gt;GetVersion(this); } jclass DefineClass(const char *name, jobject loader, const jbyte* buf, jsize bufLen) { return functions-&gt;DefineClass(this, name, loader, buf, bufLen); } jclass FindClass(const char* name) { return functions-&gt;FindClass(this, name); } jmethodID FromReflectedMethod(jobject method) { return functions-&gt;FromReflectedMethod(this, method); } jfieldID FromReflectedField(jobject field) { return functions-&gt;FromReflectedField(this, field); } jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic) { return functions-&gt;ToReflectedMethod(this, cls, methodID, isStatic); } jclass GetSuperclass(jclass clazz) { return functions-&gt;GetSuperclass(this, clazz); } jboolean IsAssignableFrom(jclass clazz1, jclass clazz2) { return functions-&gt;IsAssignableFrom(this, clazz1, clazz2); } jobject ToReflectedField(jclass cls, jfieldID fieldID, jboolean isStatic) { return functions-&gt;ToReflectedField(this, cls, fieldID, isStatic); } jint Throw(jthrowable obj) { return functions-&gt;Throw(this, obj); } jint ThrowNew(jclass clazz, const char* message) { return functions-&gt;ThrowNew(this, clazz, message); } jthrowable ExceptionOccurred() { return functions-&gt;ExceptionOccurred(this); } void ExceptionDescribe() { functions-&gt;ExceptionDescribe(this); } void ExceptionClear() { functions-&gt;ExceptionClear(this); } void FatalError(const char* msg) { functions-&gt;FatalError(this, msg); } jint PushLocalFrame(jint capacity) { return functions-&gt;PushLocalFrame(this, capacity); } jobject PopLocalFrame(jobject result) { return functions-&gt;PopLocalFrame(this, result); } jobject NewGlobalRef(jobject obj) { return functions-&gt;NewGlobalRef(this, obj); } void DeleteGlobalRef(jobject globalRef) { functions-&gt;DeleteGlobalRef(this, globalRef); } void DeleteLocalRef(jobject localRef) { functions-&gt;DeleteLocalRef(this, localRef); } jboolean IsSameObject(jobject ref1, jobject ref2) { return functions-&gt;IsSameObject(this, ref1, ref2); } jobject NewLocalRef(jobject ref) { return functions-&gt;NewLocalRef(this, ref); } jint EnsureLocalCapacity(jint capacity) { return functions-&gt;EnsureLocalCapacity(this, capacity); } jobject AllocObject(jclass clazz) { return functions-&gt;AllocObject(this, clazz); } jobject NewObject(jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); jobject result = functions-&gt;NewObjectV(this, clazz, methodID, args); va_end(args); return result; } jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args) { return functions-&gt;NewObjectV(this, clazz, methodID, args); } jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args) { return functions-&gt;NewObjectA(this, clazz, methodID, args); } jclass GetObjectClass(jobject obj) { return functions-&gt;GetObjectClass(this, obj); } jboolean IsInstanceOf(jobject obj, jclass clazz) { return functions-&gt;IsInstanceOf(this, obj, clazz); } jmethodID GetMethodID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetMethodID(this, clazz, name, sig); }#define CALL_TYPE_METHOD(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype Call##_jname##Method(jobject obj, jmethodID methodID, ...) \\ { \\ _jtype result; \\ va_list args; \\ va_start(args, methodID); \\ result = functions-&gt;Call##_jname##MethodV(this, obj, methodID, \\ args); \\ va_end(args); \\ return result; \\ }#define CALL_TYPE_METHODV(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype Call##_jname##MethodV(jobject obj, jmethodID methodID, \\ va_list args) \\ { return functions-&gt;Call##_jname##MethodV(this, obj, methodID, args); }#define CALL_TYPE_METHODA(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype Call##_jname##MethodA(jobject obj, jmethodID methodID, \\ jvalue* args) \\ { return functions-&gt;Call##_jname##MethodA(this, obj, methodID, args); }#define CALL_TYPE(_jtype, _jname) \\ CALL_TYPE_METHOD(_jtype, _jname) \\ CALL_TYPE_METHODV(_jtype, _jname) \\ CALL_TYPE_METHODA(_jtype, _jname) CALL_TYPE(jobject, Object) CALL_TYPE(jboolean, Boolean) CALL_TYPE(jbyte, Byte) CALL_TYPE(jchar, Char) CALL_TYPE(jshort, Short) CALL_TYPE(jint, Int) CALL_TYPE(jlong, Long) CALL_TYPE(jfloat, Float) CALL_TYPE(jdouble, Double) void CallVoidMethod(jobject obj, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-&gt;CallVoidMethodV(this, obj, methodID, args); va_end(args); } void CallVoidMethodV(jobject obj, jmethodID methodID, va_list args) { functions-&gt;CallVoidMethodV(this, obj, methodID, args); } void CallVoidMethodA(jobject obj, jmethodID methodID, jvalue* args) { functions-&gt;CallVoidMethodA(this, obj, methodID, args); }#define CALL_NONVIRT_TYPE_METHOD(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallNonvirtual##_jname##Method(jobject obj, jclass clazz, \\ jmethodID methodID, ...) \\ { \\ _jtype result; \\ va_list args; \\ va_start(args, methodID); \\ result = functions-&gt;CallNonvirtual##_jname##MethodV(this, obj, \\ clazz, methodID, args); \\ va_end(args); \\ return result; \\ }#define CALL_NONVIRT_TYPE_METHODV(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallNonvirtual##_jname##MethodV(jobject obj, jclass clazz, \\ jmethodID methodID, va_list args) \\ { return functions-&gt;CallNonvirtual##_jname##MethodV(this, obj, clazz, \\ methodID, args); }#define CALL_NONVIRT_TYPE_METHODA(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallNonvirtual##_jname##MethodA(jobject obj, jclass clazz, \\ jmethodID methodID, jvalue* args) \\ { return functions-&gt;CallNonvirtual##_jname##MethodA(this, obj, clazz, \\ methodID, args); }#define CALL_NONVIRT_TYPE(_jtype, _jname) \\ CALL_NONVIRT_TYPE_METHOD(_jtype, _jname) \\ CALL_NONVIRT_TYPE_METHODV(_jtype, _jname) \\ CALL_NONVIRT_TYPE_METHODA(_jtype, _jname) CALL_NONVIRT_TYPE(jobject, Object) CALL_NONVIRT_TYPE(jboolean, Boolean) CALL_NONVIRT_TYPE(jbyte, Byte) CALL_NONVIRT_TYPE(jchar, Char) CALL_NONVIRT_TYPE(jshort, Short) CALL_NONVIRT_TYPE(jint, Int) CALL_NONVIRT_TYPE(jlong, Long) CALL_NONVIRT_TYPE(jfloat, Float) CALL_NONVIRT_TYPE(jdouble, Double) void CallNonvirtualVoidMethod(jobject obj, jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-&gt;CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args); va_end(args); } void CallNonvirtualVoidMethodV(jobject obj, jclass clazz, jmethodID methodID, va_list args) { functions-&gt;CallNonvirtualVoidMethodV(this, obj, clazz, methodID, args); } void CallNonvirtualVoidMethodA(jobject obj, jclass clazz, jmethodID methodID, jvalue* args) { functions-&gt;CallNonvirtualVoidMethodA(this, obj, clazz, methodID, args); } jfieldID GetFieldID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetFieldID(this, clazz, name, sig); } jobject GetObjectField(jobject obj, jfieldID fieldID) { return functions-&gt;GetObjectField(this, obj, fieldID); } jboolean GetBooleanField(jobject obj, jfieldID fieldID) { return functions-&gt;GetBooleanField(this, obj, fieldID); } jbyte GetByteField(jobject obj, jfieldID fieldID) { return functions-&gt;GetByteField(this, obj, fieldID); } jchar GetCharField(jobject obj, jfieldID fieldID) { return functions-&gt;GetCharField(this, obj, fieldID); } jshort GetShortField(jobject obj, jfieldID fieldID) { return functions-&gt;GetShortField(this, obj, fieldID); } jint GetIntField(jobject obj, jfieldID fieldID) { return functions-&gt;GetIntField(this, obj, fieldID); } jlong GetLongField(jobject obj, jfieldID fieldID) { return functions-&gt;GetLongField(this, obj, fieldID); } __NDK_FPABI__ jfloat GetFloatField(jobject obj, jfieldID fieldID) { return functions-&gt;GetFloatField(this, obj, fieldID); } __NDK_FPABI__ jdouble GetDoubleField(jobject obj, jfieldID fieldID) { return functions-&gt;GetDoubleField(this, obj, fieldID); } void SetObjectField(jobject obj, jfieldID fieldID, jobject value) { functions-&gt;SetObjectField(this, obj, fieldID, value); } void SetBooleanField(jobject obj, jfieldID fieldID, jboolean value) { functions-&gt;SetBooleanField(this, obj, fieldID, value); } void SetByteField(jobject obj, jfieldID fieldID, jbyte value) { functions-&gt;SetByteField(this, obj, fieldID, value); } void SetCharField(jobject obj, jfieldID fieldID, jchar value) { functions-&gt;SetCharField(this, obj, fieldID, value); } void SetShortField(jobject obj, jfieldID fieldID, jshort value) { functions-&gt;SetShortField(this, obj, fieldID, value); } void SetIntField(jobject obj, jfieldID fieldID, jint value) { functions-&gt;SetIntField(this, obj, fieldID, value); } void SetLongField(jobject obj, jfieldID fieldID, jlong value) { functions-&gt;SetLongField(this, obj, fieldID, value); } __NDK_FPABI__ void SetFloatField(jobject obj, jfieldID fieldID, jfloat value) { functions-&gt;SetFloatField(this, obj, fieldID, value); } __NDK_FPABI__ void SetDoubleField(jobject obj, jfieldID fieldID, jdouble value) { functions-&gt;SetDoubleField(this, obj, fieldID, value); } jmethodID GetStaticMethodID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetStaticMethodID(this, clazz, name, sig); }#define CALL_STATIC_TYPE_METHOD(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallStatic##_jname##Method(jclass clazz, jmethodID methodID, \\ ...) \\ { \\ _jtype result; \\ va_list args; \\ va_start(args, methodID); \\ result = functions-&gt;CallStatic##_jname##MethodV(this, clazz, \\ methodID, args); \\ va_end(args); \\ return result; \\ }#define CALL_STATIC_TYPE_METHODV(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallStatic##_jname##MethodV(jclass clazz, jmethodID methodID, \\ va_list args) \\ { return functions-&gt;CallStatic##_jname##MethodV(this, clazz, methodID, \\ args); }#define CALL_STATIC_TYPE_METHODA(_jtype, _jname) \\ __NDK_FPABI__ \\ _jtype CallStatic##_jname##MethodA(jclass clazz, jmethodID methodID, \\ jvalue* args) \\ { return functions-&gt;CallStatic##_jname##MethodA(this, clazz, methodID, \\ args); }#define CALL_STATIC_TYPE(_jtype, _jname) \\ CALL_STATIC_TYPE_METHOD(_jtype, _jname) \\ CALL_STATIC_TYPE_METHODV(_jtype, _jname) \\ CALL_STATIC_TYPE_METHODA(_jtype, _jname) CALL_STATIC_TYPE(jobject, Object) CALL_STATIC_TYPE(jboolean, Boolean) CALL_STATIC_TYPE(jbyte, Byte) CALL_STATIC_TYPE(jchar, Char) CALL_STATIC_TYPE(jshort, Short) CALL_STATIC_TYPE(jint, Int) CALL_STATIC_TYPE(jlong, Long) CALL_STATIC_TYPE(jfloat, Float) CALL_STATIC_TYPE(jdouble, Double) void CallStaticVoidMethod(jclass clazz, jmethodID methodID, ...) { va_list args; va_start(args, methodID); functions-&gt;CallStaticVoidMethodV(this, clazz, methodID, args); va_end(args); } void CallStaticVoidMethodV(jclass clazz, jmethodID methodID, va_list args) { functions-&gt;CallStaticVoidMethodV(this, clazz, methodID, args); } void CallStaticVoidMethodA(jclass clazz, jmethodID methodID, jvalue* args) { functions-&gt;CallStaticVoidMethodA(this, clazz, methodID, args); } jfieldID GetStaticFieldID(jclass clazz, const char* name, const char* sig) { return functions-&gt;GetStaticFieldID(this, clazz, name, sig); } jobject GetStaticObjectField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticObjectField(this, clazz, fieldID); } jboolean GetStaticBooleanField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticBooleanField(this, clazz, fieldID); } jbyte GetStaticByteField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticByteField(this, clazz, fieldID); } jchar GetStaticCharField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticCharField(this, clazz, fieldID); } jshort GetStaticShortField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticShortField(this, clazz, fieldID); } jint GetStaticIntField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticIntField(this, clazz, fieldID); } jlong GetStaticLongField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticLongField(this, clazz, fieldID); } __NDK_FPABI__ jfloat GetStaticFloatField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticFloatField(this, clazz, fieldID); } __NDK_FPABI__ jdouble GetStaticDoubleField(jclass clazz, jfieldID fieldID) { return functions-&gt;GetStaticDoubleField(this, clazz, fieldID); } void SetStaticObjectField(jclass clazz, jfieldID fieldID, jobject value) { functions-&gt;SetStaticObjectField(this, clazz, fieldID, value); } void SetStaticBooleanField(jclass clazz, jfieldID fieldID, jboolean value) { functions-&gt;SetStaticBooleanField(this, clazz, fieldID, value); } void SetStaticByteField(jclass clazz, jfieldID fieldID, jbyte value) { functions-&gt;SetStaticByteField(this, clazz, fieldID, value); } void SetStaticCharField(jclass clazz, jfieldID fieldID, jchar value) { functions-&gt;SetStaticCharField(this, clazz, fieldID, value); } void SetStaticShortField(jclass clazz, jfieldID fieldID, jshort value) { functions-&gt;SetStaticShortField(this, clazz, fieldID, value); } void SetStaticIntField(jclass clazz, jfieldID fieldID, jint value) { functions-&gt;SetStaticIntField(this, clazz, fieldID, value); } void SetStaticLongField(jclass clazz, jfieldID fieldID, jlong value) { functions-&gt;SetStaticLongField(this, clazz, fieldID, value); } __NDK_FPABI__ void SetStaticFloatField(jclass clazz, jfieldID fieldID, jfloat value) { functions-&gt;SetStaticFloatField(this, clazz, fieldID, value); } __NDK_FPABI__ void SetStaticDoubleField(jclass clazz, jfieldID fieldID, jdouble value) { functions-&gt;SetStaticDoubleField(this, clazz, fieldID, value); } jstring NewString(const jchar* unicodeChars, jsize len) { return functions-&gt;NewString(this, unicodeChars, len); } jsize GetStringLength(jstring string) { return functions-&gt;GetStringLength(this, string); } const jchar* GetStringChars(jstring string, jboolean* isCopy) { return functions-&gt;GetStringChars(this, string, isCopy); } void ReleaseStringChars(jstring string, const jchar* chars) { functions-&gt;ReleaseStringChars(this, string, chars); } jstring NewStringUTF(const char* bytes) { return functions-&gt;NewStringUTF(this, bytes); } jsize GetStringUTFLength(jstring string) { return functions-&gt;GetStringUTFLength(this, string); } const char* GetStringUTFChars(jstring string, jboolean* isCopy) { return functions-&gt;GetStringUTFChars(this, string, isCopy); } void ReleaseStringUTFChars(jstring string, const char* utf) { functions-&gt;ReleaseStringUTFChars(this, string, utf); } jsize GetArrayLength(jarray array) { return functions-&gt;GetArrayLength(this, array); } jobjectArray NewObjectArray(jsize length, jclass elementClass, jobject initialElement) { return functions-&gt;NewObjectArray(this, length, elementClass, initialElement); } jobject GetObjectArrayElement(jobjectArray array, jsize index) { return functions-&gt;GetObjectArrayElement(this, array, index); } void SetObjectArrayElement(jobjectArray array, jsize index, jobject value) { functions-&gt;SetObjectArrayElement(this, array, index, value); } jbooleanArray NewBooleanArray(jsize length) { return functions-&gt;NewBooleanArray(this, length); } jbyteArray NewByteArray(jsize length) { return functions-&gt;NewByteArray(this, length); } jcharArray NewCharArray(jsize length) { return functions-&gt;NewCharArray(this, length); } jshortArray NewShortArray(jsize length) { return functions-&gt;NewShortArray(this, length); } jintArray NewIntArray(jsize length) { return functions-&gt;NewIntArray(this, length); } jlongArray NewLongArray(jsize length) { return functions-&gt;NewLongArray(this, length); } jfloatArray NewFloatArray(jsize length) { return functions-&gt;NewFloatArray(this, length); } jdoubleArray NewDoubleArray(jsize length) { return functions-&gt;NewDoubleArray(this, length); } jboolean* GetBooleanArrayElements(jbooleanArray array, jboolean* isCopy) { return functions-&gt;GetBooleanArrayElements(this, array, isCopy); } jbyte* GetByteArrayElements(jbyteArray array, jboolean* isCopy) { return functions-&gt;GetByteArrayElements(this, array, isCopy); } jchar* GetCharArrayElements(jcharArray array, jboolean* isCopy) { return functions-&gt;GetCharArrayElements(this, array, isCopy); } jshort* GetShortArrayElements(jshortArray array, jboolean* isCopy) { return functions-&gt;GetShortArrayElements(this, array, isCopy); } jint* GetIntArrayElements(jintArray array, jboolean* isCopy) { return functions-&gt;GetIntArrayElements(this, array, isCopy); } jlong* GetLongArrayElements(jlongArray array, jboolean* isCopy) { return functions-&gt;GetLongArrayElements(this, array, isCopy); } jfloat* GetFloatArrayElements(jfloatArray array, jboolean* isCopy) { return functions-&gt;GetFloatArrayElements(this, array, isCopy); } jdouble* GetDoubleArrayElements(jdoubleArray array, jboolean* isCopy) { return functions-&gt;GetDoubleArrayElements(this, array, isCopy); } void ReleaseBooleanArrayElements(jbooleanArray array, jboolean* elems, jint mode) { functions-&gt;ReleaseBooleanArrayElements(this, array, elems, mode); } void ReleaseByteArrayElements(jbyteArray array, jbyte* elems, jint mode) { functions-&gt;ReleaseByteArrayElements(this, array, elems, mode); } void ReleaseCharArrayElements(jcharArray array, jchar* elems, jint mode) { functions-&gt;ReleaseCharArrayElements(this, array, elems, mode); } void ReleaseShortArrayElements(jshortArray array, jshort* elems, jint mode) { functions-&gt;ReleaseShortArrayElements(this, array, elems, mode); } void ReleaseIntArrayElements(jintArray array, jint* elems, jint mode) { functions-&gt;ReleaseIntArrayElements(this, array, elems, mode); } void ReleaseLongArrayElements(jlongArray array, jlong* elems, jint mode) { functions-&gt;ReleaseLongArrayElements(this, array, elems, mode); } void ReleaseFloatArrayElements(jfloatArray array, jfloat* elems, jint mode) { functions-&gt;ReleaseFloatArrayElements(this, array, elems, mode); } void ReleaseDoubleArrayElements(jdoubleArray array, jdouble* elems, jint mode) { functions-&gt;ReleaseDoubleArrayElements(this, array, elems, mode); } void GetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, jboolean* buf) { functions-&gt;GetBooleanArrayRegion(this, array, start, len, buf); } void GetByteArrayRegion(jbyteArray array, jsize start, jsize len, jbyte* buf) { functions-&gt;GetByteArrayRegion(this, array, start, len, buf); } void GetCharArrayRegion(jcharArray array, jsize start, jsize len, jchar* buf) { functions-&gt;GetCharArrayRegion(this, array, start, len, buf); } void GetShortArrayRegion(jshortArray array, jsize start, jsize len, jshort* buf) { functions-&gt;GetShortArrayRegion(this, array, start, len, buf); } void GetIntArrayRegion(jintArray array, jsize start, jsize len, jint* buf) { functions-&gt;GetIntArrayRegion(this, array, start, len, buf); } void GetLongArrayRegion(jlongArray array, jsize start, jsize len, jlong* buf) { functions-&gt;GetLongArrayRegion(this, array, start, len, buf); } void GetFloatArrayRegion(jfloatArray array, jsize start, jsize len, jfloat* buf) { functions-&gt;GetFloatArrayRegion(this, array, start, len, buf); } void GetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, jdouble* buf) { functions-&gt;GetDoubleArrayRegion(this, array, start, len, buf); } void SetBooleanArrayRegion(jbooleanArray array, jsize start, jsize len, const jboolean* buf) { functions-&gt;SetBooleanArrayRegion(this, array, start, len, buf); } void SetByteArrayRegion(jbyteArray array, jsize start, jsize len, const jbyte* buf) { functions-&gt;SetByteArrayRegion(this, array, start, len, buf); } void SetCharArrayRegion(jcharArray array, jsize start, jsize len, const jchar* buf) { functions-&gt;SetCharArrayRegion(this, array, start, len, buf); } void SetShortArrayRegion(jshortArray array, jsize start, jsize len, const jshort* buf) { functions-&gt;SetShortArrayRegion(this, array, start, len, buf); } void SetIntArrayRegion(jintArray array, jsize start, jsize len, const jint* buf) { functions-&gt;SetIntArrayRegion(this, array, start, len, buf); } void SetLongArrayRegion(jlongArray array, jsize start, jsize len, const jlong* buf) { functions-&gt;SetLongArrayRegion(this, array, start, len, buf); } void SetFloatArrayRegion(jfloatArray array, jsize start, jsize len, const jfloat* buf) { functions-&gt;SetFloatArrayRegion(this, array, start, len, buf); } void SetDoubleArrayRegion(jdoubleArray array, jsize start, jsize len, const jdouble* buf) { functions-&gt;SetDoubleArrayRegion(this, array, start, len, buf); } jint RegisterNatives(jclass clazz, const JNINativeMethod* methods, jint nMethods) { return functions-&gt;RegisterNatives(this, clazz, methods, nMethods); } jint UnregisterNatives(jclass clazz) { return functions-&gt;UnregisterNatives(this, clazz); } jint MonitorEnter(jobject obj) { return functions-&gt;MonitorEnter(this, obj); } jint MonitorExit(jobject obj) { return functions-&gt;MonitorExit(this, obj); } jint GetJavaVM(JavaVM** vm) { return functions-&gt;GetJavaVM(this, vm); } void GetStringRegion(jstring str, jsize start, jsize len, jchar* buf) { functions-&gt;GetStringRegion(this, str, start, len, buf); } void GetStringUTFRegion(jstring str, jsize start, jsize len, char* buf) { return functions-&gt;GetStringUTFRegion(this, str, start, len, buf); } void* GetPrimitiveArrayCritical(jarray array, jboolean* isCopy) { return functions-&gt;GetPrimitiveArrayCritical(this, array, isCopy); } void ReleasePrimitiveArrayCritical(jarray array, void* carray, jint mode) { functions-&gt;ReleasePrimitiveArrayCritical(this, array, carray, mode); } const jchar* GetStringCritical(jstring string, jboolean* isCopy) { return functions-&gt;GetStringCritical(this, string, isCopy); } void ReleaseStringCritical(jstring string, const jchar* carray) { functions-&gt;ReleaseStringCritical(this, string, carray); } jweak NewWeakGlobalRef(jobject obj) { return functions-&gt;NewWeakGlobalRef(this, obj); } void DeleteWeakGlobalRef(jweak obj) { functions-&gt;DeleteWeakGlobalRef(this, obj); } jboolean ExceptionCheck() { return functions-&gt;ExceptionCheck(this); } jobject NewDirectByteBuffer(void* address, jlong capacity) { return functions-&gt;NewDirectByteBuffer(this, address, capacity); } void* GetDirectBufferAddress(jobject buf) { return functions-&gt;GetDirectBufferAddress(this, buf); } jlong GetDirectBufferCapacity(jobject buf) { return functions-&gt;GetDirectBufferCapacity(this, buf); } /* added in JNI 1.6 */ jobjectRefType GetObjectRefType(jobject obj) { return functions-&gt;GetObjectRefType(this, obj); }#endif /*__cplusplus*/};/* * JNI invocation interface. */ //调用接口结构体JNIInvokeInterface的定义struct JNIInvokeInterface { void* reserved0; void* reserved1; void* reserved2; jint (*DestroyJavaVM)(JavaVM*); jint (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*); jint (*DetachCurrentThread)(JavaVM*); jint (*GetEnv)(JavaVM*, void**, jint); jint (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);};/* * C++ version. */struct _JavaVM { const struct JNIInvokeInterface* functions;#if defined(__cplusplus) jint DestroyJavaVM() { return functions-&gt;DestroyJavaVM(this); } jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) { return functions-&gt;AttachCurrentThread(this, p_env, thr_args); } jint DetachCurrentThread() { return functions-&gt;DetachCurrentThread(this); } jint GetEnv(void** env, jint version) { return functions-&gt;GetEnv(this, env, version); } jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) { return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); }#endif /*__cplusplus*/};struct JavaVMAttachArgs { jint version; /* must be &gt;= JNI_VERSION_1_2 */ const char* name; /* NULL or name of thread as modified UTF-8 str */ jobject group; /* global ref of a ThreadGroup object, or NULL */};typedef struct JavaVMAttachArgs JavaVMAttachArgs;/* * JNI 1.2+ initialization. (As of 1.6, the pre-1.2 structures are no * longer supported.) */typedef struct JavaVMOption { const char* optionString; void* extraInfo;} JavaVMOption;typedef struct JavaVMInitArgs { jint version; /* use JNI_VERSION_1_2 or later */ jint nOptions; JavaVMOption* options; jboolean ignoreUnrecognized;} JavaVMInitArgs;#ifdef __cplusplusextern &quot;C&quot; {#endif/* * VM initialization functions. * * Note these are the only symbols exported for JNI by the VM. */#if 0 /* In practice, these are not exported by the NDK so don't declare them */jint JNI_GetDefaultJavaVMInitArgs(void*);jint JNI_CreateJavaVM(JavaVM**, JNIEnv**, void*);jint JNI_GetCreatedJavaVMs(JavaVM**, jsize, jsize*);#endif#define JNIIMPORT#define JNIEXPORT __attribute__ ((visibility (&quot;default&quot;)))#define JNICALL __NDK_FPABI__/* * Prototypes for functions exported by loadable shared libs. These are * called by JNI, not provided by JNI. */JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM* vm, void* reserved);JNIEXPORT void JNICALL JNI_OnUnload(JavaVM* vm, void* reserved);#ifdef __cplusplus}#endif/* * Manifest constants. */#define JNI_FALSE 0#define JNI_TRUE 1#define JNI_VERSION_1_1 0x00010001#define JNI_VERSION_1_2 0x00010002#define JNI_VERSION_1_4 0x00010004#define JNI_VERSION_1_6 0x00010006#define JNI_OK (0) /* no error */#define JNI_ERR (-1) /* generic error */#define JNI_EDETACHED (-2) /* thread detached from the VM */#define JNI_EVERSION (-3) /* JNI version error */#define JNI_COMMIT 1 /* copy content, do not free buffer */#define JNI_ABORT 2 /* free buffer w/o copying back */#endif /* JNI_H_ */","link":"/20211201/JNI%E8%A7%84%E8%8C%83%E6%96%87%E6%A1%A3/"},{"title":"Hook All In Unidbg","text":"原文链接: https://blog.csdn.net/qq_38851536/category_11102404.html 更多Unidbg使用和算法还原的教程可见龙哥星球。 本文总结了Unidbg Hook and Call 的知识，部分Hook代码采用Frida 与 Unidbg 对照的方式，帮助熟悉Frida但不熟悉Unidbg的读者快速入门。样例前往百度云下载。 链接：https://pan.baidu.com/s/1ZRPtQrx4QAPEQhrpq6gbgg 提取码：6666 一、基础知识1.获取SO基地址Ⅰfrida 获取基地址1var baseAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;); Ⅱ Unidbg 获取基地址123456// 加载so到虚拟内存DalvikModule dm = vm.loadLibrary(&quot;libnative-lib.so&quot;, true);// 加载好的so对应为一个模块module = dm.getModule();// 打印libnative-lib.so在Unidbg虚拟内存中的基地址System.out.println(&quot;baseAddr:&quot;+module.base); 加载了多个SO的情况 1234// 获取某个具体SO的句柄Module yourModule = emulator.getMemory().findModule(&quot;yourModuleName&quot;);// 打印其基地址System.out.println(&quot;baseAddr:&quot;+yourModule.base); 如果只主动加载一个SO，其基址恒为0x40000000 ,这是一个检测Unidbg的点，可以在 com/github/unidbg/memory/Memory.java 中做修改 1234567891011public interface Memory extends IO, Loader, StackMemory { long STACK_BASE = 0xc0000000L; int STACK_SIZE_OF_PAGE = 256; // 1024k // 修改内存映射的起始地址 long MMAP_BASE = 0x40000000L; UnidbgPointer allocateStack(int size); UnidbgPointer pointer(long address); void setStackPoint(long sp); 2.获取函数地址Ⅰ Frida 获取导出函数地址1Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;) Ⅱ Unidbg 获取导出函数地址12345// 加载so到虚拟内存DalvikModule dm = vm.loadLibrary(&quot;libnative-lib.so&quot;, true);// 加载好的 libscmain.so对应为一个模块module = dm.getModule();int address = (int) module.findSymbolByName(&quot;funcNmae&quot;).getAddress(); Ⅲ Frida 获取非导出函数地址12var soAddr = Module.findBaseAddress(&quot;libnative-lib.so&quot;);var FuncAddr = soAddr.add(0x1768 + 1); Ⅳ Unidbg 获取非导出函数地址12345678// 加载so到虚拟内存DalvikModule dm = vm.loadLibrary(&quot;libnative-lib.so&quot;, true);// 加载好的so对应为一个模块module = dm.getModule();// offset，在IDA中查看int offset = 0x1768;// 真实地址 = baseAddr + offsetint address = (int) (module.base + offset); Hook 非导出函数时，不管是Frida还是Unidbg都需要考虑thumb2下地址+1的问题。 3.Unidbg Hook 大盘点Unidbg 在Android 上支持两大类Hook方案 Unidbg 内置的第三方Hook框架，包括xHook/Whale/HookZz Unicorn Hook以及基于它封装的Console Debugger，主要就指Console Debugger。 第一类是Unidbg支持并内置的第三方Hook框架，有Dobby(前身HookZz)/Whale这样的Inline Hook框架，也有xHook这样的PLT Hook 框架，支持这些Hook框架的使用，证明了Unidbg确实相对完善。但支持Frida还有很远的路要走，Frida比Dobby或者xHook都复杂的多，使用到了多线程、信号处理等Unidbg尚不支持的机制。总体来说，Dobby + Whale + xHook 也绝对够用了，没有非Frida不可的需求。 第二类是Unicorn Hook，只有当Unidbg的底层引擎选择为Unicorn时（默认引擎），才能使用。Unicorn提供了各种级别和粒度的Hook，内存Hook/指令/基本块 Hook/异常Hook 等等，十分强大，Unidbg基于它封装了更便于使用的Console Debugger，Unidbg也支持IDA/GDB的联合调试，但仍处于实验性质，不建议尝试。 该选择哪一类Hook方案？这得看使用Unidbg的目的。如果用于模拟执行，那么建议使用第一类Hook，为什么？这得从Unidbg支持的汇编执行引擎说起。Unidbg支持多种底层引擎，最早也是默认的引擎是Unicorn，从名字也能看出，Unidbg和Unicorn有很大关系。但后续Unidbg又支持了数个引擎，丰富了Unidbg的底层生态。但我们知道，任何提高程序复杂度的行为，肯定都为了解决什么问题。 hypervisor 引擎用于搭载了 Apple Silicon 芯片的设备； KVM 引擎用于树莓派； Dynarmic 引擎是为了更快的模拟执行； Unicorn 是最强大最完善的模拟执行引擎，但它相比Dynarmic太慢了，同场景下，Dynarmic比Unicorn模拟执行快数倍甚至十数倍。因此在生产环境中，采用 Dynarmic 引擎配上 unidbg-boot-server 实现高并发。 Dynarmic引擎使用 123456private static AndroidEmulator createARMEmulator() { return AndroidEmulatorBuilder.for32Bit() // 切换为Dynarmic引擎 .addBackendFactory(new DynarmicFactory(true)) .build();} Unicorn 默认引擎 1234private static AndroidEmulator createARMEmulator() { return AndroidEmulatorBuilder.for32Bit() .build();} 使用Unidbg的第二个场景是辅助算法还原，即模拟执行只作为算法还原的前奏，在模拟执行输出结果无误后，再使用Unidbg辅助算法还原。这种情况下对执行速度要求不高，那肯定使用更强大的Unicorn引擎。这时候两大类Hook方案都可以使用，选择哪类？我倾向于自始至终使用第二类方案，即基于Unicorn Hook的方案。 我个人认为有三点优势 HookZz或者xHook等方案，都可以基于其Hook实现原理进行检测，但Unicorn 原生Hook不容易被检测。 Unicorn Hook 没有局限，其他方案局限性较大。比如Inline Hook方案不能Hook短函数，或者两个相邻的地址；PLT Hook 不能 Hook Sub_xxx 子函数。 两类方案混用时，一定几率触发bug，事实上，单使用Unicorn的某些Hook功能都有bug，因此统一用原生Hook可以少一些bug。 总结如下 Ⅰ 以模拟执行为目的使用第三方Hook方案，arm32下HookZz的支持较好，arm64下Dobby的支持较好，HookZz/Dobby Hook不成功时，如果函数是导出函数就用xHook，否则使用 Whale。 Ⅱ 以算法还原为目的使用Console Debugger 和 Unicorn Hook，不优先使用第三方Hook方案。 4.本篇的基础代码即模拟执行demo的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.tutorial;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.arm.HookStatus;import com.github.unidbg.arm.backend.Backend;import com.github.unidbg.arm.backend.CodeHook;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.hook.HookContext;import com.github.unidbg.hook.ReplaceCallback;import com.github.unidbg.hook.hookzz.*;import com.github.unidbg.hook.whale.IWhale;import com.github.unidbg.hook.whale.Whale;import com.github.unidbg.hook.xhook.IxHook;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.XHookImpl;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.DvmClass;import com.github.unidbg.linux.android.dvm.DvmObject;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import com.github.unidbg.utils.Inspector;import com.sun.jna.Pointer;import unicorn.ArmConst;import unicorn.Unicorn;import java.io.File;public class hookInUnidbg { private final AndroidEmulator emulator; private final VM vm; private final Module module; hookInUnidbg() { // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for32Bit().build(); // 模拟器的内存操作接口 final Memory memory = emulator.getMemory(); // 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); // 创建Android虚拟机 vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&quot;));// emulator.attach().addBreakPoint(0x40000000+0xa80); // 加载so到虚拟内存 DalvikModule dm = vm.loadLibrary(&quot;hookinunidbg&quot;, true); // 加载好的 libhookinunidbg.so对应为一个模块 module = dm.getModule(); // 执行JNIOnLoad（如果有的话） dm.callJNI_OnLoad(emulator); } public void call(){ DvmClass dvmClass = vm.resolveClass(&quot;com/example/hookinunidbg/MainActivity&quot;); String methodSign = &quot;call()V&quot;; DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(null); dvmObject.callJniMethodObject(emulator, methodSign); } public static void main(String[] args) { hookInUnidbg mydemo = new hookInUnidbg(); mydemo.call(); }} 运行时有一些日志输出，为正常逻辑。 二、Hook 函数demo hookInunidbg中运行了数个函数，在本节中关注其中运行的base64_encode函数。 12unsigned intbase64_encode(const unsigned char *in, unsigned int inlen, char *out); 参数解释如下 char *out：一块buffer的首地址，用来存放转码后的内容。 char *in：原字符串的首地址，指向原字符串内容。 int inlen：原字符串长度。 返回值：正常情况下返回转换后字符串的实际长度。 本节的任务就是打印base64编码前的内容，以及编码后的内容。 1.Frida1234567891011121314151617181920212223242526272829// Frida Versionfunction main(){ // get base address of target so; var base_addr = Module.findBaseAddress(&quot;libhookinunidbg.so&quot;); if (base_addr){ var func_addr = Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;base64_encode&quot;); console.log(&quot;hook base64_encode function&quot;) Interceptor.attach(func_addr,{ // 打印入参 onEnter: function (args) { console.log(&quot;\\n input:&quot;) this.buffer = args[2]; var length = args[1]; console.log(hexdump(args[0],{length: length.toUInt32()})) console.log(&quot;\\n&quot;) }, // 打印返回值 onLeave: function () { console.log(&quot; output:&quot;) console.log(this.buffer.readCString()); } }) }}setImmediate(main); 2.Console DebuggerConsole Debugger 是快速打击、快速验证的交互调试器，在call JNIOnLoad之前下断点。 12// debugemulator.attach().addBreakPoint(module.findSymbolByName(&quot;base64_encode&quot;).getAddress()); 需要重申和强调几个概念 运行到对应地址时触发断点，类似于GDB调试或者IDA调试，时机为目标指令执行前。 断点不具有函数的种种概念，需要从汇编指令的角度去理解函数。 Console Debugger 用于辅助算法分析，快速分析、确认某个函数的功能。在Unicorn 引擎下才可以用。 针对第二条做补充 根据ARM ATPCS调用约定，当参数个数小于等于4个的时候，子程序间通过R0~R3来传递参数（即R0-R3代表参数1-参数4），如果参数个数大于4个，余下的参数通过sp所指向的数据栈进行参数传递。而函数的返回值总是通过R0传递回来。 以目标函数为例，函数调用前，调用方把三个参数依次放在R0-R2中。 立即数可以直接看，比如此处参数2是5。如果怀疑不是立即数而是指针，比如参数1和参数3，那么在交互调试中输入 mxx 查看其指向的内存，等价于Frida中的hexdump(xxx)。写法有两种，以此处r0为例，既可以 mr0 也可以 m0x400022e0 。 Unidbg 在数据展示上，相较于Frida Hexdump，有一些不同，体现在两方面 Frida hexdump时，左侧基地址从当前地址开始，而Unidbg从0开始。 Unidbg 给出了所打印数据块的md5值，方便对比两块数据块内容是否一致，而且还展示数据的Hex String，方便在大量日志中搜索。 Console Debugger 支持许多调试、分析的命令，如下： 12345678910111213141516171819202122232425262728293031323334353637383940c: continuen: step overbt: back tracest hex: search stackshw hex: search writable heapshr hex: search readable heapshx hex: search executable heapnb: break at next blocks|si: step intos[decimal]: execute specified amount instructions(blx): execute util BLX mnemonic, low performancem(op) [size]: show memory, default size is 0x70, size may hex or decimalmr0-mr7, mfp, mip, msp [size]: show memory of specified registerm(address) [size]: show memory of specified address, address must start with 0xwr0-wr7, wfp, wip, wsp &lt;value&gt;: write specified registerwb(address), ws(address), wi(address) &lt;value&gt;: write (byte, short, integer) memory of specified address, address must start with 0xwx(address) &lt;hex&gt;: write bytes to memory at specified address, address must start with 0xb(address): add temporarily breakpoint, address must start with 0x, can be module offsetb: add breakpoint of register PCr: remove breakpoint of register PCblr: add temporarily breakpoint of register LRp (assembly): patch assembly at PC addresswhere: show java stack tracetrace [begin end]: Set trace instructionstraceRead [begin end]: Set trace memory readtraceWrite [begin end]: Set trace memory writevm: view loaded modulesvbs: view breakpointsd|dis: show disassembled(0x): show disassemble at specify addressstop: stop emulationrun [arg]: run testcc size: convert asm from 0x400008a0 - 0x400008a0 + size bytes to c function 在Frida代码中，用 console.log(hexdump(args[0],{length: args[1].toUInt32()}))来打印 参数1指向的内存块，长度为参数2的值 ，Unidbg中同样可以指定长度。 1234567mr0 5&gt;-----------------------------------------------------------------------------&lt;[23:41:37 891]r0=RX@0x400022e0[libhookinunidbg.so]0x22e0, md5=f5704182e75d12316f5b729e89a499df, hex=6c696c6163size: 50000: 6C 69 6C 61 63 lilac^-----------------------------------------------------------------------------^ 目前Console Debugger 还不支持 mr0 r1这样的语法。 至此实现了Frida OnEnter的功能，接下来要获取OnLeave即函数执行完的时机。在ARM编程中，LR寄存器存放了程序的返回地址，当函数跑到LR所指向的地址时，意味着函数结束跳转了出来。又因为断点是在目标地址执行前触发，所以在LR处的断点断下时，目标函数执行完且刚执行完，这就是Frida OnLeave 时机点的原理。在Console Debugger交互调试中，使用 blr 命令可以在 lr 处下一个临时断点，它只会触发一次。 整体逻辑如下 在目标函数的地址处下断点 运行到断点处，进入Console Debugger 交互调试 mxx 系列查看参数 blr 在函数返回处下断点 c 使程序继续运行，到返回值处断下 查看此时的buffer 需要注意的是，在onLeave时机中通过mr2查看入参3是胡闹。R2只在程序入口处表示参数3，在函数运算的过程中，R2作为通用寄存器被用于存储、运算，它已经不是指向buffer的地址了。在Frida中也存在这个问题，所以我们在OnEnter里将args[2]即R2的值保存在this.buffer中，OnLeave中再取出来打印。而在Console Debugger交互调试中，办法更简单粗暴——鼠标往上拉一下，看看原来r2的值是什么，发现是0x401d2000，然后m0x401d2000即可。 这样我们就实现了Frida的等价功能。似乎有点麻烦，但熟练后你会发现Console Debugger 是最快最稳的Hook &amp; Debug 工具。除此之外，当函数被调用了三五百次时，我们不希望它反复停下来，然后不停“c”来继续运行。Console Debugger 也可以做持久化的Hook，代码如下。 123456789101112131415161718192021222324public void HookByConsoleDebugger(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;base64_encode&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext context = emulator.getContext(); Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); Pointer buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), &quot;base64 input&quot;); // OnLeave emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { // onHit返回ture时，断点触发时不会进入交互界面；为false时会。 String result = buffer.getString(0); System.out.println(&quot;base64 result:&quot;+result); return true; } }); return true; } });} 3.第三方Hook框架如下目标函数均在JNIOnLoad前调用 ⅠxHook123456789101112131415161718192021public void HookByXhook(){ IxHook xHook = XHookImpl.getInstance(emulator); xHook.register(&quot;libhookinunidbg.so&quot;, &quot;base64_encode&quot;, new ReplaceCallback() { @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) { Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); Pointer buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), &quot;base64 input&quot;); context.push(buffer); return HookStatus.RET(emulator, originFunction); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) { Pointer buffer = context.pop(); System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }, true); // 使其生效 xHook.refresh();} xHook是爱奇艺开源的Android PLT hook框架，优点是挺稳定好用，缺点是不能Hook Sub_xxx 子函数。这是其原理所限。 Ⅱ HookZz1234567891011121314151617181920public void HookByHookZz(){ IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz，支持inline hook hookZz.enable_arm_arm64_b_branch(); // 测试enable_arm_arm64_b_branch，可有可无 hookZz.wrap(module.findSymbolByName(&quot;base64_encode&quot;), new WrapCallback&lt;HookZzArm32RegisterContext&gt;() { @Override public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) { Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); Pointer buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), &quot;base64 input&quot;); context.push(buffer); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) { Pointer buffer = context.pop(); System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }); hookZz.disable_arm_arm64_b_branch();} HookZz 也可以实现类似于单行断点的Hook，但在Unidbg 的Hook大环境下感觉用处不大，不建议使用。 1234567IHookZz hookZz = HookZz.getInstance(emulator);hookZz.instrument(module.base + 0x978 + 1, new InstrumentCallback&lt;RegisterContext&gt;() { @Override public void dbiCall(Emulator&lt;?&gt; emulator, RegisterContext ctx, HookEntryInfo info) { System.out.println(ctx.getIntArg(0)); }}); HookZz是老名字，现在叫Dobby，Unidbg中HookZz和Dobby是两个独立的Hook库，因为Unidbg作者认为HookZz在arm32上支持较好，Dobby在arm64上支持较好。HookZz或者说Dobby采用的是inline hook方案，因此可以Hook Sub_xxx，缺点是短函数可能出bug，受限于其 inline Hook 原理。 Ⅲ Whale1234567891011121314151617181920public void HookByWhale(){ IWhale whale = Whale.getInstance(emulator); whale.inlineHookFunction(module.findSymbolByName(&quot;base64_encode&quot;), new ReplaceCallback() { Pointer buffer; @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, long originFunction) { RegisterContext context = emulator.getContext(); Pointer input = context.getPointerArg(0); int length = context.getIntArg(1); buffer = context.getPointerArg(2); Inspector.inspect(input.getByteArray(0, length), &quot;base64 input&quot;); return HookStatus.RET(emulator, originFunction); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) { System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }, true);} Whale 是一个跨平台的Hook框架，在Andorid Native Hook 上也是inline Hook方案，具体情况我了解不多。 4.Unicorn Hook如果想对某个函数进行集中的、高强度的、同时又灵活的调试，Unicorn CodeHook是一个好选择。比如我想查看目标函数第一条指令的r1，第二条指令的r2，第三条指令的r3，类似于这种需求。 hook_add_new 第一个参数是Hook回调，我们这里选择CodeHook，它是逐条指令Hook，参数2是起始地址，参数3是结束地址，参数4一般填null。这意味着从起始地址到终止地址这个执行范围内的每条指令，我们都可以在其执行前处理它。 找到目标函数的代码范围 123456789101112131415161718192021222324252627282930313233public void HookByUnicorn(){ long start = module.base+0x97C; long end = module.base+0x97C+0x17A; emulator.getBackend().hook_add_new(new CodeHook() { @Override public void hook(Backend backend, long address, int size, Object user) { RegisterContext registerContext = emulator.getContext(); if(address == module.base + 0x97C){ int r0 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R0); System.out.println(&quot;0x97C 处 r0:&quot;+Integer.toHexString(r0)); } if(address == module.base + 0x97C + 2){ int r2 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R2); System.out.println(&quot;0x97C +2 处 r2:&quot;+Integer.toHexString(r2)); } if(address == module.base + 0x97C + 4){ int r4 = registerContext.getIntByReg(ArmConst.UC_ARM_REG_R4); System.out.println(&quot;0x97C +4 处 r4:&quot;+Integer.toHexString(r4)); } } @Override public void onAttach(Unicorn.UnHook unHook) { } @Override public void detach() { } }, start, end, null);} 三、Replace 参数和返回值1.替换参数需求：入参改为hello world，对应的入参长度也要改，正确结果是 **aGVsbG8gd29ybGQ=**，供验证效果。 ⅠFrida12345678910111213141516171819202122232425262728// Frida Versionfunction main(){ // get base address of target so; var base_addr = Module.findBaseAddress(&quot;libhookinunidbg.so&quot;); if (base_addr){ var func_addr = Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;base64_encode&quot;); console.log(&quot;hook base64_encode function&quot;) var fakeinput = &quot;hello world&quot; var fakeinputPtr = Memory.allocUtf8String(fakeinput); Interceptor.attach(func_addr,{ onEnter: function (args) { args[0] = fakeinputPtr; args[1] = ptr(fakeinput.length); this.buffer = args[2]; }, // 打印返回值 onLeave: function () { console.log(&quot; output:&quot;) console.log(this.buffer.readCString()); } }) }}setImmediate(main); Ⅱ Console DebuggerConsole Debugger 如何实现这一目标？ ①下断点，运行代码后进入debugger 1emulator.attach().addBreakPoint(module.findSymbolByName(&quot;base64_encode&quot;).getAddress()); ②通过命令修改参数1和2，字符串得通过hexstring的形式传入 12345678910wx0x40002403 68656c6c6f20776f726c64&gt;-----------------------------------------------------------------------------&lt;[14:06:46 165]RX@0x40002403[libhookinunidbg.so]0x2403, md5=5eb63bbbe01eeed093cb22bb8f5acdc3, hex=68656c6c6f20776f726c64size: 110000: 68 65 6C 6C 6F 20 77 6F 72 6C 64 hello world^-----------------------------------------------------------------------------^wr1 11&gt;&gt;&gt; r1=0xb Console Debugger 支持下列写操作 123wr0-wr7, wfp, wip, wsp &lt;value&gt;: write specified registerwb(address), ws(address), wi(address) &lt;value&gt;: write (byte, short, integer) memory of specified address, address must start with 0xwx(address) &lt;hex&gt;: write bytes to memory at specified address, address must start with 0x 但这其实并不方便，还是做持久化比较舒服。 12345678910111213141516171819202122232425262728public void ReplaceArgByConsoleDebugger(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;base64_encode&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext context = emulator.getContext(); String fakeInput = &quot;hello world&quot;; int length = fakeInput.length(); // 修改r1值为新长度 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R1, length); MemoryBlock fakeInputBlock = emulator.getMemory().malloc(length, true); fakeInputBlock.getPointer().write(fakeInput.getBytes(StandardCharsets.UTF_8)); // 修改r0为指向新字符串的新指针 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, fakeInputBlock.getPointer().peer); Pointer buffer = context.getPointerArg(2); // OnLeave emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { String result = buffer.getString(0); System.out.println(&quot;base64 result:&quot;+result); return true; } }); return true; } });} Ⅲ 第三方Hook框架原理和Unicorn Hook完全不同，但得益于良好的封装，代码是类似的。 ① xHook 123456789101112131415161718192021222324252627public void ReplaceArgByXhook(){ IxHook xHook = XHookImpl.getInstance(emulator); xHook.register(&quot;libhookinunidbg.so&quot;, &quot;base64_encode&quot;, new ReplaceCallback() { @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) { String fakeInput = &quot;hello world&quot;; int length = fakeInput.length(); // 修改r1值为新长度 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R1, length); MemoryBlock fakeInputBlock = emulator.getMemory().malloc(length, true); fakeInputBlock.getPointer().write(fakeInput.getBytes(StandardCharsets.UTF_8)); // 修改r0为指向新字符串的新指针 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, fakeInputBlock.getPointer().peer); Pointer buffer = context.getPointerArg(2); context.push(buffer); return HookStatus.RET(emulator, originFunction); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookContext context) { Pointer buffer = context.pop(); System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }, true); // 使其生效 xHook.refresh();} ② HookZz 12345678910111213141516171819202122public void ReplaceArgByHookZz(){ IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz，支持inline hook hookZz.enable_arm_arm64_b_branch(); // 测试enable_arm_arm64_b_branch，可有可无 hookZz.wrap(module.findSymbolByName(&quot;base64_encode&quot;), new WrapCallback&lt;HookZzArm32RegisterContext&gt;() { @Override public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) { Pointer input = context.getPointerArg(0); String fakeInput = &quot;hello world&quot;; input.setString(0, fakeInput); context.setR1(fakeInput.length()); Pointer buffer = context.getPointerArg(2); context.push(buffer); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext context, HookEntryInfo info) { Pointer buffer = context.pop(); System.out.println(&quot;base64 result:&quot;+buffer.getString(0)); } }); hookZz.disable_arm_arm64_b_branch();} 因为可以用HookZzArm32RegisterContext，相对来说代码简单一些。 2.修改返回值修改返回值的逻辑和替换参数并没什么区别，但它可以引出第四节，所以还是仔细讲一下。 在demo 中，有一个verifyApkSign函数，它总是返回1，并导致APK校验失败，因此目标就是让它返回0。 12345678910111213141516extern &quot;C&quot;JNIEXPORT void JNICALLJava_com_example_hookinunidbg_MainActivity_call(JNIEnv *env, jobject thiz) { int verifyret = verifyApkSign(); if(verifyret == 1){ LOGE(&quot;APK sign verify failed!&quot;); } else{ LOGE(&quot;APK sign verify success!&quot;); } testBase64();}extern &quot;C&quot; int verifyApkSign(){ LOGE(&quot;verify apk sign&quot;); return 1;}; ⅠFrida1234567891011121314151617181920212223// Frida Versionfunction main(){ // get base address of target so; var base_addr = Module.findBaseAddress(&quot;libhookinunidbg.so&quot;); if (base_addr){ var func_addr = Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;verifyApkSign&quot;); console.log(&quot;hook verifyApkSign function&quot;) Interceptor.attach(func_addr,{ onEnter: function (args) { }, onLeave: function (retval) { // 修改返回值为0 retval.replace(0); } }) }}setImmediate(main); Ⅱ Console Debugger123456789101112131415161718public void ReplaceRetByConsoleDebugger(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;verifyApkSign&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext context = emulator.getContext(); // OnLeave emulator.attach().addBreakPoint(context.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { // 修改返回值为0 emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0); return true; } }); return true; } });} 我们的Hook生效了，但 verifyApkSign 函数里的log 还是打印出来了。在一些情况中，我们并不希望函数执行本来的逻辑，这就引出了第四节，即需要彻底的函数替换——替换并使用自己的函数。 四、替换函数1.Frida12345const verifyApkSignPtr = Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;verifyApkSign&quot;);Interceptor.replace(verifyApkSignPtr, new NativeCallback(() =&gt; { console.log(&quot;replace verifyApkSign Function&quot;) return 0;}, 'void', [])); Frida 这部分门道还挺多，但不是我们这里的重点。 2.第三方Hook框架这里只演示xHook 12345678910public void ReplaceFuncByHookZz(){ HookZz hook = HookZz.getInstance(emulator); hook.replace(module.findSymbolByName(&quot;verifyApkSign&quot;).getAddress(), new ReplaceCallback() { @Override public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) { emulator.getBackend().reg_write(Unicorn.UC_ARM_REG_R0,0); return HookStatus.RET(emulator,context.getLR()); } });} xHook的版本很清晰易懂，我们做了两件事 R0 赋值为0 LR 赋值给 PC，这意味着函数一行不执行就返回了，又因为R0赋值0所以返回值为0。 3.Console Debugger123456789101112public void ReplaceFuncByConsoleDebugger(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;verifyApkSign&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { System.out.println(&quot;替换函数 verifyApkSign&quot;); RegisterContext registerContext = emulator.getContext(); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_PC, registerContext.getLRPointer().peer); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0); return true; } });} 非常清晰易懂。 五、Call 函数分析具体算法时，常需要对其进行主动调用，进行更灵活和细致的分析。举两个例子 1是主动调用base64_encode 函数 2是一个更复杂一些的函数。 1.Frida2.Unidbg六、Patch 与内存检索1.PatchPatch 就是直接对二进制文件进行修改，Patch本质上只有两种形式 patch 二进制文件 在内存里 patch Patch的应用场景很多，有时候比Hook更简单好用，所以要介绍它。Patch 二进制文件大家都很熟悉，在IDA中使用KeyPatch即可。但这里我们关注内存Patch。 0x8CA处调用了签名校验函数，第三四节中通过Replace返回值或函数的方式来处理它，但实际上，修改0x8CA处这条四字节指令也是好办法。 需要注意的是，本文只讨论了arm32，指令集只考虑最常见的thumb2，arm以及arm64可以自行测试。 ⅠFrida①方法一 12345678var str_name_so = &quot;libhookinunidbg.so&quot;; //要hook的so名var n_addr_func_offset = 0x8CA; //要hook的函数在函数里面的偏移,thumb要+1var n_addr_so = Module.findBaseAddress(str_name_so);var n_addr_assemble = n_addr_so.add(n_addr_func_offset);Memory.protect(n_addr_assemble, 4, 'rwx'); // 修改内存属性,使程序段可写n_addr_assemble.writeByteArray([0x00, 0x20, 0x00, 0xBF]); 但这并不是最佳代码，Patch存在两个问题 是否存在多个线程同时读写这块内存？是否有冲突 arm 的缓存刷新机制 所以Frida 提供了更安全可靠的API来修改内存中的字节 ②方法二 123456789101112131415161718var str_name_so = &quot;libhookinunidbg.so&quot;; //要hook的so名var n_addr_func_offset = 0x8CA; //要hook的函数在函数里面的偏移,thumb要+1var n_addr_so = Module.findBaseAddress(str_name_so);var n_addr_assemble = n_addr_so.add(n_addr_func_offset);// safely modify bytes at addressMemory.patchCode(n_addr_assemble, 4, function () { // 以 thumb的方式获取一个patch对象 var cw = new ThumbWriter(n_addr_assemble); // 小端序 // 00 20 cw.putInstruction(0x2000) // 00 BF cw.putInstruction(0xBF00); cw.flush(); // 内存刷新 console.log(hexdump(n_addr_assemble))}); Ⅱ UnidbgUnidbg在修改内存上，既可以传机器码，也可以传汇编指令，方法一和方法二其实没区别。 ①方法一 12345public void Patch1(){ // 00 20 00 bf int patchCode = 0xBF002000; // movs r0,0 emulator.getMemory().pointer(module.base + 0x8CA).setInt(0,patchCode);} ②方法二 1234public void Patch2(){ byte[] patchCode = {0x00, 0x20, 0x00, (byte) 0xBF}; emulator.getBackend().mem_write(module.base + 0x8CA, patchCode);} ③方法三 1234567public void Patch3(){ try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) { KeystoneEncoded encoded = keystone.assemble(&quot;movs r0,0;nop&quot;); byte[] patchCode = encoded.getMachineCode(); emulator.getMemory().pointer(module.base + 0x8CA).write(0, patchCode, 0, patchCode.length); }} 2.内存检索假设SO存在碎片化，比如要分析某个SO的多个版本，需要Patch签名校验或者某处汇编，其地址在不同版本中不一样，而且不是导出函数。内存检索+Patch就是一个好办法，可以很好适应多版本、碎片化。 搜索特征片段，可能是搜索函数开头十字节，也可能是搜索目标地址上下字节或者其他特征。 ⅠFrida123456789101112131415161718192021222324function searchAndPatch() { var module = Process.findModuleByName(&quot;libhookinunidbg.so&quot;); var pattern = &quot;80 b5 6f 46 84 b0 03 90 02 91&quot; var matches = Memory.scanSync(module.base, module.size, pattern); console.log(matches.length) if (matches.length !== 0) { var n_addr_assemble = matches[0].address.add(10); // safely modify bytes at address Memory.patchCode(n_addr_assemble, 4, function () { // 以 thumb的方式获取一个patch对象 var cw = new ThumbWriter(n_addr_assemble); // 小端序 // 00 20 cw.putInstruction(0x2000) // 00 BF cw.putInstruction(0xBF00); cw.flush(); // 内存刷新 console.log(hexdump(n_addr_assemble)) }); }}setImmediate(searchAndPatch); Ⅱ Unidbg12345678910111213141516171819202122232425262728public void SearchAndPatch(){ byte[] patterns = {(byte) 0x80, (byte) 0xb5,0x6f,0x46, (byte) 0x84, (byte) 0xb0,0x03, (byte) 0x90,0x02, (byte) 0x91}; Collection&lt;Pointer&gt; pointers = searchMemory(module.base, module.base+module.size, patterns); if(pointers.size() &gt; 0){ try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb)) { KeystoneEncoded encoded = keystone.assemble(&quot;movs r0,0;nop&quot;); byte[] patchCode = encoded.getMachineCode(); ((ArrayList&lt;Pointer&gt;) pointers).get(0).write(10, patchCode, 0, patchCode.length); } }}private Collection&lt;Pointer&gt; searchMemory(long start, long end, byte[] data) { List&lt;Pointer&gt; pointers = new ArrayList&lt;&gt;(); for (long i = start, m = end - data.length; i &lt; m; i++) { byte[] oneByte = emulator.getBackend().mem_read(i, 1); if (data[0] != oneByte[0]) { continue; } if (Arrays.equals(data, emulator.getBackend().mem_read(i, data.length))) { pointers.add(UnidbgPointer.pointer(emulator, i)); i += (data.length - 1); } } return pointers;} 值得一提的是，本节的内容也可用 LIEF Patch二进制文件实现。 七、Hook时机过晚问题上文中，Hook代码都位于 SO加载后， 执行JNI_OnLoad之前，和如下Frida代码Spawn注入进程等价。 123456789101112131415161718var android_dlopen_ext = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);if (android_dlopen_ext != null) { Interceptor.attach(android_dlopen_ext, { onEnter: function (args) { this.hook = false; var soName = args[0].readCString(); if (soName.indexOf(&quot;libhookinunidbg.so&quot;) !== -1) { this.hook = true; } }, onLeave: function (retval) { if (this.hook) { this.hook = false; // your code } } });} 而Unidbg Hook代码位于JNI_OnLoad后时，和如下Frida代码Spawn注入进程等价 123456789101112131415161718192021222324252627282930var android_dlopen_ext = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);if (android_dlopen_ext != null) { Interceptor.attach(android_dlopen_ext, { onEnter: function (args) { this.hook = false; var soName = args[0].readCString(); if (soName.indexOf(&quot;libhookinunidbg.so&quot;) !== -1) { this.hook = true; } }, onLeave: function (retval) { if (this.hook) { this.hook = false; var jniOnload = Module.findExportByName(&quot;libhookinunidbg.so&quot;,&quot;JNI_OnLoad&quot;); if(jniOnload != null){ Interceptor.attach(jniOnload, { onEnter:function(args){ console.log(&quot;Enter libkwsgmain JNIOnLoad&quot;) }, onLeave:function(retval){ console.log(&quot;After libkwsgmain JNIOnLoad&quot;); // your code } }); } } } });} 但如果**.init和.init_array段**存在代码逻辑（init→init_array→JNIOnLoad），我们想捕获这个时机，那么上述的时机点都太晚了，这种情况下就需要将Hook时机点提前到init执行前。在Frida中，为了实现这一点，通常做法是Hook Linker中的call_function或call_constructor函数。 以我们的demo hookInUnidbg为例，其中init段里就有如下逻辑，比较两个字符串的大小。 123456789101112131415161718192021222324252627// 编译生成后在.init段 [名字不可更改]extern &quot;C&quot; void _init(void) { char str1[15]; char str2[15]; int ret; strcpy(str1, &quot;abcdef&quot;); strcpy(str2, &quot;ABCDEF&quot;); ret = strcmp(str1, str2); if(ret &lt; 0) { LOGI(&quot;str1 小于 str2&quot;); } else if(ret &gt; 0) { LOGI(&quot;str1 大于 str2&quot;); } else { LOGI(&quot;str1 等于 str2&quot;); }} 当前显示str1 大于 str2，我们的Hook目标是让其显示 str1 小于 str2。如果还想之前那样，在JNIOnLoad之前下断，是断不下来的，因为时机太晚了，Unidbg中可以使用下面几个办法。 1.提前加载libc提前加载libc，然后hook strcmp函数，修改其返回值为-1是一个办法。如下是完整代码，提供了Console Debugger 以及 HookZz 两个版本。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package com.tutorial;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.hook.hookzz.*;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import unicorn.ArmConst;import java.io.File;public class hookInUnidbg { private final AndroidEmulator emulator; private final VM vm; private final Module module; private final Module moduleLibc; hookInUnidbg() { // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for32Bit().build(); // 模拟器的内存操作接口 final Memory memory = emulator.getMemory(); // 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); // 创建Android虚拟机 vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&quot;)); // 先加载libc.so DalvikModule dmLibc = vm.loadLibrary(new File(&quot;unidbg-android/src/main/resources/android/sdk23/lib/libc.so&quot;), true); moduleLibc = dmLibc.getModule(); // hook hookStrcmpByUnicorn(); // 或者 // hookStrcmpByHookZz(); // 加载so到虚拟内存 DalvikModule dm = vm.loadLibrary(&quot;hookinunidbg&quot;, true); // 加载好的 libhookinunidbg.so对应为一个模块 module = dm.getModule(); // 执行JNIOnLoad（如果有的话） dm.callJNI_OnLoad(emulator); } public void call(){ DvmClass dvmClass = vm.resolveClass(&quot;com/example/hookinunidbg/MainActivity&quot;); String methodSign = &quot;call()V&quot;; DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(null); dvmObject.callJniMethodObject(emulator, methodSign); } public static void main(String[] args) { hookInUnidbg mydemo = new hookInUnidbg(); mydemo.call(); } public void hookStrcmpByUnicorn(){ emulator.attach().addBreakPoint(moduleLibc.findSymbolByName(&quot;strcmp&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext registerContext = emulator.getContext(); String arg1 = registerContext.getPointerArg(0).getString(0); emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { if(arg1.equals(&quot;abcdef&quot;)){ emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, -1); } return true; } }); return true; } }); } public void hookStrcmpByHookZz(){ IHookZz hookZz = HookZz.getInstance(emulator); // 加载HookZz，支持inline hook hookZz.enable_arm_arm64_b_branch(); // 测试enable_arm_arm64_b_branch，可有可无 hookZz.wrap(moduleLibc.findSymbolByName(&quot;strcmp&quot;), new WrapCallback&lt;HookZzArm32RegisterContext&gt;() { String arg1; @Override public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) { arg1 = ctx.getPointerArg(0).getString(0); } @Override public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContext ctx, HookEntryInfo info) { if(arg1.equals(&quot;abcdef&quot;)){ ctx.setR0(-1); } } }); hookZz.disable_arm_arm64_b_branch(); }} 但如果想hook的目标函数不是libc里的函数，就没效果了。比如想在0x978下个断点。 2.固定地址下断点这是最常用也最方便的方式，但只有Unicorn引擎下可以使用。 通过 vm.loadLibrary 加载的第一个用户SO，其基地址是0x40000000，因此可以在IDA中看函数偏移，通过绝对地址Console Debugger Hook。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.tutorial;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.hook.hookzz.*;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import unicorn.ArmConst;import java.io.File;public class hookInUnidbg { private final AndroidEmulator emulator; private final VM vm; private final Module module; private Module moduleLibc; hookInUnidbg() { // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for32Bit().build(); // 模拟器的内存操作接口 final Memory memory = emulator.getMemory(); // 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); // 创建Android虚拟机 vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&quot;)); emulator.attach().addBreakPoint(0x40000000 + 0x978); // 加载so到虚拟内存 DalvikModule dm = vm.loadLibrary(&quot;hookinunidbg&quot;, true); // 加载好的 libhookinunidbg.so对应为一个模块 module = dm.getModule(); // 执行JNIOnLoad（如果有的话） dm.callJNI_OnLoad(emulator); } public void call(){ DvmClass dvmClass = vm.resolveClass(&quot;com/example/hookinunidbg/MainActivity&quot;); String methodSign = &quot;call()V&quot;; DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(null); dvmObject.callJniMethodObject(emulator, methodSign); } public static void main(String[] args) { hookInUnidbg mydemo = new hookInUnidbg(); mydemo.call(); } } 如果加载了多个用户SO，可以先运行一遍代码，确认目标SO的基地址（Unidbg中不存在地址随机化，目标函数每次地址都固定。）然后在loadLibrary前Hook该地址，即可保证Hook不遗漏。 3.使用Unidbg提供的模块监听器实现自己的模块监听器 12345678910111213141516171819202122232425262728293031package com.tutorial;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.ModuleListener;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.hook.hookzz.HookEntryInfo;import com.github.unidbg.hook.hookzz.HookZz;import com.github.unidbg.hook.hookzz.InstrumentCallback;public class MyModuleListener implements ModuleListener { private HookZz hook; @Override public void onLoaded(Emulator&lt;?&gt; emulator, Module module) { // 提前加载Hook框架 if(module.name.equals(&quot;libc.so&quot;)){ hook = HookZz.getInstance(emulator); } // 在目标函数中Hook if(module.name.equals(&quot;libhookinunidbg.so&quot;)){ hook.instrument(module.base + 0x978 + 1, new InstrumentCallback&lt;RegisterContext&gt;() { @Override public void dbiCall(Emulator&lt;?&gt; emulator, RegisterContext ctx, HookEntryInfo info) { System.out.println(ctx.getIntArg(0)); } }); } }} 通过memory.addModuleListener绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.tutorial;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import java.io.File;public class hookInUnidbg{ private final AndroidEmulator emulator; private final VM vm; hookInUnidbg() { // 创建模拟器实例 emulator = AndroidEmulatorBuilder.for32Bit().build(); // 模拟器的内存操作接口 final Memory memory = emulator.getMemory(); // 添加模块加载监听器 memory.addModuleListener(new MyModuleListener()); // 设置系统类库解析 memory.setLibraryResolver(new AndroidResolver(23)); // 创建Android虚拟机 vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/tutorial/hookinunidbg.apk&quot;)); // 加载so到虚拟内存 DalvikModule dm = vm.loadLibrary(&quot;hookinunidbg&quot;, true); // 加载好的 libhookinunidbg.so对应为一个模块 Module module = dm.getModule(); // 执行JNIOnLoad（如果有的话） dm.callJNI_OnLoad(emulator); } public void call(){ DvmClass dvmClass = vm.resolveClass(&quot;com/example/hookinunidbg/MainActivity&quot;); String methodSign = &quot;call()V&quot;; DvmObject&lt;?&gt; dvmObject = dvmClass.newObject(null); dvmObject.callJniMethodObject(emulator, methodSign); } public static void main(String[] args) { hookInUnidbg mydemo = new hookInUnidbg(); mydemo.call(); }} 每种方法都有对应使用场景，按需使用。除此之外也可以修改Unidbg源码，在 callInitFunction函数前添加自己的逻辑。 八、条件断点在算法分析时，条件断点可以减少干扰信息。以strcmp为例，整个进程的所有模块都可能调用strcmp函数。 1.限定于某SOⅠFrida123456789101112Interceptor.attach( Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;), { onEnter: function(args) { var moduleName = Process.getModuleByAddress(this.returnAddress).name; console.log(&quot;strcmp arg1:&quot;+args[0].readCString()) // 可以根据moduleName筛选打印 console.log(&quot;call from :&quot;+moduleName) }, onLeave: function(ret) { } }); Ⅱ Unidbg123456789101112131415public void hookstrcmp(){ long address = module.findSymbolByName(&quot;strcmp&quot;).getAddress(); emulator.attach().addBreakPoint(address, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext registerContext = emulator.getContext(); String arg1 = registerContext.getPointerArg(0).getString(0); String moduleName = emulator.getMemory().findModuleByAddress(registerContext.getLRPointer().peer).name; if(moduleName.equals(&quot;libhookinunidbg.so&quot;)){ System.out.println(&quot;strcmp arg1:&quot;+arg1); } return true; } });} 在Unidbg中，“Hook限定于目标SO内”的使用场景可能不那么多，因为Unidbg虚拟进程里只有我们的目标SO在活跃，但Android系统中，目标进程里可能有数十个模块。当我们想hook strlen 来窥探目标SO里的字符串操作时，如果不加筛选，会被其他模块的大量调用干扰。或者我们想替换pthread_create函数，观察或者阻止子线程创建的时候，也会发现libart等模块也在创建子线程，除此之外替换时间等操作也都要注意这个问题。 123456789101112131415// 替换目标函数里对pthread_create的访问function hookPthreadCreate(){ var p_pthread_create = Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;); var pthread_create = new NativeFunction( p_pthread_create, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]); Interceptor.replace( p_pthread_create, new NativeCallback(function (ptr0, ptr1, ptr2, ptr3) { var moduleName = Process.getModuleByAddress(this.returnAddress).name; if (moduleName === &quot;target.so&quot;) { console.log(&quot;loading fake pthread_create&quot;); return -1; } else { return pthread_create(ptr0,ptr1,ptr2,ptr3); } }, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;, &quot;pointer&quot;]));} 2.限定于某函数比如某个函数在SO中被大量使用，现在只想分析这个函数在函数A中的使用。 ⅠFrida123456789101112131415161718192021222324var show = false;Interceptor.attach( Module.findExportByName(&quot;libc.so&quot;, &quot;strcmp&quot;), { onEnter: function(args) { if(show){ console.log(&quot;strcmp arg1:&quot;+args[0].readCString()) } }, onLeave: function(ret) { } });Interceptor.attach( Module.findExportByName(&quot;libhookinunidbg.so&quot;, &quot;targetfunction&quot;),{ onEnter: function(args) { show = this; }, onLeave: function(ret) { show = false; } }) Ⅱ Unidbg1234567891011121314151617181920212223242526272829303132// 早先声明全局变量 public boolean show = false;public void hookstrcmp(){ emulator.attach().addBreakPoint(module.findSymbolByName(&quot;targetfunction&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext registerContext = emulator.getContext(); show = true; emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { show = false; return true; } }); return true; } }); emulator.attach().addBreakPoint(module.findSymbolByName(&quot;strcmp&quot;).getAddress(), new BreakPointCallback() { @Override public boolean onHit(Emulator&lt;?&gt; emulator, long address) { RegisterContext registerContext = emulator.getContext(); String arg1 = registerContext.getPointerArg(0).getString(0); if(show){ System.out.println(&quot;strcmp arg1:&quot;+arg1); } return true; } });} 3.限定于某处 比如上图，只关注0xA00 处发生的strcmp。一个办法是hook strcmp函数，只在lr寄存器=module.base + 0xA00 + 4 + 1时打印输出。 另一个办法是Console Debugger ,也很方便。 12emulator.attach().addBreakPoint(module, 0xA00);emulator.attach().addBreakPoint(module, 0xA04); 一定要掌握这些知识，并做到灵活变通。在实际使用中，诸如“A hook生效后再打印B函数的输出“这样的需求是很常见的，否则每个函数都打印成百上千行会迷人眼，干扰对关键信息的寻找。 九、系统调用拦截——以时间为例这里说的系统调用拦截，并不是要对系统调用进行Hook，比如 frida - syscall - intercceptor 这样，系统调用全部是Unidbg自己实现的，日志一开就能看，显然也没有Hook的必要。Unidbg的系统调用拦截是为了替换系统调用，修改Unidbg中系统调用的实现。 有两个问题需要解释 为什么要修改系统调用？ Unidbg中部分系统调用没实现或者没实现好，以及有时候想要固定其输出，比如获取时间的系统调用，这些需求需要我们修复或修改Unidbg中系统调用的实现。 为什么不直接修改Unidbg源码 1是灵活性较差，2是我们的实现或修改并不是完美的，直接改Unidbg源码是对运行环境的污染，影响其他项目。 在分析算法时，输入不变的前提下，如果输出在不停变化，会干扰算法分析，这种情况的一大来源是时间戳参与了运算。在Frida中，为了控制这种干扰因素，常常会Hook libc的gettimeodfay这个时间获取函数。 1.Fridahook time 123456789101112var time = Module.findExportByName(null, &quot;time&quot;);if (time != null) { Interceptor.attach(time, { onEnter: function (args) { }, onLeave: function (retval) { // time返回秒级时间戳，修改返回值为100 retval.replace(100); } })} hook gettimeofday 1234567891011121314151617function hook_gettimeofday() { var addr_gettimeofday = Module.findExportByName(null, &quot;gettimeofday&quot;); var gettimeofday = new NativeFunction(addr_gettimeofday, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]); Interceptor.replace(addr_gettimeofday, new NativeCallback(function (ptr_tz, ptr_tzp) { var result = gettimeofday(ptr_tz, ptr_tzp); if (result == 0) { console.log(&quot;hook gettimeofday:&quot;, ptr_tz, ptr_tzp, result); var t = new Int32Array(ArrayBuffer.wrap(ptr_tz, 8)); t[0] = 0xAAAA; t[1] = 0xBBBB; console.log(hexdump(ptr_tz)); } return result; }, &quot;int&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]));} 但Frida做这件事并不容易做圆满，单是libc.so，就有time、gettimeodfay、clock_gettime、clock 这四个库函数可以获取时间戳，而且样本可以通过内联汇编使用系统调用，获取时间戳。 2.UnidbgUnidbg中可以更方便、更大范围的固定时间，不必像Frida那般。time和gettimeodfay库函数基于gettimeodfay这个系统调用，clock_gettime和clock基于clock_gettime系统调用。所以只要在Unidbg中固定gettimeodfay和clock_gettime这两个系统调用获取的时间戳，就可以一劳永逸。 首先实现时间相关的系统调用处理器，其中的*System.currentTimeMillis()和System.nanoTime()*改成定数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.tutorial;import com.github.unidbg.Emulator;import com.github.unidbg.linux.ARM32SyscallHandler;import com.github.unidbg.memory.SvcMemory;import com.github.unidbg.pointer.UnidbgPointer;import com.github.unidbg.unix.struct.TimeVal32;import com.github.unidbg.unix.struct.TimeZone;import com.sun.jna.Pointer;import unicorn.ArmConst;import java.util.Calendar;public class TimeSyscallHandler extends ARM32SyscallHandler { public TimeSyscallHandler(SvcMemory svcMemory) { super(svcMemory); } @Override protected boolean handleUnknownSyscall(Emulator emulator, int NR) { switch (NR) { case 78: // gettimeofday mygettimeofday(emulator); return true; case 263: // clock_gettime myclock_gettime(emulator); return true; } return super.handleUnknownSyscall(emulator, NR); } private void mygettimeofday(Emulator&lt;?&gt; emulator) { Pointer tv = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R0); Pointer tz = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1); emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, mygettimeofday(tv, tz)); }; private int mygettimeofday(Pointer tv, Pointer tz) { long currentTimeMillis = System.currentTimeMillis(); long tv_sec = currentTimeMillis / 1000; long tv_usec = (currentTimeMillis % 1000) * 1000; TimeVal32 timeVal = new TimeVal32(tv); timeVal.tv_sec = (int) tv_sec; timeVal.tv_usec = (int) tv_usec; timeVal.pack(); if (tz != null) { Calendar calendar = Calendar.getInstance(); int tz_minuteswest = -(calendar.get(Calendar.ZONE_OFFSET) + calendar.get(Calendar.DST_OFFSET)) / (60 * 1000); TimeZone timeZone = new TimeZone(tz); timeZone.tz_minuteswest = tz_minuteswest; timeZone.tz_dsttime = 0; timeZone.pack(); } return 0; } private static final int CLOCK_REALTIME = 0; private static final int CLOCK_MONOTONIC = 1; private static final int CLOCK_THREAD_CPUTIME_ID = 3; private static final int CLOCK_MONOTONIC_RAW = 4; private static final int CLOCK_MONOTONIC_COARSE = 6; private static final int CLOCK_BOOTTIME = 7; private final long nanoTime = System.nanoTime(); private int myclock_gettime(Emulator&lt;?&gt; emulator) { int clk_id = emulator.getBackend().reg_read(ArmConst.UC_ARM_REG_R0).intValue(); Pointer tp = UnidbgPointer.register(emulator, ArmConst.UC_ARM_REG_R1); long offset = clk_id == CLOCK_REALTIME ? System.currentTimeMillis() * 1000000L : System.nanoTime() - nanoTime; long tv_sec = offset / 1000000000L; long tv_nsec = offset % 1000000000L; switch (clk_id) { case CLOCK_REALTIME: case CLOCK_MONOTONIC: case CLOCK_MONOTONIC_RAW: case CLOCK_MONOTONIC_COARSE: case CLOCK_BOOTTIME: tp.setInt(0, (int) tv_sec); tp.setInt(4, (int) tv_nsec); return 0; case CLOCK_THREAD_CPUTIME_ID: tp.setInt(0, 0); tp.setInt(4, 1); return 0; } throw new UnsupportedOperationException(&quot;clk_id=&quot; + clk_id); }} 在自己的模拟器上使用它，原先模拟器创建是这么一句 12// 创建模拟器实例emulator = AndroidEmulatorBuilder.for32Bit().build(); 修改如下 123456789101112131415// 创建模拟器实例AndroidEmulatorBuilder builder = new AndroidEmulatorBuilder(false) { public AndroidEmulator build() { return new AndroidARMEmulator(processName, rootDir, backendFactories) { @Override protected UnixSyscallHandler&lt;AndroidFileIO&gt; createSyscallHandler(SvcMemory svcMemory) { return new TimeSyscallHandler(svcMemory); } }; }};emulator = builder.build(); 十、Hook 检测Anti Unidbg的方法浩如烟海，但事实上几乎没有主动Anti Unidbg的样本，有两方面原因 Unidbg 自身的多个重大弱点没有解决，比如多线程和信号机制尚未实现。 Unidbg 普及率和推广度还不高。 所以本节专注于Hook 检测。 1.检测第三方Hook框架基于其Hook实现原理，可以对应检测。 ⅠInline Hook以我熟悉的inline Hook 检测为例，inline Hook 需要修改Hook处的前几个字节，跳转到自己的地方实现逻辑，最后再跳转回来。那么就有两类思路实现检测，首先开辟一个检测线程，对关键函数做如下二选一循环操作 函数开头前几个字节是否被篡改 函数体是否完整未被修改，常使用crc32校验，为什么不用md5或其他哈希函数？因为crc32极快，性能影响小，碰撞率又在可接受的范围内 相关项目：check_fish_inline_hook Ⅱ Got Hook相关项目：SliverBullet5563/CheckGotHook: 检测got hook（使用xhook测试） 2.检测Unicorn Based HookUnicorn Hook 似乎不可检测，但Unicorn也是可检测的。在星球的Anti-Unidbg系列，就提到过一种检测方式。在Android系统中，只支持对四字节对齐的内存地址做读写操作，所以通过内联汇编尝试向SP+1的位置做读写，在真机上会导致App崩溃，而Unidbg模拟执行不会出任何问题。当然，我们并不希望App崩溃，所以需要在代码中实现自己的信号处理函数，当此处发生异常时，信号处理函数接收信号并做出某种处理，因为Unidbg中程序不会异常，所以也不会走到信号处理函数，这里面可以设计形成差异。 除此之外，Unicorn下断点调试或者做指令追踪时，必然会导致函数运行时间超出常理，基于运行时间的反调试策略也可行。 十一、Unidbg Trace 五件套基于Frida 存在许多trace 方案，比如用于 trace JNI函数的 JNItrace，用于trace Java调用的 ZenTrace、r0tracer，又或者是官方的多功能 trace 工具 frida-trace，用于指令级 trace 的 Frida Stalker，又或者是trace SO中所有函数的 trace_natives ，以及Linux上著名的strace 或者 基于Frida 的 frida-syscall-interceptor，用于 trace 系统调用。 在Unidbg 上，上述的大部分trace，只需要调整日志等级就能实现。我们这里所讲的trace，聚焦于如何让使用者对代码执行流有更强的掌控。 1.Instruction tracing令追踪包括两部分 记录每条指令的执行，打印地址、机器码、汇编等信息 打印每条指令相关的寄存器值 Unidbg 基于 Unicorn CodeHook 封装了指令追踪，方法和效果如下 1234567/** * trace instruction * note: low performance */TraceHook traceCode();TraceHook traceCode(long begin, long end);TraceHook traceCode(long begin, long end, TraceCodeListener listener); Unidbg的指令追踪，在第一部分的工作做得很好，采用 模块名+相对偏移+机器码+绝对地址+汇编 的展示形式，但美中不足的是，它并没有做第二部分的工作，可以使用如下的脚本在Unidbg中实现完善的指令追踪，其原理也是实现了一个自己的codehook。 增加trace的部分 by dqzg12300 · Pull Request #214 2.Function Tracing指令Trace是最细粒度的Trace，优点是细，缺点是动辄数百上千万行，让人迷失其中。函数粒度的trace则不然，粗糙但容易理解全貌，在算法还原的一些场景中会起到帮助。在IDA Debug中，即可选择函数追踪来记录函数调用，包括了有符号函数以及IDA识别并命名为Sub_addr的子函数。 在Frida上，可以使用 trace_natives 对 一个SO中的全部函数进行Trace，并形成如下调用图。 Unidbg中可以做到这一点吗？不妨看一下 Frida trace_natives 脚本，其中有三个关注点。 如何获得一个SO的全部函数列表，就像IDA一样 如何Hook函数 如何获得调用层级关系，形成树结构 关于问题1，trace_natives怎么解决的？直接编写IDA脚本获取IDA的函数列表 12345678910def getFunctionList(): functionlist = &quot;&quot; minLength = 10 maxAddress = ida_ida.inf_get_max_ea() for func in idautils.Functions(0, maxAddress): if len(list(idautils.FuncItems(func))) &gt; minLength: functionName = str(idaapi.ida_funcs.get_func_name(func)) oneFunction = hex(func) + &quot;!&quot; + functionName + &quot;\\t\\n&quot; functionlist += oneFunction return functionlist 脚本获取了函数以及对应函数名列表，同时通过minLength过滤较短的函数，至少包含10条汇编指令的函数才会被计入。这么做有两个原因 过短的函数可能导致Frida Hook失败（inline hook 原理所致） 过短的函数可能是工具函数，调用次数多，但价值不大，让调用图变得臃肿不堪 完整的IDA插件 getFunctions 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import osimport timeimport ida_idaimport ida_naltimport idaapiimport idautilsfrom idaapi import plugin_tfrom idaapi import PLUGIN_PROCfrom idaapi import PLUGIN_OKdef getFunctionList(): functionlist = &quot;&quot; minLength = 10 maxAddress = ida_ida.inf_get_max_ea() for func in idautils.Functions(0, maxAddress): if len(list(idautils.FuncItems(func))) &gt; minLength: functionName = str(idaapi.ida_funcs.get_func_name(func)) oneFunction = hex(func) + &quot;!&quot; + functionName + &quot;\\t\\n&quot; functionlist += oneFunction return functionlist# 获取SO文件名和路径def getSoPathAndName(): fullpath = ida_nalt.get_input_file_path() filepath, filename = os.path.split(fullpath) return filepath, filenameclass getFunctions(plugin_t): flags = PLUGIN_PROC comment = &quot;getFunctions&quot; help = &quot;&quot; wanted_name = &quot;getFunctions&quot; wanted_hotkey = &quot;&quot; def init(self): print(&quot;getFunctions(v0.1) plugin has been loaded.&quot;) return PLUGIN_OK def run(self, arg): so_path, so_name = getSoPathAndName() functionlist = getFunctionList() script_name = so_name.split(&quot;.&quot;)[0] + &quot;_functionlist_&quot; + str(int(time.time())) + &quot;.txt&quot; save_path = os.path.join(so_path, script_name) with open(save_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as F: F.write(functionlist) F.close() print(f&quot;location: {save_path}&quot;) def term(self): passdef PLUGIN_ENTRY(): return getFunctions() 关于问题2：使用Frida Native Hook 关于问题3：Frida的frida-trace自带调用层级关系，所以trace_Natives脚本依赖Frida-trace，展示出了树结构的调用图。分析源码发现，frida-trace 使用了Frida在 Interceptor.attach 环境中的depth 如下代码中的this.depth），depth表示了调用深度。那深度的值哪来的呢？其最终依赖于Frida的栈回溯。 123456789101112131415161718192021222324Interceptor.attach(Module.getExportByName(null, 'read'), { onEnter(args) { console.log('Context information:'); console.log('Context : ' + JSON.stringify(this.context)); console.log('Return : ' + this.returnAddress); console.log('ThreadId : ' + this.threadId); console.log('Depth : ' + this.depth); console.log('Errornr : ' + this.err); // Save arguments for processing in onLeave. this.fd = args[0].toInt32(); this.buf = args[1]; this.count = args[2].toInt32(); }, onLeave(result) { console.log('----------') // Show argument 1 (buf), saved during onEnter. const numBytes = result.toInt32(); if (numBytes &gt; 0) { console.log(hexdump(this.buf, { length: numBytes, ansi: true })); } console.log('Result : ' + numBytes); }}) 这三个问题能在Unidbg中解决吗？如果能解决，那就有了Unidbg 版的Function Tracing。 首先问题一，只是一个获取函数列表的插件，与使用Frida还是Unidbg无关，构不成问题。我们还可以更进一步思考，trace_Natives 依赖IDA实现对SO 函数的识别，但与此同时也增加了使用的复杂度，而且加壳的SO无法直接识别函数，必须得先dump+fix SO，其实还挺折腾人，不如不依赖IDA，换个办法识别函数。ARM中，函数序言常常以 push 指令开始，这可以代表绝大多数函数。配合Unidbg的BlockHook 或者 CodeHook，就可以解析并 Hook 这些函数，问题二也顺带解决了。少部分函数会遗漏，但也无关痛痒。BlockHook 还会提供当前基本块的大小，我们设置对较小的块不予理睬。 接下来就是问题三，栈回溯这块，Unidbg也实现了arm unwind栈回溯，一些情况下有Bug，但总体应该能用。但Unidbg没有提供打印深度的函数，在Unwinder类中添加一个它。 src/main/java/com/github/unidbg/unwind/Unwinder.java 1234567891011public final int depth(){ int count = 0; Frame frame = null; while((frame = unw_step(emulator, frame)) != null) { if(frame.isFinish()){ return count; } count++; } return count;} 接下来三步骤合一，组装代码 12345678910111213141516171819202122232425262728293031323334353637PrintStream traceStream = null;try { // 保存文件 String traceFile = &quot;unidbg-android/src/test/resources/app/traceFunctions.txt&quot;; traceStream = new PrintStream(new FileOutputStream(traceFile), true);} catch (FileNotFoundException e) { e.printStackTrace();}final PrintStream finalTraceStream = traceStream;emulator.getBackend().hook_add_new(new BlockHook() { @Override public void hookBlock(Backend backend, long address, int size, Object user) { if(size&gt;8){ Capstone.CsInsn[] insns = emulator.disassemble(address, 4, 0); if(insns[0].mnemonic.equals(&quot;push&quot;)){ int level = emulator.getUnwinder().depth(); assert finalTraceStream != null; for(int i = 0 ; i &lt; level ; i++){ finalTraceStream.print(&quot; | &quot;); } finalTraceStream.println(&quot; &quot;+&quot;sub_&quot;+Integer.toHexString((int) (address-module.base))+&quot; &quot;); } } } @Override public void onAttach(Unicorn.UnHook unHook) { } @Override public void detach() { }}, module.base, module.base+module.size, 0); 可以发现代码非常的简洁优雅，效果也不错 它还有三个明显的缺陷 1是时机过晚，init或者init_arrayz里的内容无法Hook到，可以结合第七节的方法进行完善。 2是有符号的函数也以sub_xxx 显示 3是导入表中的函数无法包括在内，因为原理上讲，只扫描so内push开头的函数。 3.Memory Search4.Unidbg-FindKeyUnidbg_FindKey 这是我写的小工具，具体原理见星球，目前支持查找AES-128/AES-256的密钥，理论上还可以将更多的加密算法包括进去，只需要算法满足以下三点： 1.程序的预处理（最典型的场景即密钥编排）会产生某个结构 2.这个结构是可分辨的 3.这个结构可以解码出原始Key AES完美符合这三点，SM4也很适用，过往的研究表明，DES、RSA、TwoFish、Separnt等加密算法都满足或者部分满足上述三条件。 5.Unidbg-FindcryptFindcrypt是老牌经典工具，Unidbg版的Findcrypt是要做啥？解决什么痛点？有三个主要原因 Findcrypt 处理不了加壳SO Findcrypt 中说存在某种加密，但SO中并不一定用，我们的目标函数更不一定用。 从Findcrypt提示的常数不一定能找到对应函数，静态交叉分析有局限 // TODO 十二、固定随机数// TODO 十三、杂项无需Hook，Unidbg中通过其他方式实现 // TODO","link":"/20220106/Hook-All-In-Unidbg/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"安卓逆向","slug":"安卓逆向","link":"/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"爬虫","slug":"爬虫","link":"/tags/%E7%88%AC%E8%99%AB/"},{"name":"破解","slug":"破解","link":"/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"主题配置","slug":"主题配置","link":"/tags/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Unidbg","slug":"Unidbg","link":"/tags/Unidbg/"},{"name":"Win逆向","slug":"Win逆向","link":"/tags/Win%E9%80%86%E5%90%91/"},{"name":"xpath","slug":"xpath","link":"/tags/xpath/"},{"name":"Frida","slug":"Frida","link":"/tags/Frida/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"安卓逆向","slug":"安卓逆向","link":"/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"},{"name":"爬虫","slug":"爬虫","link":"/categories/%E7%88%AC%E8%99%AB/"},{"name":"破解","slug":"破解","link":"/categories/%E7%A0%B4%E8%A7%A3/"},{"name":"主题配置","slug":"主题配置","link":"/categories/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"自动化","slug":"自动化","link":"/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"Unidbg","slug":"Unidbg","link":"/categories/Unidbg/"},{"name":"Win逆向","slug":"Win逆向","link":"/categories/Win%E9%80%86%E5%90%91/"},{"name":"Frida","slug":"Frida","link":"/categories/Frida/"}]}