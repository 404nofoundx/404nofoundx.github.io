{"pages":[],"posts":[{"title":"ARM汇编小结","text":"一、ARM汇编规范1、书写规范 所有的符号都必须在一行书写，在后面不用添加高级语言所用的分号。 ARM汇编器对标识符的大小写敏感，书写符号以及指令时字母大小写一定要一致。 一条ARM指令，伪指令。寄存器名可以全部写为大写字母,也可以全部为小写字母, 但是不能大小写混合编写使用。 注释使用(分号)，注释内容由(分号)开始到执行结束。 例如：[符号] &lt;指令|条件|S&gt; &lt;操作数&gt;[;注释] 2、符号符号可以代表地址、变量、数字变量，当符号代表地址时又叫标号，符号就是变量的变量名、数字常量的名称、标号，符号的命名规则如下： 符号由大小写字母、数字以及下划线组成； 除局部标号以数字开头外，其它的符号不能以数字开头； 符号区分大小写，且所有字符都是有意义的； 符号在其作用域范围必须是唯一的； 符号不能与系统内部或系统预定义的符号同名； 符号不要与指令助记符、伪指令同名。 3、常量常量的分类：数字常数、字符常量、布尔常量 （1）数字常数有三种表示方式： 十进制数，如：12、5、876、0 十六进制数如：0x4387、0xFF0、0x1 n 进制数用n-XXX 表示，其中n 为2～9，XXX 为具体的数，如：2-010111、8-4363156 （2）字符常量 字符常量由一对单引号及中间字符串表示，标准C 语言中的转义符也可使用。如果需要包含双引号或$，必须使用”” “”和$$代替。 如：Hello SETS “Hello World！” Errorl SETS “The parameter ““VFH””error$$2” （3）布尔常量 布尔常量的逻辑真为{TRUE}，逻辑假为{FALSE}。 如： testno SETS {FALSE} 4、ARM指令的格式ARM是三地址指令格式，指令的基本格式为： 1234567&lt;opcode&gt; {&lt;cond&gt;} {s} &lt;Rd&gt;, &lt;Rn&gt; {,&lt;operand2&gt;} opcode: 指令助记符 cond: 执行条件 s: 是否影响CPSR寄存器的值 Rd: 目标寄存器 Rn: 第一个操作数的寄存器 operand2: 第二个操作数 其中&lt; &gt;号内为必须的，{ }里面的项是可选的 5、跳转指令B 无条件跳转 BEQ 相等后跳转 BNE 不相等后跳转 BL 带链接的无条件跳转 BX 带状态切换的无条件跳转 根据目标地址最低位切换状态（arm/thumb） BLX 带链接和状态切换的无条件跳转 B loc_地址 6.存储器与寄存器交互数据指令存储器（主存，内存）寄存器中放的数据：可以是字符串，可以是数，也可以是一个地址，它可以放各种类型的数据存储地址单元：地址（如0x00004000）与地址中存在的值 A、LDR指令 (Load from memory into register)LDR指令的格式： LDR{条件} 目的寄存器 &lt;存储器地址&gt; 作用：将存储器地址所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 ← LDR指令的寻址方式比较灵活,实例如下： 123456789101112131415161718192021LDR R0，[R1] ；将存储器地址为R1的字数据读入寄存器R0。LDR R0，[R1，R2] ；将存储器地址为R1+R2的字数据读入寄存器R0。LDR R0，[R1，#8] ；将存储器地址为R1+8的字数据读入寄存器R0。LDR R0，[R1],R2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1],#8 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+8的值存入R1。LDR R0，[R1，R2]! ；将存储器地址为R1+R2的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1，LSL #3] ；将存储器地址为R1*8的字数据读入寄存器R0。LDR R0，[R1，R2，LSL #2] ；将存储器地址为R1+R2*4的字数据读入寄存器R0。LDR R0，[R1,,R2，LSL #2]！ ；将存储器地址为R1+R2*4的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，[R1],R2，LSL #2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，Label ；Label为程序标号，Label必须是当前指令的-4~4KB范围内。 B、STR指令 (Store from a register into memory)STR指令的格式为： STR{条件} 源寄存器，&lt;存储器地址&gt; STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。→ 123456STR r1, [r0] ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中STR R0，[R1]，＃8 ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。STR R0，[R1，＃8] ；将R0中的字数据写入以R1＋8为地址的存储器中。 C、LDM指令 (Load from memory into register / Load much)LDM指令的格式为： LDM {cond} &lt;模式&gt; Rn{!},reglist{^} LDM是将内存中堆栈内的数据，批量的赋值给寄存器，即是出栈操作 → LDM R0,｛R1-R3｝将R0指向的存储单元的数据依次加载到R1,R2,R3寄存器 D、STM指令 (Store from a register into memory / Store much)STM指令的格式为： STM {cond} &lt;模式&gt; Rn{!},reglist{^} STM：将一个寄存器列表的数据存储到指定的存储器 ← STM R0,{R1-R3} ;把R1,R2,R3保存到堆栈R0中 E、PUSH和POPPUSH:将寄存器值推入堆栈 压栈--&gt; POP：将堆栈值推出到寄存器 出栈 &lt;-- F、SWPSWP将寄存器与存储器之间的数据进行交换 SWP指令的格式为： SWP Rd,Rm,[Rn] Rd 为数据从存储器加载到的寄存器；Rm的数据用于存储到存储器中，若Rm与Rn相同，则为寄存器与存储器内容进行交换；Rn为要进行数据交换的存储器地址，Rn不能与Rd和Rm相同。 123SWP R1, R1 [R0] ;将R1寄存器与R0指向的存储单元的内容进行交换SWP R1, R2, [R0] ;把R0所指向的内容读到R1，同时把R2的内容写到 [R0] 7、数据传送指令MOV：将立即数或寄存器的数据传送到目标寄存器 ← 1MOV R0, #8 ;R0=8 8、数据算术运算指令​ ←​ ADD,SUB,MUL,DIV (加、减、乘、除)​ 有符号，无符号运算；带进位运算 9、数据算术运算指令与：AND或：ORR异或：EOR 移位：实质是乘，除，类似于小数点移位，但相反。小数点左移，数变小；右移变大。但逻辑移位，左移变大，右移变小，且按2的倍数进行，因为是2进制。 LSL：逻辑左移←LSR：逻辑右移← LSL R0,R1，#2 ；R0=R1*4 LSR R0,R1，#2 ；R0=R1*2 10、比较指令CMP：比较 1CMP R0 #0 ;R0寄存器中的值与0比较","link":"/20210906/ARM%E6%B1%87%E7%BC%96%E5%B0%8F%E7%BB%93/"},{"title":"ARM指令集","text":"1 、LDR 和 STR加载/存储字和无符号字节指令，使用单一数据传送指令(STR 和 LDR)来装载和存储，单一字节或字的数据从/到内存LDR指令用于从内存中读取数据放入寄存器中，STR指令用于将寄存器中的数据保存到内存。 指令格式如下： 1234567LDR{cond}{T} Rd,&lt;地址&gt; ;加载指定地址上的数据(字),放入 Rd 中 STR{cond}{T} Rd,&lt;地址&gt; ;存储数据(字)到指定地址的存储单元,要存储的数据在 Rd 中 LDR{cond}B{T} Rd,&lt;地址&gt; ;加载字节数据,放入 Rd 中,即 Rd 最低字节有效,高 24 位清零 STR{cond}B{T} Rd,&lt;地址&gt; ;存储字节数据,要存储的数据在 Rd,最低字节有效 2、LDM 和 STM批量加载/存储指令可以实现在一组寄存器和一块连续的内存单元之间传输数，LDM 为加载多个寄存器，STM 为存储多个寄存器，允许一条指令传送 16 个寄存器任何子集或所有寄存器。LDM /STM 的主要用途是现场保护、数据复制、参数传送等。 指令格式如下: 1234567LDM{cond}&lt;模式&gt; Rn{!},reglist{^} STM{cond}&lt;模式&gt; Rn{!},reglist{^} LDMIA R0!,{R3-R9} ;加载 R0 指向的地址上的多字数据,保存到 R3～R9 中,R0 值更新 STMIA R1!,{R3-R9} ;将 R3～R9 的数据存储到 R1 指向的地址上,R1 值更新 STMFD SP!,{R0-R7,LR} ;现场保存,将 R0～R7、LR 入栈 LDMFD SP!,{R0-R7,PC}^;恢复现场,异常处理返回 3、 SWP寄存器和存储器交换指令，SWP 指令用于将一个内存单元(该单元地址放在寄存器Rn 中)的内容读取到一个寄存器 Rd 中,同时将另一个寄存器 Rm 的内容写入到该内存单元中。 指令格式如下: SWP{cond}{B} Rd,Rm,[Rn]、 其中，B 为可选后缀,若有B，则交换字节，否则交换 32 位字；Rd 为数据从存储器加载到的寄存器；Rm 的数据用于存储到存储器中，若 Rm 与 Rn 相同，则为寄存器与存储器内容进行交换；Rn 为要进行数据交换的存储器地址,Rn 不能与 Rd 和 Rm 相同. SWP 指令举例如下： 123SWP R1,R1,[R0] ;将 R1 的内容与 R0 指向的存储单元的内容进行交换 SWP R1,R2,,[R0] ;将R0指向的存储单元内容读取一字节数据到R1中(高24 位清零),并将R2的内容写入到该内存单元中(最低字节有效) ​ ​ 数据传送指令4、MOV数据传送指令，将 8 位图立即数或寄存器(operant2)传送到目标寄存器 Rd，可用于移位运算等操作。 指令格式如下： MOV{cond}{S} Rd,operand2 MOV 指令举例如下: 12345MOV R1#0x10 ;R1=0x10 MOV R0,R1 ;R0=R1 MOVS R3,R1,LSL #2 ;R3=R1＜＜2,并影响标志位 MOV PC,LR ;PC=LR ,子程序返回 5、MVN数据非传送指令，将8 位图立即数或寄存器(operand2)按位取反后传送到目标寄存器(Rd)，因为其具有取反功能，所以可以装载范围更广的立即数。 指令格式如下: MVN{cond}{S} Rd,operand2 MVN 指令举例如下: 12MVN R1,#0xFF ;R1=0xFFFFFF00 MVN R1,R2 ;将 R2 取反,结果存到 R1 算术逻辑运算指令6、ADD加法运算指令，将 operand2 数据与 Rn 的值相加，结果保存到 Rd 寄存器。 指令格式如下： ADD{cond}{S} Rd,Rn,operand2 ADD 指令举例如下: 123ADDS R1,R1,#1 ;R1=R1+1 ADD R1,R1,R2 ;R1=R1+R2 ADDS R3,R1,R2,LSL #2 ;R3=R1+R2＜＜2 7、SUB减法运算指令，用寄存器 Rn 减去 operand2.结果保存到 Rd 中。 指令格式如下：SUB{cond}{S} Rd,Rn,operand2 SUB 指令举例如下： 1234SUBS R0,R0,#1 ;R0=R0-1 SUBS R2,R1,R2 ;R2=R1-R2 SUB R6,R7,#0x10 ;R6=R7-0x10 8、RSB逆向减法指令，用寄存器 operand2 减法 Rn，结果保存到 Rd 中。 指令格式如下：RSB{cond}{S} Rd,Rn,operand2 RSB 指令举例如下： 123RSB R3,R1,#0xFF00 ;R3=0xFF00-R1 RSBS R1,R2,R2,LSL #2 ;R1=R2＜＜2-R2=R2×3 RSB R0,R1,#0 ;R0=-R1 9、ADC带进位加法指令，将 operand2 的数据与 Rn 的值相加，再加上 CPSR 中的 C 条件标志位，结果保存到 Rd 寄存器。 指令格式如下; ADC{cond}{S} Rd,Rn,operand2 ADC 指令举例如下: 12ADDS R0,R0,R2 ADC R1,R1,R3 ;使用 ADC 实现 64 位加法,(R1、R0)=(R1、R0)+（R3、R2） 10、SBC带进位减法指令。用寄存器 Rn 减去 operand2，再减去 CPSR 中的 C 条件标志位的非（即若 C 标志清零，则结果减去 1），结果保存到 Rd 中。 指令格式如下： SCB{cond}{S} Rd,Rn,operand2 SBC 指令举例如下： 12SUBS R0，R0，R2 SBC R1，R1，R3 ;使用 SBC 实现 64 位减法,(R1,R0)-(R3,R2) 11、RSC带进位逆向减法指令。用寄存器 operand2 减去 Rn，再减去 CPSR 中的 C 条件标志位，结果保存到 Rd 中。 指令格式如下：RSC{cond}{S} Rd,Rn,operand2 RSC 指令举例如下： 12RSBS R2,R0,#0 RSC R3,R1,#0 ;使用 RSC 指令实现求 64 位数值的负数 12、AND逻辑与操作指令，将 operand2 值与寄存器 Rn 的值按位作逻辑与操作，结果保存到Rd 中。 指令格式如下： AND{cond}{S} Rd,Rn,operand2 AND 指令举例如下: 12ANDS R0,R0,#x01 ;R0=R0&amp;0x01,取出最低位数据 AND R2,R1,R3 ;R2=R1&amp;R3 13、ORR逻辑或操作指令，将operand2的值与寄存器Rn的值按位作逻辑或操作，结果保存到Rd 中。 指令格式如下：ORR{cond}{S} Rd,Rn,operand2 ORR 指令举例如下: 123ORR R0,R0,#x0F ;将 R0 的低 4 位置 1 MOV R1,R2,LSR #4 ORR R3,R1,R3,LSL #8 ;使用 ORR 指令将近 R2 的高 8 位数据移入到 R3 低 8 位 中 14、 EOR逻辑异或操作指令。将operand2的值与寄存器Rn的值按位作逻辑异或操作，结果保存到 Rd 中。 指令格式如下： EOR{cond}{S} Rd,Rn,operand2 EOR 指令举例如下 123EOR R1,R1,#0x0F ;将 R1 的低 4 位取反 EOR R2,R1,R0 ;R2=R1^R0 EORS R0,R5,#0x01 ;将 R5 和 0x01 进行逻辑异或,结果保存到 R0,并影响标志位","link":"/20211130/ARM%E6%8C%87%E4%BB%A4%E9%9B%86/"}],"tags":[{"name":"安卓逆向","slug":"安卓逆向","link":"/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"categories":[{"name":"安卓逆向","slug":"安卓逆向","link":"/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}]}