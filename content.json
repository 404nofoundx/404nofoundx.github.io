{"pages":[],"posts":[{"title":"ARM汇编小结","text":"一、ARM汇编规范1、书写规范 所有的符号都必须在一行书写，在后面不用添加高级语言所用的分号。 ARM汇编器对标识符的大小写敏感，书写符号以及指令时字母大小写一定要一致。 一条ARM指令，伪指令。寄存器名可以全部写为大写字母,也可以全部为小写字母, 但是不能大小写混合编写使用。 注释使用(分号)，注释内容由(分号)开始到执行结束。 例如：[符号] &lt;指令|条件|S&gt; &lt;操作数&gt;[;注释] 2、符号符号可以代表地址、变量、数字变量，当符号代表地址时又叫标号，符号就是变量的变量名、数字常量的名称、标号，符号的命名规则如下： 符号由大小写字母、数字以及下划线组成； 除局部标号以数字开头外，其它的符号不能以数字开头； 符号区分大小写，且所有字符都是有意义的； 符号在其作用域范围必须是唯一的； 符号不能与系统内部或系统预定义的符号同名； 符号不要与指令助记符、伪指令同名。 3、常量常量的分类：数字常数、字符常量、布尔常量 （1）数字常数有三种表示方式： 十进制数，如：12、5、876、0 十六进制数如：0x4387、0xFF0、0x1 n 进制数用n-XXX 表示，其中n 为2～9，XXX 为具体的数，如：2-010111、8-4363156 （2）字符常量 字符常量由一对单引号及中间字符串表示，标准C 语言中的转义符也可使用。如果需要包含双引号或$，必须使用”” “”和$$代替。 如：Hello SETS “Hello World！” Errorl SETS “The parameter ““VFH””error$$2” （3）布尔常量 布尔常量的逻辑真为{TRUE}，逻辑假为{FALSE}。 如： testno SETS {FALSE} 4、ARM指令的格式ARM是三地址指令格式，指令的基本格式为： 1234567&lt;opcode&gt; {&lt;cond&gt;} {s} &lt;Rd&gt;, &lt;Rn&gt; {,&lt;operand2&gt;} opcode: 指令助记符 cond: 执行条件 s: 是否影响CPSR寄存器的值 Rd: 目标寄存器 Rn: 第一个操作数的寄存器 operand2: 第二个操作数 其中&lt; &gt;号内为必须的，{ }里面的项是可选的 5、跳转指令B 无条件跳转 BEQ 相等后跳转 BNE 不相等后跳转 BL 带链接的无条件跳转 BX 带状态切换的无条件跳转 根据目标地址最低位切换状态（arm/thumb） BLX 带链接和状态切换的无条件跳转 B loc_地址 6.存储器与寄存器交互数据指令存储器（主存，内存）寄存器中放的数据：可以是字符串，可以是数，也可以是一个地址，它可以放各种类型的数据存储地址单元：地址（如0x00004000）与地址中存在的值 A、LDR指令 (Load from memory into register)LDR指令的格式： LDR{条件} 目的寄存器 &lt;存储器地址&gt; 作用：将存储器地址所指地址处连续的4个字节（1个字）的数据传送到目的寄存器中。 ← LDR指令的寻址方式比较灵活,实例如下： 123456789101112131415161718192021LDR R0，[R1] ；将存储器地址为R1的字数据读入寄存器R0。LDR R0，[R1，R2] ；将存储器地址为R1+R2的字数据读入寄存器R0。LDR R0，[R1，#8] ；将存储器地址为R1+8的字数据读入寄存器R0。LDR R0，[R1],R2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1],#8 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+8的值存入R1。LDR R0，[R1，R2]! ；将存储器地址为R1+R2的字数据读入寄存器R0，并将R1+R2的值存入R1。LDR R0，[R1，LSL #3] ；将存储器地址为R1*8的字数据读入寄存器R0。LDR R0，[R1，R2，LSL #2] ；将存储器地址为R1+R2*4的字数据读入寄存器R0。LDR R0，[R1,,R2，LSL #2]！ ；将存储器地址为R1+R2*4的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，[R1],R2，LSL #2 ；将存储器地址为R1的字数据读入寄存器R0，并将R1+R2*4的值存入R1。LDR R0，Label ；Label为程序标号，Label必须是当前指令的-4~4KB范围内。 B、STR指令 (Store from a register into memory)STR指令的格式为： STR{条件} 源寄存器，&lt;存储器地址&gt; STR指令用于从源寄存器中将一个32位的字数据传送到存储器中。→ 123456STR r1, [r0] ；将r1寄存器的值，传送到地址值为r0的（存储器）内存中STR R0，[R1]，＃8 ；将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1。STR R0，[R1，＃8] ；将R0中的字数据写入以R1＋8为地址的存储器中。 C、LDM指令 (Load from memory into register / Load much)LDM指令的格式为： LDM {cond} &lt;模式&gt; Rn{!},reglist{^} LDM是将内存中堆栈内的数据，批量的赋值给寄存器，即是出栈操作 → LDM R0,｛R1-R3｝将R0指向的存储单元的数据依次加载到R1,R2,R3寄存器 D、STM指令 (Store from a register into memory / Store much)STM指令的格式为： STM {cond} &lt;模式&gt; Rn{!},reglist{^} STM：将一个寄存器列表的数据存储到指定的存储器 ← STM R0,{R1-R3} ;把R1,R2,R3保存到堆栈R0中 E、PUSH和POPPUSH:将寄存器值推入堆栈 压栈--&gt; POP：将堆栈值推出到寄存器 出栈 &lt;-- F、SWPSWP将寄存器与存储器之间的数据进行交换 SWP指令的格式为： SWP Rd,Rm,[Rn] Rd 为数据从存储器加载到的寄存器；Rm的数据用于存储到存储器中，若Rm与Rn相同，则为寄存器与存储器内容进行交换；Rn为要进行数据交换的存储器地址，Rn不能与Rd和Rm相同。 123SWP R1, R1 [R0] ;将R1寄存器与R0指向的存储单元的内容进行交换SWP R1, R2, [R0] ;把R0所指向的内容读到R1，同时把R2的内容写到 [R0] 7、数据传送指令MOV：将立即数或寄存器的数据传送到目标寄存器 ← 1MOV R0, #8 ;R0=8 8、数据算术运算指令​ ←​ ADD,SUB,MUL,DIV (加、减、乘、除)​ 有符号，无符号运算；带进位运算 9、数据算术运算指令与：AND或：ORR异或：EOR 移位：实质是乘，除，类似于小数点移位，但相反。小数点左移，数变小；右移变大。但逻辑移位，左移变大，右移变小，且按2的倍数进行，因为是2进制。 LSL：逻辑左移←LSR：逻辑右移← LSL R0,R1，#2 ；R0=R1*4 LSR R0,R1，#2 ；R0=R1*2 10、比较指令CMP：比较 1CMP R0 #0 ;R0寄存器中的值与0比较","link":"/2021/09/06/ARM%E6%B1%87%E7%BC%96%E5%B0%8F%E7%BB%93/"}],"tags":[{"name":"安卓逆向","slug":"安卓逆向","link":"/tags/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}],"categories":[{"name":"安卓逆向","slug":"安卓逆向","link":"/categories/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91/"}]}